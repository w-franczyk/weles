
chdir(main)
fchdir() to previous dir
chdir(/etc)
fchdir() to previous dir
sourcing "/etc/vimrc"
line 1: if v:lang =~ "utf8$" || v:lang =~ "UTF-8$"
line 2:    set fileencodings=ucs-bom,utf-8,latin1
line 3: endif
line 4: 
line 5: set nocompatible^I" Use Vim defaults (much better!)
line 6: set bs=indent,eol,start^I^I" allow backspacing over everything in insert mode
line 7: "set ai^I^I^I" always set autoindenting on
line 8: "set backup^I^I" keep a backup file
line 9: set viminfo='20,\"50^I" read/write a .viminfo file, don't store more
line 10: ^I^I^I" than 50 lines of registers
line 11: set history=50^I^I" keep 50 lines of command line history
line 12: set ruler^I^I" show the cursor position all the time
line 13: 
line 14: " Only do this part when compiled with support for autocommands
line 15: if has("autocmd")
line 16:   augroup fedora
line 17:   autocmd!
line 18:   " In text files, always limit the width of text to 78 characters
line 19:   " autocmd BufRead *.txt set tw=78
line 20:   " When editing a file, always jump to the last cursor position
line 24:   autocmd BufReadPost * if line("'\"") > 0 && line ("'\"") <= line("$") |   exe "normal! g'\"" | endif
line 25:   " don't write swapfile on most commonly used directories for NFS mounts or USB sticks
line 26:   autocmd BufNewFile,BufReadPre /media/*,/run/media/*,/mnt/* set directory=~/tmp,/var/tmp,/tmp
line 27:   " start with spec file template
line 28:   autocmd BufNewFile *.spec 0r /usr/share/vim/vimfiles/template.spec
line 29:   augroup END
line 30: endif
line 31: 
line 32: if has("cscope") && filereadable("/usr/bin/cscope")
line 33:    set csprg=/usr/bin/cscope
line 34:    set csto=0
line 35:    set cst
line 36:    set nocsverb
line 37:    " add any database in current directory
line 38:    if filereadable("cscope.out")
line 39:       cs add $PWD/cscope.out
line 40:    " else add database pointed to by environment
line 41:    elseif $CSCOPE_DB != ""
line 42:       cs add $CSCOPE_DB
line 43:    endif
line 44:    set csverb
line 45: endif
line 46: 
line 47: " Switch syntax highlighting on, when the terminal has colors
line 48: " Also switch on highlighting the last used search pattern.
line 49: if &t_Co > 2 || has("gui_running")
line 50:   syntax on
line 50: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 50: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/w/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
line 76:   endif
line 77: endif
line 78: 
line 79: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
Searching for "filetype.vim" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 25: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2019 Mar 26
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: " When using this, the entry should probably be further down below with the
line 46: " other StarSetf() calls.
line 47: func! s:StarSetf(ft)
line 52: 
line 53: " Vim help file
line 54: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 55: 
line 56: " Abaqus or Trasys
line 57: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 58: 
line 59: " 8th (Firth-derivative)
line 60: au BufNewFile,BufRead *.8th^I^I^Isetf 8th
line 61: 
line 62: " A-A-P recipe
line 63: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 64: 
line 65: " A2ps printing utility
line 66: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 67: 
line 68: " ABAB/4
line 69: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 70: 
line 71: " ABC music notation
line 72: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 73: 
line 74: " ABEL
line 75: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 76: 
line 77: " AceDB
line 78: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 79: 
line 80: " Ada (83, 9X, 95)
line 81: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 82: if has("vms")
line 83:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 84: else
line 85:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 86: endif
line 87: 
line 88: " AHDL
line 89: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 90: 
line 91: " AMPL
line 92: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 93: 
line 94: " Ant
line 95: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 96: 
line 97: " Arduino
line 98: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 99: 
line 100: " Apache config file
line 101: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 102: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache
line 103: 
line 104: " XA65 MOS6510 cross assembler
line 105: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 106: 
line 107: " Applescript
line 108: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 109: 
line 110: " Applix ELF
line 112: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 113: 
line 114: " ALSA configuration
line 115: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 116: 
line 117: " Arc Macro Language
line 118: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 119: 
line 120: " APT config file
line 121: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 122: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 123: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 124: 
line 125: " Arch Inventory file
line 126: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 127: 
line 128: " ART*Enterprise (formerly ART-IM)
line 129: au BufNewFile,BufRead *.art^I^I^Isetf art
line 130: 
line 131: " AsciiDoc
line 132: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 133: 
line 134: " ASN.1
line 135: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 136: 
line 137: " Active Server Pages (with Visual Basic Script)
line 143: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 144: 
line 145: " Active Server Pages (with Perl or Visual Basic Script)
line 153: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 154: 
line 155: " Grub (must be before catch *.lst)
line 156: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 157: 
line 158: " Assembly (all kinds)
line 159: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 160: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 161: 
line 162: " Macro (VAX)
line 163: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 164: 
line 165: " Atlas
line 166: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 167: 
line 168: " Autoit v3
line 169: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 170: 
line 171: " Autohotkey
line 172: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 173: 
line 174: " Automake
line 175: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 176: 
line 177: " Autotest .at files are actually m4
line 178: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 179: 
line 180: " Avenue
line 181: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 182: 
line 183: " Awk
line 184: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 185: 
line 186: " B
line 187: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 188: 
line 189: " BASIC or Visual Basic
line 190: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")
line 191: 
line 192: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 193: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 194: 
line 195: " IBasic file (similar to QBasic)
line 196: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 197: 
line 198: " FreeBasic file (similar to QBasic)
line 199: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 200: 
line 201: " Batch file for MSDOS.
line 202: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 203: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 205: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 206: 
line 207: " Batch file for 4DOS
line 208: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 209: 
line 210: " BC calculator
line 211: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 212: 
line 213: " BDF font
line 214: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 215: 
line 216: " BibTeX bibliography database file
line 217: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 218: 
line 219: " BibTeX Bibliography Style
line 220: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 221: 
line 222: " BIND configuration
line 223: " sudoedit uses namedXXXX.conf
line 224: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 225: 
line 226: " BIND zone
line 227: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 228: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 229: 
line 230: " Blank
line 231: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 232: 
line 233: " Blkid cache file
line 234: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 235: 
line 236: " Bazel (http://bazel.io)
line 237: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl
line 238: if has("fname_case")
line 239:   " There is another check for BUILD further below.
line 240:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl
line 241: endif
line 242: 
line 243: " C or lpc
line 244: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 245: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 246: 
line 247: " Calendar
line 248: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 249: 
line 250: " C#
line 251: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 252: 
line 253: " CSDL
line 254: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 255: 
line 256: " Cabal
line 257: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 258: 
line 259: " Cdrdao TOC
line 260: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 261: 
line 262: " Cdrdao config
line 263: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 264: 
line 265: " Cfengine
line 266: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 267: 
line 268: " ChaiScript
line 269: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 270: 
line 271: " Comshare Dimension Definition Language
line 272: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 273: 
line 274: " Conary Recipe
line 275: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 276: 
line 277: " Controllable Regex Mutilator
line 278: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 279: 
line 280: " Cyn++
line 281: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 282: 
line 283: " Cynlib
line 284: " .cc and .cpp files can be C++ or Cynlib.
line 286: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 288: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 289: 
line 290: " C++
line 291: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 292: if has("fname_case")
line 293:   au BufNewFile,BufRead *.C,*.H setf cpp
line 294: endif
line 295: 
line 296: " .h files can be C, Ch C++, ObjC or ObjC++.
line 297: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 298: " detected automatically.
line 299: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 300: 
line 301: " Ch (CHscript)
line 302: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 303: 
line 304: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 305: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 306: 
line 307: " Cascading Style Sheets
line 308: au BufNewFile,BufRead *.css^I^I^Isetf css
line 309: 
line 310: " Century Term Command Scripts (*.cmd too)
line 311: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 312: 
line 313: " Changelog
line 315: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 316: 
line 322: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 323: 
line 327: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 328: 
line 329: " CHILL
line 330: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 331: 
line 332: " Changes for WEB and CWEB or CHILL
line 333: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 334: 
line 335: " ChordPro
line 336: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 337: 
line 338: " Clean
line 339: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 340: 
line 341: " Clever
line 342: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 343: 
line 344: " Clever or dtd
line 345: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 346: 
line 347: " Clipper (or FoxPro; could also be eviews)
line 353: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 354: 
line 355: " Clojure
line 356: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 357: 
line 358: " Cmake
line 359: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 360: 
line 361: " Cmusrc
line 362: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 363: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 364: 
line 365: " Cobol
line 366: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 367: "   cobol or zope form controller python script? (heuristic)
line 373: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 374: 
line 375: " Coco/R
line 376: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 377: 
line 378: " Cold Fusion
line 379: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 380: 
line 381: " Configure scripts
line 382: au BufNewFile,BufRead configure.in,configure.ac setf config
line 383: 
line 384: " CUDA  Cumpute Unified Device Architecture
line 385: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 386: 
line 387: " Dockerfile
line 388: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile
line 389: 
line 390: " WildPackets EtherPeek Decoder
line 391: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 392: 
line 393: " Enlightenment configuration files
line 394: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 395: 
line 396: " Eterm
line 397: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 398: 
line 399: " Euphoria 3 or 4
line 400: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 401: if has("fname_case")
line 402:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 403: endif
line 404: 
line 405: " Lynx config files
line 406: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 407: 
line 408: " Quake
line 409: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 410: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 411: 
line 412: " Quake C
line 413: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 414: 
line 415: " Configure files
line 416: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 417: 
line 418: " Cucumber
line 419: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 420: 
line 421: " Communicating Sequential Processes
line 422: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 423: 
line 424: " CUPL logic description and simulation
line 425: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 426: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 427: 
line 428: " Debian Control
line 429: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 433: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 434: 
line 435: " Debian Copyright
line 436: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 440: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 441: 
line 442: " Debian Sources.list
line 443: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 444: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 445: 
line 446: " Deny hosts
line 447: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 448: 
line 449: " dnsmasq(8) configuration files
line 450: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 451: 
line 452: " ROCKLinux package description
line 453: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 454: 
line 455: " the D language or dtrace
line 456: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 457: 
line 458: " Desktop files
line 459: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 460: 
line 461: " Dict config
line 462: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 463: 
line 464: " Dictd config
line 465: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 466: 
line 467: " Diff files
line 468: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 474: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 475: 
line 476: " Dircolors
line 477: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 478: 
line 479: " Diva (with Skill) or InstallShield
line 485: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 486: 
line 487: " DCL (Digital Command Language - vms) or DNS zone file
line 488: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 489: 
line 490: " DOT
line 491: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 492: 
line 493: " Dylan - lid files
line 494: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 495: 
line 496: " Dylan - intr files (melange)
line 497: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 498: 
line 499: " Dylan
line 500: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 501: 
line 502: " Microsoft Module Definition
line 503: au BufNewFile,BufRead *.def^I^I^Isetf def
line 504: 
line 505: " Dracula
line 506: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 507: 
line 508: " Datascript
line 509: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 510: 
line 511: " dsl
line 512: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 513: 
line 514: " DTD (Document Type Definition for XML)
line 515: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 516: 
line 517: " DTS/DSTI (device tree files)
line 518: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 519: 
line 520: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 521: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 527: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 528: 
line 529: " EditorConfig (close enough to dosini)
line 530: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
line 531: 
line 532: " Embedix Component Description
line 533: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 534: 
line 535: " Eiffel or Specman or Euphoria
line 536: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 537: 
line 538: " Elinks configuration
line 539: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 540: 
line 541: " ERicsson LANGuage; Yaws is erlang too
line 542: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 543: 
line 544: " Elm Filter Rules file
line 545: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 546: 
line 547: " ESMTP rc file
line 548: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 549: 
line 550: " ESQL-C
line 551: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 552: 
line 553: " Esterel
line 554: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 555: 
line 556: " Essbase script
line 557: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 558: 
line 559: " Exim
line 560: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 561: 
line 562: " Expect
line 563: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 564: 
line 565: " Exports
line 566: au BufNewFile,BufRead exports^I^I^Isetf exports
line 567: 
line 568: " Falcon
line 569: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 570: 
line 571: " Fantom
line 572: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 573: 
line 574: " Factor
line 575: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 576: 
line 577: " Fetchmail RC file
line 578: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 579: 
line 580: " FlexWiki - disabled, because it has side effects when a .wiki file
line 581: " is not actually FlexWiki
line 582: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 583: 
line 584: " Focus Executable
line 585: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 586: 
line 587: " Focus Master file (but not for auto.master)
line 588: au BufNewFile,BufRead auto.master^I^Isetf conf
line 589: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 590: 
line 591: " Forth
line 592: au BufNewFile,BufRead *.fs,*.ft,*.fth^I^Isetf forth
line 593: 
line 594: " Reva Forth
line 595: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 596: 
line 597: " Fortran
line 598: if has("fname_case")
line 599:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 600: endif
line 601: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 602: 
line 603: " Framescript
line 604: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 605: 
line 606: " FStab
line 607: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 608: 
line 609: " GDB command files
line 610: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 611: 
line 612: " GDMO
line 613: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 614: 
line 615: " Gedcom
line 616: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 617: 
line 618: " Git
line 619: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG ^Isetf gitcommit
line 620: au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig ^Isetf gitconfig
line 621: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 622: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 623: if !empty($XDG_CONFIG_HOME)
line 624:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 625: endif
line 626: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 627: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
line 631: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 635: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 636: 
line 637: " Gkrellmrc
line 638: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 639: 
line 640: " GP scripts (2.0 and onward)
line 641: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 642: 
line 643: " GPG
line 644: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 645: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 646: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 647: if !empty($GNUPGHOME)
line 648:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 649:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 650: endif
line 651: 
line 652: " gnash(1) configuration files
line 653: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 654: 
line 655: " Gitolite
line 656: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 657: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 658: 
line 659: " Gnuplot scripts
line 660: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 661: 
line 662: " Go (Google)
line 663: au BufNewFile,BufRead *.go^I^I^Isetf go
line 664: 
line 665: " GrADS scripts
line 666: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 667: 
line 668: " Gretl
line 669: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 670: 
line 671: " Groovy
line 672: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 673: 
line 674: " GNU Server Pages
line 675: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 676: 
line 677: " Group file
line 678: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 679: 
line 680: " GTK RC
line 681: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 682: 
line 683: " Haml
line 684: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 685: 
line 686: " Hamster Classic | Playground files
line 687: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 688: 
line 689: " Haskell
line 690: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 691: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 692: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 693: 
line 694: " Haste
line 695: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 696: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 697: 
line 698: " Hercules
line 699: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 700: 
line 701: " HEX (Intel)
line 702: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 703: 
line 704: " Tilde (must be before HTML)
line 705: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 706: 
line 707: " HTML (.shtml and .stm for server side)
line 708: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 709: 
line 710: " HTML with Ruby - eRuby
line 711: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 712: 
line 713: " HTML with M4
line 714: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 715: 
line 716: " HTML Cheetah template
line 717: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 718: 
line 719: " Host config
line 720: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 721: 
line 722: " Hosts access
line 723: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 724: 
line 725: " Hyper Builder
line 726: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 727: 
line 728: " Httest
line 729: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 730: 
line 731: " Icon
line 732: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 733: 
line 734: " IDL (Interface Description Language)
line 735: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 736: 
line 737: " Microsoft IDL (Interface Description Language)  Also *.idl
line 738: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 739: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 740: 
line 741: " Icewm menu
line 742: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 743: 
line 744: " Indent profile (must come before IDL *.pro!)
line 745: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 746: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 747: 
line 748: " IDL (Interactive Data Language)
line 749: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 750: 
line 751: " Indent RC
line 752: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 753: 
line 754: " Inform
line 755: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 756: 
line 757: " Initng
line 758: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 759: 
line 760: " Innovation Data Processing
line 761: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 762: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
line 763: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 764: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 765: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 766: 
line 767: " Ipfilter
line 768: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 769: 
line 770: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 771: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 772: 
line 773: " .INI file for MSDOS
line 774: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 775: 
line 776: " SysV Inittab
line 777: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 778: 
line 779: " Inno Setup
line 780: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 781: 
line 782: " J
line 783: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 784: 
line 785: " JAL
line 786: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 787: 
line 788: " Jam
line 789: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 790: 
line 791: " Java
line 792: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 793: 
line 794: " JavaCC
line 795: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 796: 
line 797: " JavaScript, ECMAScript
line 798: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
line 799: 
line 800: " Java Server Pages
line 801: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 802: 
line 803: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 804: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 805: 
line 806: " Jess
line 807: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 808: 
line 809: " Jgraph
line 810: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 811: 
line 812: " Jovial
line 813: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 814: 
line 815: " JSON
line 816: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 817: 
line 818: " Kixtart
line 819: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 820: 
line 821: " Kimwitu[++]
line 822: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 823: 
line 824: " Kivy
line 825: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 826: 
line 827: " KDE script
line 828: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 829: 
line 830: " Kconfig
line 831: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 832: 
line 833: " Lace (ISE)
line 834: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 835: 
line 836: " Latte
line 837: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 838: 
line 839: " Limits
line 840: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 841: 
line 842: " LambdaProlog (*.mod too, see Modsim)
line 843: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 844: 
line 845: " LDAP LDIF
line 846: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 847: 
line 848: " Ld loader
line 849: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 850: 
line 851: " Less
line 852: au BufNewFile,BufRead *.less^I^I^Isetf less
line 853: 
line 854: " Lex
line 855: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 856: 
line 857: " Libao
line 858: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 859: 
line 860: " Libsensors
line 861: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 862: 
line 863: " LFTP
line 864: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 865: 
line 866: " Lifelines (or Lex for C++!)
line 867: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 868: 
line 869: " Lilo: Linux loader
line 870: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 871: 
line 872: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 873: if has("fname_case")
line 874:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 875: else
line 876:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 877: endif
line 878: 
line 879: " SBCL implementation of Common Lisp
line 880: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 881: 
line 882: " Liquid
line 883: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 884: 
line 885: " Lite
line 886: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 887: 
line 888: " LiteStep RC files
line 889: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 890: 
line 891: " Login access
line 892: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 893: 
line 894: " Login defs
line 895: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 896: 
line 897: " Logtalk
line 898: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 899: 
line 900: " LOTOS
line 901: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 902: 
line 903: " Lout (also: *.lt)
line 904: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 905: 
line 906: " Lua
line 907: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 908: 
line 909: " Luarocks
line 910: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 911: 
line 912: " Linden Scripting Language (Second Life)
line 913: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 914: 
line 915: " Lynx style file (or LotusScript!)
line 916: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 917: 
line 918: " M4
line 920: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 921: 
line 922: " MaGic Point
line 923: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 924: 
line 925: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 926: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 927: 
line 928: " Mail aliases
line 929: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 930: 
line 931: " Mailcap configuration file
line 932: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 933: 
line 934: " Makefile
line 935: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 936: 
line 937: " MakeIndex
line 938: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 939: 
line 940: " Mallard
line 941: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 942: 
line 943: " Manpage
line 944: au BufNewFile,BufRead *.man^I^I^Isetf man
line 945: 
line 946: " Man config
line 947: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 948: 
line 949: " Maple V
line 950: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 951: 
line 952: " Map (UMN mapserver config file)
line 953: au BufNewFile,BufRead *.map^I^I^Isetf map
line 954: 
line 955: " Markdown
line 956: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 957: 
line 958: " Mason
line 959: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 960: 
line 961: " Mathematica, Matlab, Murphi or Objective C
line 962: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 963: 
line 964: " Mathematica notebook
line 965: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 966: 
line 967: " Maya Extension Language
line 968: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 969: 
line 970: " Mercurial (hg) commit file
line 971: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 972: 
line 973: " Mercurial config (looks like generic config file)
line 974: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 975: 
line 976: " Messages (logs mostly)
line 977: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 978: 
line 979: " Metafont
line 980: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 981: 
line 982: " MetaPost
line 983: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 984: 
line 985: " MGL
line 986: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 987: 
line 988: " MIX - Knuth assembly
line 989: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 990: 
line 991: " MMIX or VMS makefile
line 992: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 993: 
line 994: " Symbian meta-makefile definition (MMP)
line 995: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 996: 
line 997: " Modsim III (or LambdaProlog)
line 1003: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1004: 
line 1005: " Modula 2  (.md removed in favor of Markdown)
line 1006: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1007: 
line 1008: " Modula 3 (.m3, .i3, .mg, .ig)
line 1009: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1010: 
line 1011: " Monk
line 1012: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1013: 
line 1014: " MOO
line 1015: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1016: 
line 1017: " Modconf
line 1018: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1019: 
line 1020: " Mplayer config
line 1021: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1022: 
line 1023: " Motorola S record
line 1024: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1025: 
line 1026: " Mrxvtrc
line 1027: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1028: 
line 1029: " Msql
line 1030: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1031: 
line 1032: " Mysql
line 1033: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1034: 
line 1035: " Mutt setup files (must be before catch *.rc)
line 1036: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1037: 
line 1038: " M$ Resource files
line 1039: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1040: 
line 1041: " MuPAD source
line 1042: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1043: 
line 1044: " Mush
line 1045: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1046: 
line 1047: " Mutt setup file (also for Muttng)
line 1048: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1049: 
line 1050: " N1QL
line 1051: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1052: 
line 1053: " Nano
line 1054: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1055: 
line 1056: " Nastran input/DMAP
line 1057: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1058: 
line 1059: " Natural
line 1060: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1061: 
line 1062: " Noemutt setup file
line 1063: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1064: 
line 1065: " Netrc
line 1066: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1067: 
line 1068: " Ninja file
line 1069: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1070: 
line 1071: " Novell netware batch files
line 1072: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1073: 
line 1074: " Nroff/Troff (*.ms and *.t are checked below)
line 1078: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1079: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1080: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1081: 
line 1082: " Nroff or Objective C++
line 1083: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1084: 
line 1085: " Not Quite C
line 1086: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1087: 
line 1088: " NSE - Nmap Script Engine - uses Lua syntax
line 1089: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1090: 
line 1091: " NSIS
line 1092: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1093: 
line 1094: " OCAML
line 1095: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1096: 
line 1097: " Occam
line 1098: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1099: 
line 1100: " Omnimark
line 1101: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1102: 
line 1103: " OpenROAD
line 1104: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1105: 
line 1106: " OPL
line 1107: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1108: 
line 1109: " Oracle config file
line 1110: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1111: 
line 1112: " Packet filter conf
line 1113: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1114: 
line 1115: " Pam conf
line 1116: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1117: 
line 1118: " PApp
line 1119: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1120: 
line 1121: " Password file
line 1122: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1123: 
line 1124: " Pascal (also *.p)
line 1125: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1126: 
line 1127: " Delphi project file
line 1128: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1129: 
line 1130: " PDF
line 1131: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1132: 
line 1133: " PCMK - HAE - crm configure edit
line 1134: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk
line 1135: 
line 1136: " Perl
line 1137: if has("fname_case")
line 1138:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()
line 1139: else
line 1140:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()
line 1141: endif
line 1142: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
line 1143: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1144: 
line 1145: " Perl, XPM or XPM2
line 1153: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1154: 
line 1155: " Perl POD
line 1156: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1157: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1158: 
line 1159: " Php, php3, php4, etc.
line 1160: " Also Phtml (was used for PHP 2 in the past)
line 1161: " Also .ctp for Cake template file
line 1162: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1163: 
line 1164: " Pike and Cmod
line 1165: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1166: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1167: 
line 1168: " Pinfo config
line 1169: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1170: 
line 1171: " Palm Resource compiler
line 1172: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1173: 
line 1174: " Pine config
line 1175: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1176: 
line 1177: " PL/1, PL/I
line 1178: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1179: 
line 1180: " PL/M (also: *.inp)
line 1181: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1182: 
line 1183: " PL/SQL
line 1184: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1185: 
line 1186: " PLP
line 1187: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1188: 
line 1189: " PO and PO template (GNU gettext)
line 1190: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1191: 
line 1192: " Postfix main config
line 1193: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1194: 
line 1195: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1196: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1197: 
line 1198: " PostScript Printer Description
line 1199: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1200: 
line 1201: " Povray
line 1202: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1203: 
line 1204: " Povray configuration
line 1205: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1206: 
line 1207: " Povray, PHP or assembly
line 1208: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1209: 
line 1210: " Printcap and Termcap
line 1212: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1214: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1215: 
line 1216: " PCCTS / ANTRL
line 1217: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1218: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1219: 
line 1220: " PPWizard
line 1221: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1222: 
line 1223: " Obj 3D file format
line 1224: " TODO: is there a way to avoid MS-Windows Object files?
line 1225: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1226: 
line 1227: " Oracle Pro*C/C++
line 1228: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1229: 
line 1230: " Privoxy actions file
line 1231: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1232: 
line 1233: " Procmail
line 1234: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1235: 
line 1236: " Progress or CWEB
line 1237: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1238: 
line 1239: " Progress or assembly
line 1240: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()
line 1241: 
line 1242: " Progress or Pascal
line 1243: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1244: 
line 1245: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1246: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1250: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1251: 
line 1252: " Prolog
line 1253: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1254: 
line 1255: " Promela
line 1256: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1257: 
line 1258: " Google protocol buffers
line 1259: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1260: 
line 1261: " Protocols
line 1262: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1263: 
line 1264: " Pyrex
line 1265: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1266: 
line 1267: " Python, Python Shell Startup and Python Stub Files
line 1268: " Quixote (Python-based web framework)
line 1269: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl,*.pyi  setf python
line 1270: 
line 1271: " Radiance
line 1272: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1273: 
line 1274: " Ratpoison config/command files
line 1275: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1276: 
line 1277: " RCS file
line 1278: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1279: 
line 1280: " Readline
line 1281: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1282: 
line 1283: " Registry for MS-Windows
line 1285: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1286: 
line 1287: " Renderman Interface Bytestream
line 1288: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1289: 
line 1290: " Rexx
line 1291: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1292: 
line 1293: " R (Splus)
line 1294: if has("fname_case")
line 1295:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1296: else
line 1297:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1298: endif
line 1299: 
line 1300: " R Help file
line 1301: if has("fname_case")
line 1302:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1303: else
line 1304:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1305: endif
line 1306: 
line 1307: " R noweb file
line 1308: if has("fname_case")
line 1309:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1310: else
line 1311:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1312: endif
line 1313: 
line 1314: " R Markdown file
line 1315: if has("fname_case")
line 1316:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1317: else
line 1318:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1319: endif
line 1320: 
line 1321: " R reStructuredText file
line 1322: if has("fname_case")
line 1323:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1324: else
line 1325:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1326: endif
line 1327: 
line 1328: " Rexx, Rebol or R
line 1329: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 1330: 
line 1331: " Remind
line 1332: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1333: 
line 1334: " Resolv.conf
line 1335: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1336: 
line 1337: " Relax NG Compact
line 1338: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1339: 
line 1340: " Relax NG XML
line 1341: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1342: 
line 1343: " RPL/2
line 1344: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1345: 
line 1346: " Robots.txt
line 1347: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1348: 
line 1349: " Rpcgen
line 1350: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1351: 
line 1352: " reStructuredText Documentation Format
line 1353: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1354: 
line 1355: " RTF
line 1356: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1357: 
line 1358: " Interactive Ruby shell
line 1359: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1360: 
line 1361: " Ruby
line 1362: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1363: 
line 1364: " RubyGems
line 1365: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1366: 
line 1367: " Rust
line 1368: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1369: 
line 1370: " Rackup
line 1371: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1372: 
line 1373: " Bundler
line 1374: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1375: 
line 1376: " Ruby on Rails
line 1377: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1378: 
line 1379: " Rantfile and Rakefile is like Ruby
line 1380: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1381: 
line 1382: " S-lang (or shader language, or SmallLisp)
line 1383: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1384: 
line 1385: " Samba config
line 1386: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1387: 
line 1388: " SAS script
line 1389: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1390: 
line 1391: " Sass
line 1392: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1393: 
line 1394: " Sather
line 1395: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1396: 
line 1397: " Scala
line 1398: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1399: 
line 1400: " SBT - Scala Build Tool
line 1401: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1402: 
line 1403: " Scilab
line 1404: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1405: 
line 1406: " SCSS
line 1407: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1408: 
line 1409: " SD: Streaming Descriptors
line 1410: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1411: 
line 1412: " SDL
line 1413: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1414: 
line 1415: " sed
line 1416: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1417: 
line 1418: " Sieve (RFC 3028, 5228)
line 1419: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 1420: 
line 1421: " Sendmail
line 1422: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1423: 
line 1424: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1425: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 1426: 
line 1427: " Services
line 1428: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1429: 
line 1430: " Service Location config
line 1431: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1432: 
line 1433: " Service Location registration
line 1434: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1435: 
line 1436: " Service Location SPI
line 1437: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1438: 
line 1439: " Setserial config
line 1440: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1441: 
line 1442: " SGML
line 1452: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1453: 
line 1454: " SGMLDECL
line 1458: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1459: 
line 1460: " SGML catalog file
line 1461: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1462: 
line 1463: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1464: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
line 1465: " NOTE: Patterns ending in a star are further down, these have lower priority.
line 1466: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD call dist#ft#SetFileTypeSH("bash")
line 1467: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 1468: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
line 1469: 
line 1470: 
line 1471: " Shell script (Arch Linux) or PHP file (Drupal)
line 1477: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 1478: 
line 1479: " tcsh scripts (patterns ending in a star further below)
line 1480: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 1481: 
line 1482: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1483: " (patterns ending in a start further below)
line 1484: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 1485: 
line 1486: " Z-Shell script (patterns ending in a star further below)
line 1487: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1488: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
line 1489: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1490: 
line 1491: " Scheme
line 1492: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1493: 
line 1494: " Screen RC
line 1495: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1496: 
line 1497: " Simula
line 1498: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1499: 
line 1500: " SINDA
line 1501: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1502: 
line 1503: " SiSU
line 1504: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1505: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1506: 
line 1507: " SKILL
line 1508: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1509: 
line 1510: " SLRN
line 1511: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1512: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1513: 
line 1514: " Smalltalk (and TeX)
line 1515: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1523: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1524: 
line 1525: " Smarty templates
line 1526: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1527: 
line 1528: " SMIL or XML
line 1534: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1535: 
line 1536: " SMIL or SNMP MIB file
line 1542: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1543: 
line 1544: " SMITH
line 1545: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1546: 
line 1547: " Snobol4 and spitbol
line 1548: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1549: 
line 1550: " SNMP MIB files
line 1551: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1552: 
line 1553: " Snort Configuration
line 1554: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1555: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 1556: 
line 1557: " Spec (Linux RPM)
line 1558: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1559: 
line 1560: " Speedup (AspenTech plant simulator)
line 1561: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1562: 
line 1563: " Slice
line 1564: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 1565: 
line 1566: " Spice
line 1567: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 1568: 
line 1569: " Spyce
line 1570: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 1571: 
line 1572: " Squid
line 1573: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 1574: 
line 1575: " SQL for Oracle Designer
line 1576: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 1577: 
line 1578: " SQL
line 1579: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 1580: 
line 1581: " SQLJ
line 1582: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 1583: 
line 1584: " SQR
line 1585: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 1586: 
line 1587: " OpenSSH configuration
line 1588: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 1589: 
line 1590: " OpenSSH server configuration
line 1591: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 1592: 
line 1593: " Stata
line 1594: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 1595: " Also *.class, but not when it's a Java bytecode file
line 1597: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 1598: 
line 1599: " SMCL
line 1600: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 1601: 
line 1602: " Stored Procedures
line 1603: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 1604: 
line 1605: " Standard ML
line 1606: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 1607: 
line 1608: " Sratus VOS command macro
line 1609: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 1610: 
line 1611: " Sysctl
line 1612: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 1613: 
line 1614: " Systemd unit files
line 1615: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 1616: " Systemd overrides
line 1617: au BufNewFile,BufRead /etc/systemd/system/*.d/*.conf^Isetf systemd
line 1618: " Systemd temp files
line 1619: au BufNewFile,BufRead /etc/systemd/system/*.d/.#*^Isetf systemd
line 1620: 
line 1621: " Synopsys Design Constraints
line 1622: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 1623: 
line 1624: " Sudoers
line 1625: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 1626: 
line 1627: " SVG (Scalable Vector Graphics)
line 1628: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 1629: 
line 1630: " Tads (or Nroff or Perl test file)
line 1632: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 1633: 
line 1634: " Tags
line 1635: au BufNewFile,BufRead tags^I^I^Isetf tags
line 1636: 
line 1637: " TAK
line 1638: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 1639: 
line 1640: " Task
line 1641: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 1642: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 1643: 
line 1644: " Tcl (JACL too)
line 1645: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 1646: 
line 1647: " TealInfo
line 1648: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 1649: 
line 1650: " Telix Salt
line 1651: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 1652: 
line 1653: " Tera Term Language
line 1654: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 1655: 
line 1656: " Terminfo
line 1657: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 1658: 
line 1659: " TeX
line 1660: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 1661: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 1662: 
line 1663: " ConTeXt
line 1664: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
line 1665: 
line 1666: " Texinfo
line 1667: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 1668: 
line 1669: " TeX configuration
line 1670: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 1671: 
line 1672: " Tidy config
line 1673: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 1674: 
line 1675: " TF mud client
line 1676: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 1677: 
line 1678: " tmux configuration
line 1679: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 1680: 
line 1681: " TPP - Text Presentation Program
line 1682: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 1683: 
line 1684: " Treetop
line 1685: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 1686: 
line 1687: " Trustees
line 1688: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 1689: 
line 1690: " TSS - Geometry
line 1691: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 1692: 
line 1693: " TSS - Optics
line 1694: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 1695: 
line 1696: " TSS - Command Line (temporary)
line 1697: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 1698: 
line 1699: " TWIG files
line 1700: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 1701: 
line 1702: " Motif UIT/UIL files
line 1703: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 1704: 
line 1705: " Udev conf
line 1706: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 1707: 
line 1708: " Udev permissions
line 1709: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 1710: "
line 1711: " Udev symlinks config
line 1712: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 1713: 
line 1714: " UnrealScript
line 1715: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 1716: 
line 1717: " Updatedb
line 1718: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 1719: 
line 1720: " Upstart (init(8)) config files
line 1721: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 1722: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 1723: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 1724: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 1725: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 1726: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 1727: 
line 1728: " Vera
line 1729: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 1730: 
line 1731: " Verilog HDL
line 1732: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 1733: 
line 1734: " Verilog-AMS HDL
line 1735: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 1736: 
line 1737: " SystemVerilog
line 1738: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 1739: 
line 1740: " VHDL
line 1741: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 1742: 
line 1743: " Vim script
line 1744: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 1745: 
line 1746: " Viminfo file
line 1747: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 1748: 
line 1749: " Virata Config Script File or Drupal module
line 1755: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 1756: 
line 1757: " Visual Basic (also uses *.bas) or FORM
line 1758: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")
line 1759: 
line 1760: " SaxBasic is close to Visual Basic
line 1761: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 1762: 
line 1763: " Vgrindefs file
line 1764: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 1765: 
line 1766: " VRML V1.0c
line 1767: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 1768: 
line 1769: " Vroom (vim testing and executable documentation)
line 1770: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 1771: 
line 1772: " Webmacro
line 1773: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 1774: 
line 1775: " WebAssembly
line 1776: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast
line 1777: 
line 1778: " Wget config
line 1779: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 1780: 
line 1781: " Website MetaLanguage
line 1782: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 1783: 
line 1784: " Winbatch
line 1785: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 1786: 
line 1787: " WSML
line 1788: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 1789: 
line 1790: " WPL
line 1791: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 1792: 
line 1793: " WvDial
line 1794: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 1795: 
line 1796: " CVS RC file
line 1797: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 1798: 
line 1799: " CVS commit file
line 1800: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 1801: 
line 1802: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 1803: " lines in a WEB file).
line 1809: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 1810: 
line 1811: " Windows Scripting Host and Windows Script Component
line 1812: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 1813: 
line 1814: " XHTML
line 1815: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 1816: 
line 1817: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 1823: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 1824: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 1825: 
line 1826: " XFree86 config
line 1831: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 1834: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1835: 
line 1836: " Xorg config
line 1837: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1838: 
line 1839: " Xinetd conf
line 1840: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 1841: 
line 1842: " XS Perl extension interface language
line 1843: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 1844: 
line 1845: " X resources file
line 1846: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 1847: 
line 1848: " Xmath
line 1849: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 1851: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 1852: 
line 1853: " XML  specific variants: docbk and xbl
line 1854: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 1855: 
line 1856: " XMI (holding UML models) is also XML
line 1857: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 1858: 
line 1859: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 1860: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 1861: 
line 1862: " Qt Linguist translation source and Qt User Interface Files are XML
line 1863: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 1864: 
line 1865: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 1866: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 1867: 
line 1868: " Xdg menus
line 1869: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 1870: 
line 1871: " ATI graphics driver configuration
line 1872: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 1873: 
line 1874: " Web Services Description Language (WSDL)
line 1875: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 1876: 
line 1877: " XLIFF (XML Localisation Interchange File Format) is also XML
line 1878: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 1879: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 1880: 
line 1881: " XML User Interface Language
line 1882: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 1883: 
line 1884: " X11 xmodmap (also see below)
line 1885: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 1886: 
line 1887: " Xquery
line 1888: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 1889: 
line 1890: " XSD
line 1891: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 1892: 
line 1893: " Xslt
line 1894: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 1895: 
line 1896: " Yacc
line 1897: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 1898: 
line 1899: " Yacc or racc
line 1900: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 1901: 
line 1902: " Yaml
line 1903: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 1904: 
line 1905: " Raml
line 1906: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 1907: 
line 1908: " yum conf (close enough to dosini)
line 1909: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 1910: 
line 1911: " Zimbu
line 1912: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 1913: " Zimbu Templates
line 1914: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 1915: 
line 1916: " Zope
line 1917: "   dtml (zope dynamic template markup language), pt (zope page template),
line 1918: "   cpt (zope form controller page template)
line 1919: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 1920: "   zsql (zope sql method)
line 1921: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 1922: 
line 1923: " Z80 assembler asz80
line 1924: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 1925: 
line 1926: augroup END
line 1927: 
line 1928: 
line 1929: " Source the user-specified filetype file, for backwards compatibility with
line 1930: " Vim 5.x.
line 1931: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 1932:   execute "source " . myfiletypefile
line 1933: endif
line 1934: 
line 1935: 
line 1936: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 1937: " when there are no matching file name extensions.
line 1938: " Don't do this for compressed files.
line 1939: augroup filetypedetect
line 1942: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 1943: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 1944: 
line 1945: 
line 1946: " Extra checks for when no filetype has been detected now.  Mostly used for
line 1947: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 1948: " script file.
line 1949: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 1950: " like are used.
line 1951: 
line 1952: " More Apache style config files
line 1953: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 1954: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')
line 1955: 
line 1956: " More Apache config files
line 1957: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 1958: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*,auth_mysql.conf*,auth_pgsql.conf*,ssl.conf*,perl.conf*,php.conf*,python.conf*,squirrelmail.conf*^I^Icall s:StarSetf('apache')
line 1959: 
line 1960: " Asterisk config file
line 1961: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 1962: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 1963: 
line 1964: " Bazaar version control
line 1965: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 1966: 
line 1967: " Bazel build file
line 1968: if !has("fname_case")
line 1969:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
line 1970: endif
line 1971: 
line 1972: " BIND zone
line 1973: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 1974: 
line 1975: " Calendar
line 1978: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 1979: 
line 1980: " Changelog
line 1986: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 1987: 
line 1988: " Crontab
line 1989: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 1990: 
line 1991: " dnsmasq(8) configuration
line 1992: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 1993: 
line 1994: " Dracula
line 1995: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 1996: 
line 1997: " Fvwm
line 1998: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2000: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2006: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2007: 
line 2008: " Gedcom
line 2009: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2010: 
line 2011: " Git
line 2012: au BufNewFile,BufRead */.gitconfig.d/*,/etc/gitconfig.d/* ^Icall s:StarSetf('gitconfig')
line 2013: 
line 2014: " Gitolite
line 2015: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 2016: 
line 2017: " GTK RC
line 2018: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2019: 
line 2020: " Jam
line 2021: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2022: 
line 2023: " Jargon
line 2027: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2028: 
line 2029: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 2030: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 2031: 
line 2032: " Kconfig
line 2033: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2034: 
line 2035: " Lilo: Linux loader
line 2036: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2037: 
line 2038: " Logcheck
line 2039: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2040: 
line 2041: " Makefile
line 2042: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2043: 
line 2044: " Ruby Makefile
line 2045: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2046: 
line 2047: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2048: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2049: 
line 2050: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2051: 
line 2052: " Modconf
line 2056: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2057: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2058: 
line 2059: " Mutt setup file
line 2060: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2061: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2062: 
line 2063: " Neomutt setup file
line 2064: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 2065: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 2066: 
line 2067: " Nroff macros
line 2068: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2069: 
line 2070: " OpenBSD hostname.if
line 2071: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
line 2072: 
line 2073: " Pam conf
line 2074: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2075: 
line 2076: " Printcap and Termcap
line 2080: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2084: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2085: 
line 2086: " ReDIF
line 2087: " Only used when the .rdf file was not detected to be XML.
line 2088: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 2089: 
line 2090: " Remind
line 2091: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2092: 
line 2093: " SGML catalog file
line 2094: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 2095: 
line 2096: " Shell scripts ending in a star
line 2097: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
line 2098: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
line 2099: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
line 2100: 
line 2101: " tcsh scripts ending in a star
line 2102: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")
line 2103: 
line 2104: " csh scripts ending in a star
line 2105: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
line 2106: 
line 2107: " VHDL
line 2108: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2109: 
line 2110: " Vim script
line 2111: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2112: 
line 2113: " Subversion commit file
line 2114: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2115: 
line 2116: " X resources file
line 2117: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2118: 
line 2119: " XFree86 config
line 2121: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2126: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2127: 
line 2128: " X11 xmodmap
line 2129: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2130: 
line 2131: " Xinetd conf
line 2132: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2133: 
line 2134: " yum conf (close enough to dosini)
line 2135: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2136: 
line 2137: " Z-Shell script ending in a star
line 2138: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 2139: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2140: 
line 2141: 
line 2142: " Plain text files, needs to be far down to not override others.  This avoids
line 2143: " the "conf" type being used if there is a line starting with '#'.
line 2144: au BufNewFile,BufRead *.text,README^I^Isetf text
line 2145: 
line 2146: " Help files match *.txt but should have a last line that is a modeline.
line 2150: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2151: 
line 2152: 
line 2153: " Use the filetype detect plugins.  They may overrule any of the previously
line 2154: " detected filetypes.
line 2155: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/share/vim/vim81/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/home/w/.vim/after/ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2156: 
line 2157: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2158: " and started another one. Let's make sure it has ended to get to a consistent
line 2159: " state.
line 2160: augroup END
line 2161: 
line 2162: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2168: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2169: 
line 2170: 
line 2171: " If the GUI is already running, may still need to install the Syntax menu.
line 2172: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2174: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2175:   source <sfile>:p:h/menu.vim
line 2176: endif
line 2177: 
line 2178: " Function called for testing all functions defined here.  These are
line 2179: " script-local, thus need to be executed here.
line 2180: " Returns a string with error messages (hopefully empty).
line 2181: func! TestFiletypeFuncs(testlist)
line 2192: 
line 2193: " Restore 'cpoptions'
line 2194: let &cpo = s:cpo_save
line 2195: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/w/.vim/after/filetype.vim"
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in /etc/vimrc
line 51:   set hlsearch
line 52: endif
line 53: 
line 54: filetype plugin on
Searching for "filetype.vim" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 54: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2019 Mar 26
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in /etc/vimrc
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/w/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim81/ftplugin.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 54: sourcing "/usr/share/vim/vim81/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
line 8: endif
line 9: let did_load_ftplugin = 1
line 10: 
line 11: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
line 13: 
line 14:   func! s:LoadFTPlugin()
line 35: augroup END
finished sourcing /usr/share/vim/vim81/ftplugin.vim
continuing in /etc/vimrc
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/home/w/.vim/after/ftplugin.vim"
line 55: 
line 56: if &term=="xterm"
line 57:      set t_Co=8
line 58:      set t_Sb=^[[4%dm
line 59:      set t_Sf=^[[3%dm
line 60: endif
line 61: 
line 62: " Don't wake up system with blinking cursor:
line 63: " http://www.linuxpowertop.org/known.php
line 64: let &guicursor = &guicursor . ",a:blinkon0"
finished sourcing /etc/vimrc
chdir(/home/w)
fchdir() to previous dir
sourcing "$HOME/.vimrc"
line 1: " pathogen
line 2: execute pathogen#infect()
Searching for "autoload/pathogen.vim" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/autoload/pathogen.vim"
chdir(/home/w/.vim/autoload)
fchdir() to previous dir
line 2: sourcing "/home/w/.vim/autoload/pathogen.vim"
line 1: " pathogen.vim - path option manipulation
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.4
line 4: 
line 5: " Install in ~/.vim/autoload (or ~\vimfiles\autoload).
line 6: "
line 7: " For management of individually installed plugins in ~/.vim/bundle (or
line 8: " ~\vimfiles\bundle), adding `execute pathogen#infect()` to the top of your
line 9: " .vimrc is the only other setup necessary.
line 10: "
line 11: " The API is documented inline below.
line 12: 
line 13: if exists("g:loaded_pathogen") || &cp
line 14:   finish
line 15: endif
line 16: let g:loaded_pathogen = 1
line 17: 
line 18: " Point of entry for basic default usage.  Give a relative path to invoke
line 19: " pathogen#interpose() or an absolute path to invoke pathogen#surround().
line 20: " Curly braces are expanded with pathogen#expand(): "bundle/{}" finds all
line 21: " subdirectories inside "bundle" inside all directories in the runtime path.
line 22: " If no arguments are given, defaults "bundle/{}", and also "pack/{}/start/{}"
line 23: " on versions of Vim without native package support.
line 24: function! pathogen#infect(...) abort
line 50: 
line 51: " Split a path into a list.
line 52: function! pathogen#split(path) abort
line 58: 
line 59: " Convert a list to a path.
line 60: function! pathogen#join(...) abort
line 85: 
line 86: " Convert a list to a path with escaped spaces for 'path', 'tag', etc.
line 87: function! pathogen#legacyjoin(...) abort
line 90: 
line 91: " Turn filetype detection off and back on again if it was already enabled.
line 92: function! pathogen#cycle_filetype() abort
line 98: 
line 99: " Check if a bundle is disabled.  A bundle is considered disabled if its
line 100: " basename or full name is included in the list g:pathogen_blacklist or the
line 101: " comma delimited environment variable $VIMBLACKLIST.
line 102: function! pathogen#is_disabled(path) abort
line 113: 
line 114: " Prepend the given directory to the runtime path and append its corresponding
line 115: " after directory.  Curly braces are expanded with pathogen#expand().
line 116: function! pathogen#surround(path) abort
line 126: 
line 127: " For each directory in the runtime path, add a second entry with the given
line 128: " argument appended.  Curly braces are expanded with pathogen#expand().
line 129: function! pathogen#interpose(name) abort
line 147: 
line 148: let s:done_bundles = {}
line 149: 
line 150: " Invoke :helptags on all non-$VIM doc directories in runtimepath.
line 151: function! pathogen#helptags() abort
line 161: 
line 162: command! -bar Helptags :call pathogen#helptags()
line 163: 
line 164: " Execute the given command.  This is basically a backdoor for --remote-expr.
line 165: function! pathogen#execute(...) abort
line 171: 
line 172: " Section: Unofficial
line 173: 
line 174: function! pathogen#is_absolute(path) abort
line 177: 
line 178: " Given a string, returns all possible permutations of comma delimited braced
line 179: " alternatives of that string.  pathogen#expand('/{a,b}/{c,d}') yields
line 180: " ['/a/c', '/a/d', '/b/c', '/b/d'].  Empty braces are treated as a wildcard
line 181: " and globbed.  Actual globs are preserved.
line 182: function! pathogen#expand(pattern, ...) abort
line 203: 
line 204: " \ on Windows unless shellslash is set, / everywhere else.
line 205: function! pathogen#slash() abort
line 208: 
line 209: function! pathogen#separator() abort
line 212: 
line 213: " Convenience wrapper around glob() which returns a list.
line 214: function! pathogen#glob(pattern) abort
line 218: 
line 219: " Like pathogen#glob(), only limit the results to directories.
line 220: function! pathogen#glob_directories(pattern) abort
line 223: 
line 224: " Remove duplicates from a list.
line 225: function! pathogen#uniq(list) abort
line 241: 
line 242: " Backport of fnameescape().
line 243: function! pathogen#fnameescape(string) abort
line 252: 
line 253: " Like findfile(), but hardcoded to use the runtimepath.
line 254: function! pathogen#runtime_findfile(file,count) abort
line 263: 
line 264: " vim:set et sw=2 foldmethod=expr foldexpr=getline(v\:lnum)=~'^\"\ Section\:'?'>1'\:getline(v\:lnum)=~#'^fu'?'a1'\:getline(v\:lnum)=~#'^endf'?'s1'\:'=':
finished sourcing /home/w/.vim/autoload/pathogen.vim
continuing in /home/w/.vimrc
calling function pathogen#infect()

line 1:   if a:0
line 2:     let paths = filter(reverse(copy(a:000)), 'type(v:val) == type("")')
line 3:   else
line 4:     let paths = ['bundle/{}', 'pack/{}/start/{}']
line 5:   endif
line 6:   if has('packages')
line 7:     call filter(paths, 'v:val !~# "^pack/[^/]*/start/[^/]*$"')
line 8:   endif
line 9:   let static = '^\%([$~\\/]\|\w:[\\/]\)[^{}*]*$'
line 10:   for path in filter(copy(paths), 'v:val =~# static')
line 11:     call pathogen#surround(path)
line 12:   endfor
line 13:   for path in filter(copy(paths), 'v:val !~# static')
line 14:     if path =~# '^\%([$~\\/]\|\w:[\\/]\)'
line 15:       call pathogen#surround(path)
line 16:     else
line 17:       call pathogen#interpose(path)
calling function pathogen#infect[17]..pathogen#interpose('bundle/{}')

line 1:   let sep = pathogen#slash()
calling function pathogen#infect[17]..pathogen#interpose[1]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[1]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose

line 2:   let name = a:name
line 3:   if has_key(s:done_bundles, name)
line 4:     return ""
line 5:   endif
line 6:   let s:done_bundles[name] = 1
line 7:   let list = []
line 8:   for dir in pathogen#split(&rtp)
calling function pathogen#infect[17]..pathogen#interpose[8]..pathogen#split('/home/w/.vim,/usr/share/vim/vimfiles,.../vim/vimfiles/after,/home/w/.vim/after')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
line 2:  endif
line 3:   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
line 4:   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')
function pathogen#infect[17]..pathogen#interpose[8]..pathogen#split returning ['/home/w/.vim', '/usr/share/vim/vimfi.../vimfiles/after', '/home/w/.vim/after']

continuing in function pathogen#infect[17]..pathogen#interpose

line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand('/home/w/.vim/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')
line 3:   if pattern =~# '{[^{}]\+}'
line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 6:     let results = []
line 7:     for pattern in found
line 8:       call extend(results, pathogen#expand(pattern))
line 9:     endfor
line 10:   elseif pattern =~# '{}'
line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 12:     let post = pattern[strlen(pat) : -1]
line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 14:   else
line 15:     let results = [pattern]
line 16:   endif
line 17:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 19:   return filter(results, '!empty(v:val)')
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand returning ['/home/w/.vim/bundle/nerdtree', '/hom...tabs', '/home/w/.vim/bundle/vim-rtags']

continuing in function pathogen#infect[17]..pathogen#interpose

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled('/home/w/.vim/bundle/nerdtree')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled

line 6:   if !empty(blacklist)
line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 8:   endif
line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[17]..pathogen#interpose

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled('/home/w/.vim/bundle/vim-nerdtree-tabs')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled

line 6:   if !empty(blacklist)
line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 8:   endif
line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[17]..pathogen#interpose

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled('/home/w/.vim/bundle/vim-rtags')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled

line 6:   if !empty(blacklist)
line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 8:   endif
line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[17]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand('/usr/share/vim/vimfiles/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')
line 3:   if pattern =~# '{[^{}]\+}'
line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 6:     let results = []
line 7:     for pattern in found
line 8:       call extend(results, pathogen#expand(pattern))
line 9:     endfor
line 10:   elseif pattern =~# '{}'
line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 12:     let post = pattern[strlen(pat) : -1]
line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 14:   else
line 15:     let results = [pattern]
line 16:   endif
line 17:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 19:   return filter(results, '!empty(v:val)')
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand returning []

continuing in function pathogen#infect[17]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand('/usr/share/vim/vim81/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')
line 3:   if pattern =~# '{[^{}]\+}'
line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 6:     let results = []
line 7:     for pattern in found
line 8:       call extend(results, pathogen#expand(pattern))
line 9:     endfor
line 10:   elseif pattern =~# '{}'
line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 12:     let post = pattern[strlen(pat) : -1]
line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 14:   else
line 15:     let results = [pattern]
line 16:   endif
line 17:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 19:   return filter(results, '!empty(v:val)')
function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand returning []

continuing in function pathogen#infect[17]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand('/usr/share/vim/vimfiles/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''
line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')
line 3:   if pattern =~# '{[^{}]\+}'
line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 6:     let results = []
line 7:     for pattern in found
line 8:       call extend(results, pathogen#expand(pattern))
line 9:     endfor
line 10:   elseif pattern =~# '{}'
line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 12:     let post = pattern[strlen(pat) : -1]
line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 14:   else
line 15:     let results = [pattern]
line 16:   endif
line 17:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 19:   return filter(results, '!empty(v:val)')
function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand returning []

continuing in function pathogen#infect[17]..pathogen#interpose

line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand('/home/w/.vim/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''
line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')
line 3:   if pattern =~# '{[^{}]\+}'
line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 6:     let results = []
line 7:     for pattern in found
line 8:       call extend(results, pathogen#expand(pattern))
line 9:     endfor
line 10:   elseif pattern =~# '{}'
line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 12:     let post = pattern[strlen(pat) : -1]
line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 14:   else
line 15:     let results = [pattern]
line 16:   endif
line 17:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash returning '/'

continuing in function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 19:   return filter(results, '!empty(v:val)')
function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand returning []

continuing in function pathogen#infect[17]..pathogen#interpose

line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 15:   let &rtp = pathogen#join(pathogen#uniq(list))
calling function pathogen#infect[17]..pathogen#interpose[15]..pathogen#uniq(['/home/w/.vim', '/home/w/.vim/bundle/.../vimfiles/after', '/home/w/.vim/after'])

line 1:   let i = 0
line 2:   let seen = {}
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 14:   return a:list
function pathogen#infect[17]..pathogen#interpose[15]..pathogen#uniq returning ['/home/w/.vim', '/home/w/.vim/bundle/.../vimfiles/after', '/home/w/.vim/after']

continuing in function pathogen#infect[17]..pathogen#interpose

calling function pathogen#infect[17]..pathogen#interpose[15]..pathogen#join(['/home/w/.vim', '/home/w/.vim/bundle/.../vimfiles/after', '/home/w/.vim/after'])

line 1:   if type(a:1) == type(1) && a:1
line 2:     let i = 1
line 3:     let space = ' '
line 4:   else
line 5:     let i = 0
line 6:     let space = ''
line 7:   endif
line 8:   let path = ""
line 9:   while i < a:0
line 10:     if type(a:000[i]) == type([])
line 11:       let list = a:000[i]
line 12:       let j = 0
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 18:     else
line 19:       let path .= "," . a:000[i]
line 20:     endif
line 21:     let i += 1
line 22:   endwhile
line 9:   while i < a:0
line 10:     if type(a:000[i]) == type([])
line 11:       let list = a:000[i]
line 12:       let j = 0
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 18:     else
line 19:       let path .= "," . a:000[i]
line 20:     endif
line 21:     let i += 1
line 22:   endwhile
line 23:   return substitute(path,'^,','','')
function pathogen#infect[17]..pathogen#interpose[15]..pathogen#join returning '/home/w/.vim,/home/w/.vim/bundle/nerd.../vim/vimfiles/after,/home/w/.vim/after'

continuing in function pathogen#infect[17]..pathogen#interpose

line 16:   return 1
function pathogen#infect[17]..pathogen#interpose returning #1

continuing in function pathogen#infect

line 18:     endif
line 19:   endfor
line 13:   for path in filter(copy(paths), 'v:val !~# static')
line 14:     if path =~# '^\%([$~\\/]\|\w:[\\/]\)'
line 15:       call pathogen#surround(path)
line 16:     else
line 17:       call pathogen#interpose(path)
line 18:     endif
line 19:   endfor
line 20:   call pathogen#cycle_filetype()
calling function pathogen#infect[20]..pathogen#cycle_filetype()

line 1:   if exists('g:did_load_filetypes')
line 2:     filetype off
Searching for "ftoff.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftoff.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftoff.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftoff.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftoff.vim"
Searching for "/usr/share/vim/vimfiles/ftoff.vim"
Searching for "/usr/share/vim/vim81/ftoff.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 2: sourcing "/usr/share/vim/vim81/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
finished sourcing /usr/share/vim/vim81/ftoff.vim
continuing in function pathogen#infect[20]..pathogen#cycle_filetype
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"
Searching for "/home/w/.vim/after/ftoff.vim"
line 3:     filetype on
Searching for "filetype.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/filetype.vim"
Searching for "/home/w/.vim/bundle/nerdtree/filetype.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/filetype.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 3: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2019 Mar 26
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: " When using this, the entry should probably be further down below with the
line 46: " other StarSetf() calls.
line 47: func! s:StarSetf(ft)
line 52: 
line 53: " Vim help file
line 54: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 55: 
line 56: " Abaqus or Trasys
line 57: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 58: 
line 59: " 8th (Firth-derivative)
line 60: au BufNewFile,BufRead *.8th^I^I^Isetf 8th
line 61: 
line 62: " A-A-P recipe
line 63: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 64: 
line 65: " A2ps printing utility
line 66: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 67: 
line 68: " ABAB/4
line 69: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 70: 
line 71: " ABC music notation
line 72: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 73: 
line 74: " ABEL
line 75: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 76: 
line 77: " AceDB
line 78: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 79: 
line 80: " Ada (83, 9X, 95)
line 81: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 82: if has("vms")
line 83:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 84: else
line 85:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 86: endif
line 87: 
line 88: " AHDL
line 89: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 90: 
line 91: " AMPL
line 92: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 93: 
line 94: " Ant
line 95: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 96: 
line 97: " Arduino
line 98: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 99: 
line 100: " Apache config file
line 101: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 102: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache
line 103: 
line 104: " XA65 MOS6510 cross assembler
line 105: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 106: 
line 107: " Applescript
line 108: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 109: 
line 110: " Applix ELF
line 112: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 113: 
line 114: " ALSA configuration
line 115: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 116: 
line 117: " Arc Macro Language
line 118: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 119: 
line 120: " APT config file
line 121: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 122: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 123: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 124: 
line 125: " Arch Inventory file
line 126: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 127: 
line 128: " ART*Enterprise (formerly ART-IM)
line 129: au BufNewFile,BufRead *.art^I^I^Isetf art
line 130: 
line 131: " AsciiDoc
line 132: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 133: 
line 134: " ASN.1
line 135: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 136: 
line 137: " Active Server Pages (with Visual Basic Script)
line 143: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 144: 
line 145: " Active Server Pages (with Perl or Visual Basic Script)
line 153: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 154: 
line 155: " Grub (must be before catch *.lst)
line 156: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 157: 
line 158: " Assembly (all kinds)
line 159: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 160: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 161: 
line 162: " Macro (VAX)
line 163: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 164: 
line 165: " Atlas
line 166: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 167: 
line 168: " Autoit v3
line 169: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 170: 
line 171: " Autohotkey
line 172: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 173: 
line 174: " Automake
line 175: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 176: 
line 177: " Autotest .at files are actually m4
line 178: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 179: 
line 180: " Avenue
line 181: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 182: 
line 183: " Awk
line 184: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 185: 
line 186: " B
line 187: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 188: 
line 189: " BASIC or Visual Basic
line 190: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")
line 191: 
line 192: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 193: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 194: 
line 195: " IBasic file (similar to QBasic)
line 196: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 197: 
line 198: " FreeBasic file (similar to QBasic)
line 199: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 200: 
line 201: " Batch file for MSDOS.
line 202: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 203: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 205: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 206: 
line 207: " Batch file for 4DOS
line 208: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 209: 
line 210: " BC calculator
line 211: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 212: 
line 213: " BDF font
line 214: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 215: 
line 216: " BibTeX bibliography database file
line 217: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 218: 
line 219: " BibTeX Bibliography Style
line 220: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 221: 
line 222: " BIND configuration
line 223: " sudoedit uses namedXXXX.conf
line 224: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 225: 
line 226: " BIND zone
line 227: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 228: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 229: 
line 230: " Blank
line 231: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 232: 
line 233: " Blkid cache file
line 234: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 235: 
line 236: " Bazel (http://bazel.io)
line 237: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl
line 238: if has("fname_case")
line 239:   " There is another check for BUILD further below.
line 240:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl
line 241: endif
line 242: 
line 243: " C or lpc
line 244: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 245: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 246: 
line 247: " Calendar
line 248: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 249: 
line 250: " C#
line 251: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 252: 
line 253: " CSDL
line 254: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 255: 
line 256: " Cabal
line 257: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 258: 
line 259: " Cdrdao TOC
line 260: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 261: 
line 262: " Cdrdao config
line 263: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 264: 
line 265: " Cfengine
line 266: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 267: 
line 268: " ChaiScript
line 269: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 270: 
line 271: " Comshare Dimension Definition Language
line 272: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 273: 
line 274: " Conary Recipe
line 275: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 276: 
line 277: " Controllable Regex Mutilator
line 278: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 279: 
line 280: " Cyn++
line 281: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 282: 
line 283: " Cynlib
line 284: " .cc and .cpp files can be C++ or Cynlib.
line 286: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 288: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 289: 
line 290: " C++
line 291: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 292: if has("fname_case")
line 293:   au BufNewFile,BufRead *.C,*.H setf cpp
line 294: endif
line 295: 
line 296: " .h files can be C, Ch C++, ObjC or ObjC++.
line 297: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 298: " detected automatically.
line 299: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 300: 
line 301: " Ch (CHscript)
line 302: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 303: 
line 304: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 305: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 306: 
line 307: " Cascading Style Sheets
line 308: au BufNewFile,BufRead *.css^I^I^Isetf css
line 309: 
line 310: " Century Term Command Scripts (*.cmd too)
line 311: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 312: 
line 313: " Changelog
line 315: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 316: 
line 322: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 323: 
line 327: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 328: 
line 329: " CHILL
line 330: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 331: 
line 332: " Changes for WEB and CWEB or CHILL
line 333: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 334: 
line 335: " ChordPro
line 336: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 337: 
line 338: " Clean
line 339: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 340: 
line 341: " Clever
line 342: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 343: 
line 344: " Clever or dtd
line 345: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 346: 
line 347: " Clipper (or FoxPro; could also be eviews)
line 353: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 354: 
line 355: " Clojure
line 356: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 357: 
line 358: " Cmake
line 359: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 360: 
line 361: " Cmusrc
line 362: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 363: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 364: 
line 365: " Cobol
line 366: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 367: "   cobol or zope form controller python script? (heuristic)
line 373: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 374: 
line 375: " Coco/R
line 376: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 377: 
line 378: " Cold Fusion
line 379: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 380: 
line 381: " Configure scripts
line 382: au BufNewFile,BufRead configure.in,configure.ac setf config
line 383: 
line 384: " CUDA  Cumpute Unified Device Architecture
line 385: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 386: 
line 387: " Dockerfile
line 388: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile
line 389: 
line 390: " WildPackets EtherPeek Decoder
line 391: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 392: 
line 393: " Enlightenment configuration files
line 394: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 395: 
line 396: " Eterm
line 397: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 398: 
line 399: " Euphoria 3 or 4
line 400: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 401: if has("fname_case")
line 402:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 403: endif
line 404: 
line 405: " Lynx config files
line 406: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 407: 
line 408: " Quake
line 409: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 410: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 411: 
line 412: " Quake C
line 413: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 414: 
line 415: " Configure files
line 416: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 417: 
line 418: " Cucumber
line 419: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 420: 
line 421: " Communicating Sequential Processes
line 422: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 423: 
line 424: " CUPL logic description and simulation
line 425: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 426: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 427: 
line 428: " Debian Control
line 429: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 433: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 434: 
line 435: " Debian Copyright
line 436: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 440: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 441: 
line 442: " Debian Sources.list
line 443: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 444: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 445: 
line 446: " Deny hosts
line 447: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 448: 
line 449: " dnsmasq(8) configuration files
line 450: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 451: 
line 452: " ROCKLinux package description
line 453: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 454: 
line 455: " the D language or dtrace
line 456: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 457: 
line 458: " Desktop files
line 459: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 460: 
line 461: " Dict config
line 462: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 463: 
line 464: " Dictd config
line 465: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 466: 
line 467: " Diff files
line 468: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 474: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 475: 
line 476: " Dircolors
line 477: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 478: 
line 479: " Diva (with Skill) or InstallShield
line 485: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 486: 
line 487: " DCL (Digital Command Language - vms) or DNS zone file
line 488: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 489: 
line 490: " DOT
line 491: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 492: 
line 493: " Dylan - lid files
line 494: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 495: 
line 496: " Dylan - intr files (melange)
line 497: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 498: 
line 499: " Dylan
line 500: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 501: 
line 502: " Microsoft Module Definition
line 503: au BufNewFile,BufRead *.def^I^I^Isetf def
line 504: 
line 505: " Dracula
line 506: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 507: 
line 508: " Datascript
line 509: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 510: 
line 511: " dsl
line 512: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 513: 
line 514: " DTD (Document Type Definition for XML)
line 515: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 516: 
line 517: " DTS/DSTI (device tree files)
line 518: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 519: 
line 520: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 521: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 527: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 528: 
line 529: " EditorConfig (close enough to dosini)
line 530: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
line 531: 
line 532: " Embedix Component Description
line 533: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 534: 
line 535: " Eiffel or Specman or Euphoria
line 536: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 537: 
line 538: " Elinks configuration
line 539: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 540: 
line 541: " ERicsson LANGuage; Yaws is erlang too
line 542: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 543: 
line 544: " Elm Filter Rules file
line 545: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 546: 
line 547: " ESMTP rc file
line 548: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 549: 
line 550: " ESQL-C
line 551: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 552: 
line 553: " Esterel
line 554: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 555: 
line 556: " Essbase script
line 557: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 558: 
line 559: " Exim
line 560: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 561: 
line 562: " Expect
line 563: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 564: 
line 565: " Exports
line 566: au BufNewFile,BufRead exports^I^I^Isetf exports
line 567: 
line 568: " Falcon
line 569: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 570: 
line 571: " Fantom
line 572: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 573: 
line 574: " Factor
line 575: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 576: 
line 577: " Fetchmail RC file
line 578: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 579: 
line 580: " FlexWiki - disabled, because it has side effects when a .wiki file
line 581: " is not actually FlexWiki
line 582: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 583: 
line 584: " Focus Executable
line 585: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 586: 
line 587: " Focus Master file (but not for auto.master)
line 588: au BufNewFile,BufRead auto.master^I^Isetf conf
line 589: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 590: 
line 591: " Forth
line 592: au BufNewFile,BufRead *.fs,*.ft,*.fth^I^Isetf forth
line 593: 
line 594: " Reva Forth
line 595: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 596: 
line 597: " Fortran
line 598: if has("fname_case")
line 599:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 600: endif
line 601: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 602: 
line 603: " Framescript
line 604: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 605: 
line 606: " FStab
line 607: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 608: 
line 609: " GDB command files
line 610: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 611: 
line 612: " GDMO
line 613: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 614: 
line 615: " Gedcom
line 616: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 617: 
line 618: " Git
line 619: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG ^Isetf gitcommit
line 620: au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig ^Isetf gitconfig
line 621: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 622: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 623: if !empty($XDG_CONFIG_HOME)
line 624:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 625: endif
line 626: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 627: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
line 631: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 635: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 636: 
line 637: " Gkrellmrc
line 638: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 639: 
line 640: " GP scripts (2.0 and onward)
line 641: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 642: 
line 643: " GPG
line 644: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 645: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 646: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 647: if !empty($GNUPGHOME)
line 648:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 649:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 650: endif
line 651: 
line 652: " gnash(1) configuration files
line 653: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 654: 
line 655: " Gitolite
line 656: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 657: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 658: 
line 659: " Gnuplot scripts
line 660: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 661: 
line 662: " Go (Google)
line 663: au BufNewFile,BufRead *.go^I^I^Isetf go
line 664: 
line 665: " GrADS scripts
line 666: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 667: 
line 668: " Gretl
line 669: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 670: 
line 671: " Groovy
line 672: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 673: 
line 674: " GNU Server Pages
line 675: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 676: 
line 677: " Group file
line 678: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 679: 
line 680: " GTK RC
line 681: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 682: 
line 683: " Haml
line 684: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 685: 
line 686: " Hamster Classic | Playground files
line 687: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 688: 
line 689: " Haskell
line 690: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 691: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 692: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 693: 
line 694: " Haste
line 695: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 696: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 697: 
line 698: " Hercules
line 699: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 700: 
line 701: " HEX (Intel)
line 702: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 703: 
line 704: " Tilde (must be before HTML)
line 705: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 706: 
line 707: " HTML (.shtml and .stm for server side)
line 708: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 709: 
line 710: " HTML with Ruby - eRuby
line 711: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 712: 
line 713: " HTML with M4
line 714: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 715: 
line 716: " HTML Cheetah template
line 717: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 718: 
line 719: " Host config
line 720: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 721: 
line 722: " Hosts access
line 723: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 724: 
line 725: " Hyper Builder
line 726: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 727: 
line 728: " Httest
line 729: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 730: 
line 731: " Icon
line 732: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 733: 
line 734: " IDL (Interface Description Language)
line 735: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 736: 
line 737: " Microsoft IDL (Interface Description Language)  Also *.idl
line 738: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 739: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 740: 
line 741: " Icewm menu
line 742: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 743: 
line 744: " Indent profile (must come before IDL *.pro!)
line 745: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 746: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 747: 
line 748: " IDL (Interactive Data Language)
line 749: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 750: 
line 751: " Indent RC
line 752: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 753: 
line 754: " Inform
line 755: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 756: 
line 757: " Initng
line 758: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 759: 
line 760: " Innovation Data Processing
line 761: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 762: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
line 763: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 764: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 765: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 766: 
line 767: " Ipfilter
line 768: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 769: 
line 770: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 771: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 772: 
line 773: " .INI file for MSDOS
line 774: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 775: 
line 776: " SysV Inittab
line 777: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 778: 
line 779: " Inno Setup
line 780: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 781: 
line 782: " J
line 783: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 784: 
line 785: " JAL
line 786: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 787: 
line 788: " Jam
line 789: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 790: 
line 791: " Java
line 792: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 793: 
line 794: " JavaCC
line 795: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 796: 
line 797: " JavaScript, ECMAScript
line 798: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
line 799: 
line 800: " Java Server Pages
line 801: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 802: 
line 803: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 804: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 805: 
line 806: " Jess
line 807: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 808: 
line 809: " Jgraph
line 810: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 811: 
line 812: " Jovial
line 813: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 814: 
line 815: " JSON
line 816: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 817: 
line 818: " Kixtart
line 819: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 820: 
line 821: " Kimwitu[++]
line 822: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 823: 
line 824: " Kivy
line 825: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 826: 
line 827: " KDE script
line 828: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 829: 
line 830: " Kconfig
line 831: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 832: 
line 833: " Lace (ISE)
line 834: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 835: 
line 836: " Latte
line 837: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 838: 
line 839: " Limits
line 840: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 841: 
line 842: " LambdaProlog (*.mod too, see Modsim)
line 843: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 844: 
line 845: " LDAP LDIF
line 846: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 847: 
line 848: " Ld loader
line 849: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 850: 
line 851: " Less
line 852: au BufNewFile,BufRead *.less^I^I^Isetf less
line 853: 
line 854: " Lex
line 855: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 856: 
line 857: " Libao
line 858: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 859: 
line 860: " Libsensors
line 861: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 862: 
line 863: " LFTP
line 864: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 865: 
line 866: " Lifelines (or Lex for C++!)
line 867: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 868: 
line 869: " Lilo: Linux loader
line 870: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 871: 
line 872: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 873: if has("fname_case")
line 874:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 875: else
line 876:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 877: endif
line 878: 
line 879: " SBCL implementation of Common Lisp
line 880: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 881: 
line 882: " Liquid
line 883: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 884: 
line 885: " Lite
line 886: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 887: 
line 888: " LiteStep RC files
line 889: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 890: 
line 891: " Login access
line 892: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 893: 
line 894: " Login defs
line 895: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 896: 
line 897: " Logtalk
line 898: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 899: 
line 900: " LOTOS
line 901: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 902: 
line 903: " Lout (also: *.lt)
line 904: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 905: 
line 906: " Lua
line 907: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 908: 
line 909: " Luarocks
line 910: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 911: 
line 912: " Linden Scripting Language (Second Life)
line 913: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 914: 
line 915: " Lynx style file (or LotusScript!)
line 916: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 917: 
line 918: " M4
line 920: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 921: 
line 922: " MaGic Point
line 923: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 924: 
line 925: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 926: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 927: 
line 928: " Mail aliases
line 929: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 930: 
line 931: " Mailcap configuration file
line 932: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 933: 
line 934: " Makefile
line 935: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 936: 
line 937: " MakeIndex
line 938: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 939: 
line 940: " Mallard
line 941: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 942: 
line 943: " Manpage
line 944: au BufNewFile,BufRead *.man^I^I^Isetf man
line 945: 
line 946: " Man config
line 947: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 948: 
line 949: " Maple V
line 950: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 951: 
line 952: " Map (UMN mapserver config file)
line 953: au BufNewFile,BufRead *.map^I^I^Isetf map
line 954: 
line 955: " Markdown
line 956: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 957: 
line 958: " Mason
line 959: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 960: 
line 961: " Mathematica, Matlab, Murphi or Objective C
line 962: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 963: 
line 964: " Mathematica notebook
line 965: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 966: 
line 967: " Maya Extension Language
line 968: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 969: 
line 970: " Mercurial (hg) commit file
line 971: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 972: 
line 973: " Mercurial config (looks like generic config file)
line 974: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 975: 
line 976: " Messages (logs mostly)
line 977: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 978: 
line 979: " Metafont
line 980: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 981: 
line 982: " MetaPost
line 983: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 984: 
line 985: " MGL
line 986: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 987: 
line 988: " MIX - Knuth assembly
line 989: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 990: 
line 991: " MMIX or VMS makefile
line 992: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 993: 
line 994: " Symbian meta-makefile definition (MMP)
line 995: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 996: 
line 997: " Modsim III (or LambdaProlog)
line 1003: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1004: 
line 1005: " Modula 2  (.md removed in favor of Markdown)
line 1006: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1007: 
line 1008: " Modula 3 (.m3, .i3, .mg, .ig)
line 1009: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1010: 
line 1011: " Monk
line 1012: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1013: 
line 1014: " MOO
line 1015: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1016: 
line 1017: " Modconf
line 1018: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1019: 
line 1020: " Mplayer config
line 1021: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1022: 
line 1023: " Motorola S record
line 1024: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1025: 
line 1026: " Mrxvtrc
line 1027: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1028: 
line 1029: " Msql
line 1030: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1031: 
line 1032: " Mysql
line 1033: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1034: 
line 1035: " Mutt setup files (must be before catch *.rc)
line 1036: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1037: 
line 1038: " M$ Resource files
line 1039: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1040: 
line 1041: " MuPAD source
line 1042: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1043: 
line 1044: " Mush
line 1045: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1046: 
line 1047: " Mutt setup file (also for Muttng)
line 1048: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1049: 
line 1050: " N1QL
line 1051: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1052: 
line 1053: " Nano
line 1054: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1055: 
line 1056: " Nastran input/DMAP
line 1057: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1058: 
line 1059: " Natural
line 1060: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1061: 
line 1062: " Noemutt setup file
line 1063: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1064: 
line 1065: " Netrc
line 1066: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1067: 
line 1068: " Ninja file
line 1069: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1070: 
line 1071: " Novell netware batch files
line 1072: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1073: 
line 1074: " Nroff/Troff (*.ms and *.t are checked below)
line 1078: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1079: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1080: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1081: 
line 1082: " Nroff or Objective C++
line 1083: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1084: 
line 1085: " Not Quite C
line 1086: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1087: 
line 1088: " NSE - Nmap Script Engine - uses Lua syntax
line 1089: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1090: 
line 1091: " NSIS
line 1092: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1093: 
line 1094: " OCAML
line 1095: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1096: 
line 1097: " Occam
line 1098: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1099: 
line 1100: " Omnimark
line 1101: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1102: 
line 1103: " OpenROAD
line 1104: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1105: 
line 1106: " OPL
line 1107: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1108: 
line 1109: " Oracle config file
line 1110: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1111: 
line 1112: " Packet filter conf
line 1113: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1114: 
line 1115: " Pam conf
line 1116: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1117: 
line 1118: " PApp
line 1119: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1120: 
line 1121: " Password file
line 1122: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1123: 
line 1124: " Pascal (also *.p)
line 1125: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1126: 
line 1127: " Delphi project file
line 1128: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1129: 
line 1130: " PDF
line 1131: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1132: 
line 1133: " PCMK - HAE - crm configure edit
line 1134: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk
line 1135: 
line 1136: " Perl
line 1137: if has("fname_case")
line 1138:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()
line 1139: else
line 1140:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()
line 1141: endif
line 1142: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
line 1143: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1144: 
line 1145: " Perl, XPM or XPM2
line 1153: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1154: 
line 1155: " Perl POD
line 1156: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1157: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1158: 
line 1159: " Php, php3, php4, etc.
line 1160: " Also Phtml (was used for PHP 2 in the past)
line 1161: " Also .ctp for Cake template file
line 1162: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1163: 
line 1164: " Pike and Cmod
line 1165: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1166: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1167: 
line 1168: " Pinfo config
line 1169: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1170: 
line 1171: " Palm Resource compiler
line 1172: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1173: 
line 1174: " Pine config
line 1175: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1176: 
line 1177: " PL/1, PL/I
line 1178: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1179: 
line 1180: " PL/M (also: *.inp)
line 1181: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1182: 
line 1183: " PL/SQL
line 1184: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1185: 
line 1186: " PLP
line 1187: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1188: 
line 1189: " PO and PO template (GNU gettext)
line 1190: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1191: 
line 1192: " Postfix main config
line 1193: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1194: 
line 1195: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1196: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1197: 
line 1198: " PostScript Printer Description
line 1199: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1200: 
line 1201: " Povray
line 1202: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1203: 
line 1204: " Povray configuration
line 1205: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1206: 
line 1207: " Povray, PHP or assembly
line 1208: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1209: 
line 1210: " Printcap and Termcap
line 1212: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1214: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1215: 
line 1216: " PCCTS / ANTRL
line 1217: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1218: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1219: 
line 1220: " PPWizard
line 1221: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1222: 
line 1223: " Obj 3D file format
line 1224: " TODO: is there a way to avoid MS-Windows Object files?
line 1225: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1226: 
line 1227: " Oracle Pro*C/C++
line 1228: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1229: 
line 1230: " Privoxy actions file
line 1231: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1232: 
line 1233: " Procmail
line 1234: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1235: 
line 1236: " Progress or CWEB
line 1237: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1238: 
line 1239: " Progress or assembly
line 1240: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()
line 1241: 
line 1242: " Progress or Pascal
line 1243: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1244: 
line 1245: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1246: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1250: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1251: 
line 1252: " Prolog
line 1253: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1254: 
line 1255: " Promela
line 1256: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1257: 
line 1258: " Google protocol buffers
line 1259: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1260: 
line 1261: " Protocols
line 1262: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1263: 
line 1264: " Pyrex
line 1265: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1266: 
line 1267: " Python, Python Shell Startup and Python Stub Files
line 1268: " Quixote (Python-based web framework)
line 1269: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl,*.pyi  setf python
line 1270: 
line 1271: " Radiance
line 1272: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1273: 
line 1274: " Ratpoison config/command files
line 1275: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1276: 
line 1277: " RCS file
line 1278: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1279: 
line 1280: " Readline
line 1281: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1282: 
line 1283: " Registry for MS-Windows
line 1285: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1286: 
line 1287: " Renderman Interface Bytestream
line 1288: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1289: 
line 1290: " Rexx
line 1291: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1292: 
line 1293: " R (Splus)
line 1294: if has("fname_case")
line 1295:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1296: else
line 1297:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1298: endif
line 1299: 
line 1300: " R Help file
line 1301: if has("fname_case")
line 1302:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1303: else
line 1304:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1305: endif
line 1306: 
line 1307: " R noweb file
line 1308: if has("fname_case")
line 1309:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1310: else
line 1311:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1312: endif
line 1313: 
line 1314: " R Markdown file
line 1315: if has("fname_case")
line 1316:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1317: else
line 1318:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1319: endif
line 1320: 
line 1321: " R reStructuredText file
line 1322: if has("fname_case")
line 1323:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1324: else
line 1325:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1326: endif
line 1327: 
line 1328: " Rexx, Rebol or R
line 1329: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 1330: 
line 1331: " Remind
line 1332: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1333: 
line 1334: " Resolv.conf
line 1335: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1336: 
line 1337: " Relax NG Compact
line 1338: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1339: 
line 1340: " Relax NG XML
line 1341: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1342: 
line 1343: " RPL/2
line 1344: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1345: 
line 1346: " Robots.txt
line 1347: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1348: 
line 1349: " Rpcgen
line 1350: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1351: 
line 1352: " reStructuredText Documentation Format
line 1353: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1354: 
line 1355: " RTF
line 1356: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1357: 
line 1358: " Interactive Ruby shell
line 1359: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1360: 
line 1361: " Ruby
line 1362: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1363: 
line 1364: " RubyGems
line 1365: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1366: 
line 1367: " Rust
line 1368: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1369: 
line 1370: " Rackup
line 1371: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1372: 
line 1373: " Bundler
line 1374: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1375: 
line 1376: " Ruby on Rails
line 1377: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1378: 
line 1379: " Rantfile and Rakefile is like Ruby
line 1380: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1381: 
line 1382: " S-lang (or shader language, or SmallLisp)
line 1383: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1384: 
line 1385: " Samba config
line 1386: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1387: 
line 1388: " SAS script
line 1389: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1390: 
line 1391: " Sass
line 1392: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1393: 
line 1394: " Sather
line 1395: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1396: 
line 1397: " Scala
line 1398: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1399: 
line 1400: " SBT - Scala Build Tool
line 1401: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1402: 
line 1403: " Scilab
line 1404: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1405: 
line 1406: " SCSS
line 1407: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1408: 
line 1409: " SD: Streaming Descriptors
line 1410: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1411: 
line 1412: " SDL
line 1413: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1414: 
line 1415: " sed
line 1416: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1417: 
line 1418: " Sieve (RFC 3028, 5228)
line 1419: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 1420: 
line 1421: " Sendmail
line 1422: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1423: 
line 1424: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1425: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 1426: 
line 1427: " Services
line 1428: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1429: 
line 1430: " Service Location config
line 1431: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1432: 
line 1433: " Service Location registration
line 1434: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1435: 
line 1436: " Service Location SPI
line 1437: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1438: 
line 1439: " Setserial config
line 1440: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1441: 
line 1442: " SGML
line 1452: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1453: 
line 1454: " SGMLDECL
line 1458: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1459: 
line 1460: " SGML catalog file
line 1461: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1462: 
line 1463: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1464: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
line 1465: " NOTE: Patterns ending in a star are further down, these have lower priority.
line 1466: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD call dist#ft#SetFileTypeSH("bash")
line 1467: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 1468: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
line 1469: 
line 1470: 
line 1471: " Shell script (Arch Linux) or PHP file (Drupal)
line 1477: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 1478: 
line 1479: " tcsh scripts (patterns ending in a star further below)
line 1480: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 1481: 
line 1482: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1483: " (patterns ending in a start further below)
line 1484: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 1485: 
line 1486: " Z-Shell script (patterns ending in a star further below)
line 1487: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1488: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
line 1489: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1490: 
line 1491: " Scheme
line 1492: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1493: 
line 1494: " Screen RC
line 1495: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1496: 
line 1497: " Simula
line 1498: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1499: 
line 1500: " SINDA
line 1501: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1502: 
line 1503: " SiSU
line 1504: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1505: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1506: 
line 1507: " SKILL
line 1508: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1509: 
line 1510: " SLRN
line 1511: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1512: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1513: 
line 1514: " Smalltalk (and TeX)
line 1515: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1523: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1524: 
line 1525: " Smarty templates
line 1526: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1527: 
line 1528: " SMIL or XML
line 1534: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1535: 
line 1536: " SMIL or SNMP MIB file
line 1542: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1543: 
line 1544: " SMITH
line 1545: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1546: 
line 1547: " Snobol4 and spitbol
line 1548: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1549: 
line 1550: " SNMP MIB files
line 1551: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1552: 
line 1553: " Snort Configuration
line 1554: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1555: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 1556: 
line 1557: " Spec (Linux RPM)
line 1558: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1559: 
line 1560: " Speedup (AspenTech plant simulator)
line 1561: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1562: 
line 1563: " Slice
line 1564: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 1565: 
line 1566: " Spice
line 1567: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 1568: 
line 1569: " Spyce
line 1570: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 1571: 
line 1572: " Squid
line 1573: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 1574: 
line 1575: " SQL for Oracle Designer
line 1576: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 1577: 
line 1578: " SQL
line 1579: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 1580: 
line 1581: " SQLJ
line 1582: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 1583: 
line 1584: " SQR
line 1585: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 1586: 
line 1587: " OpenSSH configuration
line 1588: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 1589: 
line 1590: " OpenSSH server configuration
line 1591: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 1592: 
line 1593: " Stata
line 1594: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 1595: " Also *.class, but not when it's a Java bytecode file
line 1597: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 1598: 
line 1599: " SMCL
line 1600: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 1601: 
line 1602: " Stored Procedures
line 1603: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 1604: 
line 1605: " Standard ML
line 1606: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 1607: 
line 1608: " Sratus VOS command macro
line 1609: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 1610: 
line 1611: " Sysctl
line 1612: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 1613: 
line 1614: " Systemd unit files
line 1615: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 1616: " Systemd overrides
line 1617: au BufNewFile,BufRead /etc/systemd/system/*.d/*.conf^Isetf systemd
line 1618: " Systemd temp files
line 1619: au BufNewFile,BufRead /etc/systemd/system/*.d/.#*^Isetf systemd
line 1620: 
line 1621: " Synopsys Design Constraints
line 1622: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 1623: 
line 1624: " Sudoers
line 1625: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 1626: 
line 1627: " SVG (Scalable Vector Graphics)
line 1628: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 1629: 
line 1630: " Tads (or Nroff or Perl test file)
line 1632: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 1633: 
line 1634: " Tags
line 1635: au BufNewFile,BufRead tags^I^I^Isetf tags
line 1636: 
line 1637: " TAK
line 1638: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 1639: 
line 1640: " Task
line 1641: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 1642: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 1643: 
line 1644: " Tcl (JACL too)
line 1645: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 1646: 
line 1647: " TealInfo
line 1648: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 1649: 
line 1650: " Telix Salt
line 1651: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 1652: 
line 1653: " Tera Term Language
line 1654: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 1655: 
line 1656: " Terminfo
line 1657: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 1658: 
line 1659: " TeX
line 1660: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 1661: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 1662: 
line 1663: " ConTeXt
line 1664: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
line 1665: 
line 1666: " Texinfo
line 1667: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 1668: 
line 1669: " TeX configuration
line 1670: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 1671: 
line 1672: " Tidy config
line 1673: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 1674: 
line 1675: " TF mud client
line 1676: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 1677: 
line 1678: " tmux configuration
line 1679: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 1680: 
line 1681: " TPP - Text Presentation Program
line 1682: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 1683: 
line 1684: " Treetop
line 1685: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 1686: 
line 1687: " Trustees
line 1688: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 1689: 
line 1690: " TSS - Geometry
line 1691: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 1692: 
line 1693: " TSS - Optics
line 1694: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 1695: 
line 1696: " TSS - Command Line (temporary)
line 1697: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 1698: 
line 1699: " TWIG files
line 1700: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 1701: 
line 1702: " Motif UIT/UIL files
line 1703: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 1704: 
line 1705: " Udev conf
line 1706: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 1707: 
line 1708: " Udev permissions
line 1709: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 1710: "
line 1711: " Udev symlinks config
line 1712: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 1713: 
line 1714: " UnrealScript
line 1715: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 1716: 
line 1717: " Updatedb
line 1718: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 1719: 
line 1720: " Upstart (init(8)) config files
line 1721: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 1722: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 1723: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 1724: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 1725: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 1726: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 1727: 
line 1728: " Vera
line 1729: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 1730: 
line 1731: " Verilog HDL
line 1732: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 1733: 
line 1734: " Verilog-AMS HDL
line 1735: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 1736: 
line 1737: " SystemVerilog
line 1738: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 1739: 
line 1740: " VHDL
line 1741: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 1742: 
line 1743: " Vim script
line 1744: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 1745: 
line 1746: " Viminfo file
line 1747: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 1748: 
line 1749: " Virata Config Script File or Drupal module
line 1755: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 1756: 
line 1757: " Visual Basic (also uses *.bas) or FORM
line 1758: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")
line 1759: 
line 1760: " SaxBasic is close to Visual Basic
line 1761: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 1762: 
line 1763: " Vgrindefs file
line 1764: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 1765: 
line 1766: " VRML V1.0c
line 1767: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 1768: 
line 1769: " Vroom (vim testing and executable documentation)
line 1770: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 1771: 
line 1772: " Webmacro
line 1773: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 1774: 
line 1775: " WebAssembly
line 1776: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast
line 1777: 
line 1778: " Wget config
line 1779: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 1780: 
line 1781: " Website MetaLanguage
line 1782: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 1783: 
line 1784: " Winbatch
line 1785: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 1786: 
line 1787: " WSML
line 1788: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 1789: 
line 1790: " WPL
line 1791: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 1792: 
line 1793: " WvDial
line 1794: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 1795: 
line 1796: " CVS RC file
line 1797: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 1798: 
line 1799: " CVS commit file
line 1800: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 1801: 
line 1802: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 1803: " lines in a WEB file).
line 1809: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 1810: 
line 1811: " Windows Scripting Host and Windows Script Component
line 1812: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 1813: 
line 1814: " XHTML
line 1815: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 1816: 
line 1817: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 1823: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 1824: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 1825: 
line 1826: " XFree86 config
line 1831: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 1834: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1835: 
line 1836: " Xorg config
line 1837: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1838: 
line 1839: " Xinetd conf
line 1840: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 1841: 
line 1842: " XS Perl extension interface language
line 1843: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 1844: 
line 1845: " X resources file
line 1846: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 1847: 
line 1848: " Xmath
line 1849: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 1851: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 1852: 
line 1853: " XML  specific variants: docbk and xbl
line 1854: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 1855: 
line 1856: " XMI (holding UML models) is also XML
line 1857: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 1858: 
line 1859: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 1860: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 1861: 
line 1862: " Qt Linguist translation source and Qt User Interface Files are XML
line 1863: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 1864: 
line 1865: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 1866: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 1867: 
line 1868: " Xdg menus
line 1869: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 1870: 
line 1871: " ATI graphics driver configuration
line 1872: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 1873: 
line 1874: " Web Services Description Language (WSDL)
line 1875: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 1876: 
line 1877: " XLIFF (XML Localisation Interchange File Format) is also XML
line 1878: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 1879: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 1880: 
line 1881: " XML User Interface Language
line 1882: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 1883: 
line 1884: " X11 xmodmap (also see below)
line 1885: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 1886: 
line 1887: " Xquery
line 1888: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 1889: 
line 1890: " XSD
line 1891: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 1892: 
line 1893: " Xslt
line 1894: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 1895: 
line 1896: " Yacc
line 1897: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 1898: 
line 1899: " Yacc or racc
line 1900: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 1901: 
line 1902: " Yaml
line 1903: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 1904: 
line 1905: " Raml
line 1906: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 1907: 
line 1908: " yum conf (close enough to dosini)
line 1909: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 1910: 
line 1911: " Zimbu
line 1912: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 1913: " Zimbu Templates
line 1914: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 1915: 
line 1916: " Zope
line 1917: "   dtml (zope dynamic template markup language), pt (zope page template),
line 1918: "   cpt (zope form controller page template)
line 1919: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 1920: "   zsql (zope sql method)
line 1921: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 1922: 
line 1923: " Z80 assembler asz80
line 1924: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 1925: 
line 1926: augroup END
line 1927: 
line 1928: 
line 1929: " Source the user-specified filetype file, for backwards compatibility with
line 1930: " Vim 5.x.
line 1931: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 1932:   execute "source " . myfiletypefile
line 1933: endif
line 1934: 
line 1935: 
line 1936: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 1937: " when there are no matching file name extensions.
line 1938: " Don't do this for compressed files.
line 1939: augroup filetypedetect
line 1942: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 1943: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 1944: 
line 1945: 
line 1946: " Extra checks for when no filetype has been detected now.  Mostly used for
line 1947: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 1948: " script file.
line 1949: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 1950: " like are used.
line 1951: 
line 1952: " More Apache style config files
line 1953: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 1954: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')
line 1955: 
line 1956: " More Apache config files
line 1957: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 1958: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*,auth_mysql.conf*,auth_pgsql.conf*,ssl.conf*,perl.conf*,php.conf*,python.conf*,squirrelmail.conf*^I^Icall s:StarSetf('apache')
line 1959: 
line 1960: " Asterisk config file
line 1961: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 1962: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 1963: 
line 1964: " Bazaar version control
line 1965: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 1966: 
line 1967: " Bazel build file
line 1968: if !has("fname_case")
line 1969:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
line 1970: endif
line 1971: 
line 1972: " BIND zone
line 1973: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 1974: 
line 1975: " Calendar
line 1978: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 1979: 
line 1980: " Changelog
line 1986: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 1987: 
line 1988: " Crontab
line 1989: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 1990: 
line 1991: " dnsmasq(8) configuration
line 1992: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 1993: 
line 1994: " Dracula
line 1995: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 1996: 
line 1997: " Fvwm
line 1998: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2000: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2006: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2007: 
line 2008: " Gedcom
line 2009: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2010: 
line 2011: " Git
line 2012: au BufNewFile,BufRead */.gitconfig.d/*,/etc/gitconfig.d/* ^Icall s:StarSetf('gitconfig')
line 2013: 
line 2014: " Gitolite
line 2015: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 2016: 
line 2017: " GTK RC
line 2018: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2019: 
line 2020: " Jam
line 2021: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2022: 
line 2023: " Jargon
line 2027: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2028: 
line 2029: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 2030: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 2031: 
line 2032: " Kconfig
line 2033: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2034: 
line 2035: " Lilo: Linux loader
line 2036: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2037: 
line 2038: " Logcheck
line 2039: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2040: 
line 2041: " Makefile
line 2042: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2043: 
line 2044: " Ruby Makefile
line 2045: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2046: 
line 2047: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2048: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2049: 
line 2050: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2051: 
line 2052: " Modconf
line 2056: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2057: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2058: 
line 2059: " Mutt setup file
line 2060: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2061: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2062: 
line 2063: " Neomutt setup file
line 2064: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 2065: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 2066: 
line 2067: " Nroff macros
line 2068: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2069: 
line 2070: " OpenBSD hostname.if
line 2071: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
line 2072: 
line 2073: " Pam conf
line 2074: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2075: 
line 2076: " Printcap and Termcap
line 2080: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2084: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2085: 
line 2086: " ReDIF
line 2087: " Only used when the .rdf file was not detected to be XML.
line 2088: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 2089: 
line 2090: " Remind
line 2091: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2092: 
line 2093: " SGML catalog file
line 2094: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 2095: 
line 2096: " Shell scripts ending in a star
line 2097: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
line 2098: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
line 2099: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
line 2100: 
line 2101: " tcsh scripts ending in a star
line 2102: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")
line 2103: 
line 2104: " csh scripts ending in a star
line 2105: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
line 2106: 
line 2107: " VHDL
line 2108: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2109: 
line 2110: " Vim script
line 2111: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2112: 
line 2113: " Subversion commit file
line 2114: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2115: 
line 2116: " X resources file
line 2117: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2118: 
line 2119: " XFree86 config
line 2121: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2126: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2127: 
line 2128: " X11 xmodmap
line 2129: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2130: 
line 2131: " Xinetd conf
line 2132: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2133: 
line 2134: " yum conf (close enough to dosini)
line 2135: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2136: 
line 2137: " Z-Shell script ending in a star
line 2138: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 2139: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2140: 
line 2141: 
line 2142: " Plain text files, needs to be far down to not override others.  This avoids
line 2143: " the "conf" type being used if there is a line starting with '#'.
line 2144: au BufNewFile,BufRead *.text,README^I^Isetf text
line 2145: 
line 2146: " Help files match *.txt but should have a last line that is a modeline.
line 2150: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2151: 
line 2152: 
line 2153: " Use the filetype detect plugins.  They may overrule any of the previously
line 2154: " detected filetypes.
line 2155: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftdetect/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftdetect/*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftdetect/*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/share/vim/vim81/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/home/w/.vim/after/ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2156: 
line 2157: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2158: " and started another one. Let's make sure it has ended to get to a consistent
line 2159: " state.
line 2160: augroup END
line 2161: 
line 2162: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2168: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2169: 
line 2170: 
line 2171: " If the GUI is already running, may still need to install the Syntax menu.
line 2172: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2174: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2175:   source <sfile>:p:h/menu.vim
line 2176: endif
line 2177: 
line 2178: " Function called for testing all functions defined here.  These are
line 2179: " script-local, thus need to be executed here.
line 2180: " Returns a string with error messages (hopefully empty).
line 2181: func! TestFiletypeFuncs(testlist)
line 2192: 
line 2193: " Restore 'cpoptions'
line 2194: let &cpo = s:cpo_save
line 2195: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in function pathogen#infect[20]..pathogen#cycle_filetype
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/w/.vim/after/filetype.vim"
line 4:   endif
function pathogen#infect[20]..pathogen#cycle_filetype returning #0

continuing in function pathogen#infect

line 21:   if pathogen#is_disabled($MYVIMRC)
calling function pathogen#infect[21]..pathogen#is_disabled('/home/w/.vimrc')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[21]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[21]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[21]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[21]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[21]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[21]..pathogen#is_disabled

line 6:   if !empty(blacklist)
line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 8:   endif
line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[21]..pathogen#is_disabled returning #0

continuing in function pathogen#infect

line 22:     return 'finish'
line 23:   endif
line 24:   return ''
function pathogen#infect returning ''

continuing in /home/w/.vimrc

line 2: 
line 3: 
line 4: " code format
line 5: syntax on
line 5: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 5: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2006 Apr 16
line 4: 
line 5: " This file is used for ":syntax off".
line 6: " It removes the autocommands and stops highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " Remove all autocommands for the Syntax event.  This also avoids that
line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 14: au! Syntax
line 15: 
line 16: " remove all syntax autocommands and remove the syntax for each buffer
line 17: augroup syntaxset
line 18:   au!
line 19:   au BufEnter * syn clear
line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 21:   doautoall syntaxset BufEnter *
line 22:   au!
line 23: augroup END
line 24: 
line 25: if exists("syntax_on")
line 26:   unlet syntax_on
line 27: endif
line 28: if exists("syntax_manual")
line 29:   unlet syntax_manual
line 30: endif
finished sourcing /usr/share/vim/vim81/syntax/nosyntax.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/syntax/synload.vim"
Searching for "/home/w/.vim/bundle/nerdtree/syntax/synload.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/syntax/synload.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/syntax/syncolor.vim"
Searching for "/home/w/.vim/bundle/nerdtree/syntax/syncolor.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/syntax/syncolor.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/w/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
line 76:   endif
line 77: endif
line 78: 
line 79: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in /home/w/.vimrc
line 6: filetype plugin indent on
Searching for "filetype.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/filetype.vim"
Searching for "/home/w/.vim/bundle/nerdtree/filetype.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/filetype.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 6: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2019 Mar 26
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in /home/w/.vimrc
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/w/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftplugin.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim81/ftplugin.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 6: sourcing "/usr/share/vim/vim81/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/share/vim/vim81/ftplugin.vim
continuing in /home/w/.vimrc
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/home/w/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/indent.vim"
Searching for "/home/w/.vim/bundle/nerdtree/indent.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/indent.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim81/indent.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 6: sourcing "/usr/share/vim/vim81/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
line 8: endif
line 9: let did_indent_on = 1
line 10: 
line 11: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
line 31: augroup END
finished sourcing /usr/share/vim/vim81/indent.vim
continuing in /home/w/.vimrc
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/home/w/.vim/after/indent.vim"
line 7: 
line 8: "let g:rtagsUseLocationList = 0
line 9: 
line 10: " key bindings
line 11: let mapleader = ","
line 12: map <Leader>n <plug>NERDTreeTabsToggle<CR>
finished sourcing $HOME/.vimrc
Searching for "pack/*/start/*" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/w/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/plugin/**/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/plugin/**/*.vim"
chdir(/home/w/.vim/bundle/nerdtree/plugin)
fchdir() to previous dir
sourcing "/home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim"
line 1: " ============================================================================
line 2: " File:        NERD_tree.vim
line 3: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 4: " License:     This program is free software. It comes without any warranty,
line 5: "              to the extent permitted by applicable law. You can redistribute
line 6: "              it and/or modify it under the terms of the Do What The Fuck You
line 7: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: " ============================================================================
line 11: "
line 12: " SECTION: Script init stuff {{{1
line 13: "============================================================
line 14: if exists("loaded_nerd_tree")
line 15:     finish
line 16: endif
line 17: if v:version < 703
line 18:     echoerr "NERDTree: this plugin requires vim >= 7.3. DOWNLOAD IT! You'll thank me later!"
line 19:     finish
line 20: endif
line 21: let loaded_nerd_tree = 1
line 22: 
line 23: "for line continuation - i.e dont want C in &cpo
line 24: let s:old_cpo = &cpo
line 25: set cpo&vim
line 26: 
line 27: "Function: s:initVariable() function {{{2
line 28: "This function is used to initialise a given variable to a given value. The
line 29: "variable is only initialised if it does not exist prior
line 30: "
line 31: "Args:
line 32: "var: the name of the var to be initialised
line 33: "value: the value to initialise var to
line 34: "
line 35: "Returns:
line 36: "1 if the var is set, 0 otherwise
line 37: function! s:initVariable(var, value)
line 44: 
line 45: "SECTION: Init variable calls and other random constants {{{2
line 46: call s:initVariable("g:NERDTreeAutoCenter", 1)
calling function <SNR>12_initVariable('g:NERDTreeAutoCenter', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenter = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 47: call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
calling function <SNR>12_initVariable('g:NERDTreeAutoCenterThreshold', 3)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenterThreshold = '3'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 48: call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
calling function <SNR>12_initVariable('g:NERDTreeCaseSensitiveSort', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCaseSensitiveSort = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 49: call s:initVariable("g:NERDTreeNaturalSort", 0)
calling function <SNR>12_initVariable('g:NERDTreeNaturalSort', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNaturalSort = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 50: call s:initVariable("g:NERDTreeSortHiddenFirst", 1)
calling function <SNR>12_initVariable('g:NERDTreeSortHiddenFirst', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortHiddenFirst = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 51: call s:initVariable("g:NERDTreeChDirMode", 0)
calling function <SNR>12_initVariable('g:NERDTreeChDirMode', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeChDirMode = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 52: call s:initVariable("g:NERDTreeCreatePrefix", "silent")
calling function <SNR>12_initVariable('g:NERDTreeCreatePrefix', 'silent')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCreatePrefix = 'silent'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 53: call s:initVariable("g:NERDTreeMinimalUI", 0)
calling function <SNR>12_initVariable('g:NERDTreeMinimalUI', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMinimalUI = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 54: call s:initVariable("g:NERDTreeMinimalMenu", 0)
calling function <SNR>12_initVariable('g:NERDTreeMinimalMenu', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMinimalMenu = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 55: if !exists("g:NERDTreeIgnore")
line 56:     let g:NERDTreeIgnore = ['\~$']
line 57: endif
line 58: call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
calling function <SNR>12_initVariable('g:NERDTreeBookmarksFile', '/home/w/.NERDTreeBookmarks')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksFile = '/home/w/.NERDTreeBookmarks'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 59: call s:initVariable("g:NERDTreeBookmarksSort", 1)
calling function <SNR>12_initVariable('g:NERDTreeBookmarksSort', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksSort = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 60: call s:initVariable("g:NERDTreeHighlightCursorline", 1)
calling function <SNR>12_initVariable('g:NERDTreeHighlightCursorline', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHighlightCursorline = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 61: call s:initVariable("g:NERDTreeHijackNetrw", 1)
calling function <SNR>12_initVariable('g:NERDTreeHijackNetrw', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHijackNetrw = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 62: call s:initVariable('g:NERDTreeMarkBookmarks', 1)
calling function <SNR>12_initVariable('g:NERDTreeMarkBookmarks', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMarkBookmarks = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 63: call s:initVariable("g:NERDTreeMouseMode", 1)
calling function <SNR>12_initVariable('g:NERDTreeMouseMode', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMouseMode = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 64: call s:initVariable("g:NERDTreeNotificationThreshold", 100)
calling function <SNR>12_initVariable('g:NERDTreeNotificationThreshold', 100)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNotificationThreshold = '100'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 65: call s:initVariable("g:NERDTreeQuitOnOpen", 0)
calling function <SNR>12_initVariable('g:NERDTreeQuitOnOpen', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeQuitOnOpen = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 66: call s:initVariable("g:NERDTreeRespectWildIgnore", 0)
calling function <SNR>12_initVariable('g:NERDTreeRespectWildIgnore', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRespectWildIgnore = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 67: call s:initVariable("g:NERDTreeShowBookmarks", 0)
calling function <SNR>12_initVariable('g:NERDTreeShowBookmarks', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowBookmarks = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 68: call s:initVariable("g:NERDTreeShowFiles", 1)
calling function <SNR>12_initVariable('g:NERDTreeShowFiles', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowFiles = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 69: call s:initVariable("g:NERDTreeShowHidden", 0)
calling function <SNR>12_initVariable('g:NERDTreeShowHidden', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowHidden = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 70: call s:initVariable("g:NERDTreeShowLineNumbers", 0)
calling function <SNR>12_initVariable('g:NERDTreeShowLineNumbers', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowLineNumbers = '0'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 71: call s:initVariable("g:NERDTreeSortDirs", 1)
calling function <SNR>12_initVariable('g:NERDTreeSortDirs', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortDirs = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 72: 
line 73: if !nerdtree#runningWindows() && !nerdtree#runningCygwin()
Searching for "autoload/nerdtree.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/autoload/nerdtree.vim"
Searching for "/home/w/.vim/bundle/nerdtree/autoload/nerdtree.vim"
chdir(/home/w/.vim/bundle/nerdtree/autoload)
fchdir() to previous dir
line 73: sourcing "/home/w/.vim/bundle/nerdtree/autoload/nerdtree.vim"
line 1: if exists("g:loaded_nerdtree_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_autoload = 1
line 5: 
line 6: let s:rootNERDTreePath = resolve(expand("<sfile>:p:h:h"))
line 7: function! nerdtree#version(...)
line 21: 
line 22: " SECTION: General Functions {{{1
line 23: "============================================================
line 24: 
line 25: function! nerdtree#slash()
line 37: 
line 38: "FUNCTION: nerdtree#and(x,y) {{{2
line 39: " Implements and() function for Vim <= 7.2
line 40: function! nerdtree#and(x,y)
line 60: 
line 61: "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
line 62: "inits a window tree in the current buffer if appropriate
line 63: function! nerdtree#checkForBrowse(dir)
line 74: 
line 75: "FUNCTION: s:reuseWin(dir) {{{2
line 76: "finds a NERDTree buffer with root of dir, and opens it.
line 77: function! s:reuseWin(dir) abort
line 96: 
line 97: " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
line 98: " completion function for the bookmark commands
line 99: function! nerdtree#completeBookmarks(A,L,P)
line 102: 
line 103: "FUNCTION: nerdtree#compareNodes(dir) {{{2
line 104: function! nerdtree#compareNodes(n1, n2)
line 107: 
line 108: "FUNCTION: nerdtree#compareNodesBySortKey(n1, n2) {{{2
line 109: function! nerdtree#compareNodesBySortKey(n1, n2)
line 141: 
line 142: " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
line 143: " Issue a deprecation warning for a:func. If a second arg is given, use this
line 144: " as the deprecation message
line 145: function! nerdtree#deprecated(func, ...)
line 156: 
line 157: " FUNCTION: nerdtree#exec(cmd, ignoreAll) {{{2
line 158: " Same as :exec cmd but, if ignoreAll is TRUE, set eventignore=all for the duration
line 159: function! nerdtree#exec(cmd, ignoreAll)
line 167: 
line 168: " FUNCTION: nerdtree#has_opt(options, name) {{{2
line 169: function! nerdtree#has_opt(options, name)
line 172: 
line 173: " FUNCTION: nerdtree#loadClassFiles() {{{2
line 174: function! nerdtree#loadClassFiles()
line 190: 
line 191: " FUNCTION: nerdtree#postSourceActions() {{{2
line 192: function! nerdtree#postSourceActions()
line 199: 
line 200: "FUNCTION: nerdtree#runningWindows(dir) {{{2
line 201: function! nerdtree#runningWindows()
line 204: 
line 205: "FUNCTION: nerdtree#runningCygwin(dir) {{{2
line 206: function! nerdtree#runningCygwin()
line 209: 
line 210: " SECTION: View Functions {{{1
line 211: "============================================================
line 212: 
line 213: "FUNCTION: nerdtree#echo  {{{2
line 214: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
line 215: "
line 216: "Args:
line 217: "msg: the message to echo
line 218: function! nerdtree#echo(msg)
line 222: 
line 223: "FUNCTION: nerdtree#echoError {{{2
line 224: "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
line 225: "Args:
line 226: "msg: the message to echo
line 227: function! nerdtree#echoError(msg)
line 232: 
line 233: "FUNCTION: nerdtree#echoWarning {{{2
line 234: "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
line 235: "Args:
line 236: "msg: the message to echo
line 237: function! nerdtree#echoWarning(msg)
line 242: 
line 243: "FUNCTION: nerdtree#renderView {{{2
line 244: function! nerdtree#renderView()
line 247: 
line 248: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/autoload/nerdtree.vim
continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

calling function nerdtree#runningCygwin()

line 1:     return has("win32unix")
function nerdtree#runningCygwin returning #0

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 74:     call s:initVariable("g:NERDTreeDirArrowExpandable", "")
calling function <SNR>12_initVariable('g:NERDTreeDirArrowExpandable', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeDirArrowExpandable = ''
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 75:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "")
calling function <SNR>12_initVariable('g:NERDTreeDirArrowCollapsible', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeDirArrowCollapsible = ''
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 76: else
line 77:     call s:initVariable("g:NERDTreeDirArrowExpandable", "+")
line 78:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "~")
line 79: endif
line 80: 
line 81: call s:initVariable("g:NERDTreeCascadeOpenSingleChildDir", 1)
calling function <SNR>12_initVariable('g:NERDTreeCascadeOpenSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeOpenSingleChildDir = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 82: call s:initVariable("g:NERDTreeCascadeSingleChildDir", 1)
calling function <SNR>12_initVariable('g:NERDTreeCascadeSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeSingleChildDir = '1'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 83: 
line 84: if !exists("g:NERDTreeSortOrder")
line 85:     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
line 86: endif
line 87: let g:NERDTreeOldSortOrder = []
line 88: 
line 89: call s:initVariable("g:NERDTreeGlyphReadOnly", "RO")
calling function <SNR>12_initVariable('g:NERDTreeGlyphReadOnly', 'RO')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeGlyphReadOnly = 'RO'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 90: 
line 91: if has("conceal")
line 92:     call s:initVariable("g:NERDTreeNodeDelimiter", "\x07")
calling function <SNR>12_initVariable('g:NERDTreeNodeDelimiter', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNodeDelimiter = '^G'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 93: elseif (g:NERDTreeDirArrowExpandable == "\u00a0" || g:NERDTreeDirArrowCollapsible == "\u00a0")
line 94:     call s:initVariable("g:NERDTreeNodeDelimiter", "\u00b7")
line 95: else
line 96:     call s:initVariable("g:NERDTreeNodeDelimiter", "\u00a0")
line 97: endif
line 98: 
line 99: if !exists('g:NERDTreeStatusline')
line 100: 
line 101:     "the exists() crap here is a hack to stop vim spazzing out when
line 102:     "loading a session that was created with an open nerd tree. It spazzes
line 103:     "because it doesnt store b:NERDTree(its a b: var, and its a hash)
line 104:     let g:NERDTreeStatusline = "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}"
line 105: 
line 106: endif
line 107: call s:initVariable("g:NERDTreeWinPos", "left")
calling function <SNR>12_initVariable('g:NERDTreeWinPos', 'left')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinPos = 'left'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 108: call s:initVariable("g:NERDTreeWinSize", 31)
calling function <SNR>12_initVariable('g:NERDTreeWinSize', 31)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinSize = '31'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 109: 
line 110: "init the shell commands that will be used to copy nodes, and remove dir trees
line 111: "
line 112: "Note: the space after the command is important
line 113: if nerdtree#runningWindows()
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 114:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
line 115:     call s:initVariable("g:NERDTreeCopyDirCmd", 'xcopy /s /e /i /y /q ')
line 116:     call s:initVariable("g:NERDTreeCopyFileCmd", 'copy /y ')
line 117: else
line 118:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
calling function <SNR>12_initVariable('g:NERDTreeRemoveDirCmd', 'rm -rf ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRemoveDirCmd = 'rm -rf '
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 119:     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
calling function <SNR>12_initVariable('g:NERDTreeCopyCmd', 'cp -r ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCopyCmd = 'cp -r '
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 120: endif
line 121: 
line 122: 
line 123: "SECTION: Init variable calls for key mappings {{{2
line 124: call s:initVariable("g:NERDTreeMapCustomOpen", "<CR>")
calling function <SNR>12_initVariable('g:NERDTreeMapCustomOpen', '<CR>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCustomOpen = '<CR>'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 125: call s:initVariable("g:NERDTreeMapActivateNode", "o")
calling function <SNR>12_initVariable('g:NERDTreeMapActivateNode', 'o')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapActivateNode = 'o'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 126: call s:initVariable("g:NERDTreeMapChangeRoot", "C")
calling function <SNR>12_initVariable('g:NERDTreeMapChangeRoot', 'C')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChangeRoot = 'C'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 127: call s:initVariable("g:NERDTreeMapChdir", "cd")
calling function <SNR>12_initVariable('g:NERDTreeMapChdir', 'cd')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChdir = 'cd'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 128: call s:initVariable("g:NERDTreeMapCloseChildren", "X")
calling function <SNR>12_initVariable('g:NERDTreeMapCloseChildren', 'X')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseChildren = 'X'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 129: call s:initVariable("g:NERDTreeMapCloseDir", "x")
calling function <SNR>12_initVariable('g:NERDTreeMapCloseDir', 'x')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseDir = 'x'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 130: call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
calling function <SNR>12_initVariable('g:NERDTreeMapDeleteBookmark', 'D')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapDeleteBookmark = 'D'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 131: call s:initVariable("g:NERDTreeMapMenu", "m")
calling function <SNR>12_initVariable('g:NERDTreeMapMenu', 'm')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapMenu = 'm'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 132: call s:initVariable("g:NERDTreeMapHelp", "?")
calling function <SNR>12_initVariable('g:NERDTreeMapHelp', '?')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapHelp = '?'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 133: call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
calling function <SNR>12_initVariable('g:NERDTreeMapJumpFirstChild', 'K')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpFirstChild = 'K'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 134: call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
calling function <SNR>12_initVariable('g:NERDTreeMapJumpLastChild', 'J')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpLastChild = 'J'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 135: call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
calling function <SNR>12_initVariable('g:NERDTreeMapJumpNextSibling', '<C-j>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpNextSibling = '<C-j>'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 136: call s:initVariable("g:NERDTreeMapJumpParent", "p")
calling function <SNR>12_initVariable('g:NERDTreeMapJumpParent', 'p')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpParent = 'p'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 137: call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
calling function <SNR>12_initVariable('g:NERDTreeMapJumpPrevSibling', '<C-k>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpPrevSibling = '<C-k>'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 138: call s:initVariable("g:NERDTreeMapJumpRoot", "P")
calling function <SNR>12_initVariable('g:NERDTreeMapJumpRoot', 'P')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpRoot = 'P'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 139: call s:initVariable("g:NERDTreeMapOpenExpl", "e")
calling function <SNR>12_initVariable('g:NERDTreeMapOpenExpl', 'e')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenExpl = 'e'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 140: call s:initVariable("g:NERDTreeMapOpenInTab", "t")
calling function <SNR>12_initVariable('g:NERDTreeMapOpenInTab', 't')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTab = 't'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 141: call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
calling function <SNR>12_initVariable('g:NERDTreeMapOpenInTabSilent', 'T')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTabSilent = 'T'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 142: call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
calling function <SNR>12_initVariable('g:NERDTreeMapOpenRecursively', 'O')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenRecursively = 'O'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 143: call s:initVariable("g:NERDTreeMapOpenSplit", "i")
calling function <SNR>12_initVariable('g:NERDTreeMapOpenSplit', 'i')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenSplit = 'i'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 144: call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
calling function <SNR>12_initVariable('g:NERDTreeMapOpenVSplit', 's')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenVSplit = 's'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 145: call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
calling function <SNR>12_initVariable('g:NERDTreeMapPreview', 'go')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreview = 'go'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 146: call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
calling function <SNR>12_initVariable('g:NERDTreeMapPreviewSplit', 'gi')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewSplit = 'gi'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 147: call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
calling function <SNR>12_initVariable('g:NERDTreeMapPreviewVSplit', 'gs')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewVSplit = 'gs'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 148: call s:initVariable("g:NERDTreeMapQuit", "q")
calling function <SNR>12_initVariable('g:NERDTreeMapQuit', 'q')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapQuit = 'q'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 149: call s:initVariable("g:NERDTreeMapRefresh", "r")
calling function <SNR>12_initVariable('g:NERDTreeMapRefresh', 'r')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefresh = 'r'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 150: call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
calling function <SNR>12_initVariable('g:NERDTreeMapRefreshRoot', 'R')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefreshRoot = 'R'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 151: call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
calling function <SNR>12_initVariable('g:NERDTreeMapToggleBookmarks', 'B')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleBookmarks = 'B'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 152: call s:initVariable("g:NERDTreeMapToggleFiles", "F")
calling function <SNR>12_initVariable('g:NERDTreeMapToggleFiles', 'F')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFiles = 'F'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 153: call s:initVariable("g:NERDTreeMapToggleFilters", "f")
calling function <SNR>12_initVariable('g:NERDTreeMapToggleFilters', 'f')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFilters = 'f'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 154: call s:initVariable("g:NERDTreeMapToggleHidden", "I")
calling function <SNR>12_initVariable('g:NERDTreeMapToggleHidden', 'I')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleHidden = 'I'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 155: call s:initVariable("g:NERDTreeMapToggleZoom", "A")
calling function <SNR>12_initVariable('g:NERDTreeMapToggleZoom', 'A')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleZoom = 'A'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 156: call s:initVariable("g:NERDTreeMapUpdir", "u")
calling function <SNR>12_initVariable('g:NERDTreeMapUpdir', 'u')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdir = 'u'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 157: call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
calling function <SNR>12_initVariable('g:NERDTreeMapUpdirKeepOpen', 'U')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdirKeepOpen = 'U'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 158: call s:initVariable("g:NERDTreeMapCWD", "CD")
calling function <SNR>12_initVariable('g:NERDTreeMapCWD', 'CD')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCWD = 'CD'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 159: call s:initVariable("g:NERDTreeMenuDown", "j")
calling function <SNR>12_initVariable('g:NERDTreeMenuDown', 'j')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMenuDown = 'j'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 160: call s:initVariable("g:NERDTreeMenuUp", "k")
calling function <SNR>12_initVariable('g:NERDTreeMenuUp', 'k')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMenuUp = 'k'
line 3:         return 1
function <SNR>12_initVariable returning #1

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 161: 
line 162: "SECTION: Load class files{{{2
line 163: call nerdtree#loadClassFiles()
calling function nerdtree#loadClassFiles()

line 1:     runtime lib/nerdtree/path.vim
Searching for "lib/nerdtree/path.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/path.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/path.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 1: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/path.vim"
line 1: " ============================================================================
line 2: " CLASS: Path
line 3: "
line 4: " The Path class provides an abstracted representation of a file system
line 5: " pathname.  Various operations on pathnames are provided and a number of
line 6: " representations of a given path name can be accessed here.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:Path = {}
line 11: let g:NERDTreePath = s:Path
line 12: 
line 13: " FUNCTION: Path.AbsolutePathFor(pathStr) {{{1
line 14: function! s:Path.AbsolutePathFor(pathStr)
line 37: 
line 38: " FUNCTION: Path.bookmarkNames() {{{1
line 39: function! s:Path.bookmarkNames()
line 45: 
line 46: " FUNCTION: Path.cacheDisplayString() {{{1
line 47: function! s:Path.cacheDisplayString() abort
line 72: 
line 73: " FUNCTION: Path.addDelimiter() {{{1
line 74: function! s:Path.addDelimiter(line)
line 81: 
line 82: " FUNCTION: Path.changeToDir() {{{1
line 83: function! s:Path.changeToDir()
line 96: 
line 97: " FUNCTION: Path.compareTo() {{{1
line 98: "
line 99: " Compares this Path to the given path and returns 0 if they are equal, -1 if
line 100: " this Path is "less than" the given path, or 1 if it is "greater".
line 101: "
line 102: " Args:
line 103: " path: the path object to compare this to
line 104: "
line 105: " Return:
line 106: " 1, -1 or 0
line 107: function! s:Path.compareTo(path)
line 140: 
line 141: " FUNCTION: Path.Create(fullpath) {{{1
line 142: "
line 143: " Factory method.
line 144: "
line 145: " Creates a path object with the given path. The path is also created on the
line 146: " filesystem. If the path already exists, a NERDTree.Path.Exists exception is
line 147: " thrown. If any other errors occur, a NERDTree.Path exception is thrown.
line 148: "
line 149: " Args:
line 150: " fullpath: the full filesystem path to the file/dir to create
line 151: function! s:Path.Create(fullpath)
line 177: 
line 178: " FUNCTION: Path.copy(dest) {{{1
line 179: "
line 180: " Copies the file/dir represented by this Path to the given location
line 181: "
line 182: " Args:
line 183: " dest: the location to copy this dir/file to
line 184: function! s:Path.copy(dest)
line 203: 
line 204: " FUNCTION: Path.CopyingSupported() {{{1
line 205: "
line 206: " returns 1 if copying is supported for this OS
line 207: function! s:Path.CopyingSupported()
line 210: 
line 211: " FUNCTION: Path.copyingWillOverwrite(dest) {{{1
line 212: "
line 213: " returns 1 if copy this path to the given location will cause files to
line 214: " overwritten
line 215: "
line 216: " Args:
line 217: " dest: the location this path will be copied to
line 218: function! s:Path.copyingWillOverwrite(dest)
line 230: 
line 231: " FUNCTION: Path.createParentDirectories(path) {{{1
line 232: "
line 233: " create parent directories for this path if needed
line 234: " without throwing any errors if those directories already exist
line 235: "
line 236: " Args:
line 237: " path: full path of the node whose parent directories may need to be created
line 238: function! s:Path.createParentDirectories(path)
line 244: 
line 245: " FUNCTION: Path.delete() {{{1
line 246: "
line 247: " Deletes the file or directory represented by this path.
line 248: "
line 249: " Throws NERDTree.Path.Deletion exceptions
line 250: function! s:Path.delete()
line 278: 
line 279: " FUNCTION: Path.displayString() {{{1
line 280: "
line 281: " Returns a string that specifies how the path should be represented as a
line 282: " string
line 283: function! s:Path.displayString()
line 290: 
line 291: " FUNCTION: Path.edit() {{{1
line 292: function! s:Path.edit()
line 295: 
line 296: " FUNCTION: Path.extractDriveLetter(fullpath) {{{1
line 297: "
line 298: " If running windows, cache the drive letter for this path
line 299: function! s:Path.extractDriveLetter(fullpath)
line 313: 
line 314: " FUNCTION: Path.exists() {{{1
line 315: " return 1 if this path points to a location that is readable or is a directory
line 316: function! s:Path.exists()
line 320: 
line 321: " FUNCTION: Path._escChars() {{{1
line 322: function! s:Path._escChars()
line 329: 
line 330: " FUNCTION: Path.getDir() {{{1
line 331: "
line 332: " Returns this path if it is a directory, else this paths parent.
line 333: "
line 334: " Return:
line 335: " a Path object
line 336: function! s:Path.getDir()
line 343: 
line 344: " FUNCTION: Path.getParent() {{{1
line 345: "
line 346: " Returns a new path object for this paths parent
line 347: "
line 348: " Return:
line 349: " a new Path object
line 350: function! s:Path.getParent()
line 359: 
line 360: " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
line 361: "
line 362: " Gets the last part of this path.
line 363: "
line 364: " Args:
line 365: " dirSlash: if 1 then a trailing slash will be added to the returned value for
line 366: " directory nodes.
line 367: function! s:Path.getLastPathComponent(dirSlash)
line 377: 
line 378: " FUNCTION: Path.getSortOrderIndex() {{{1
line 379: " returns the index of the pattern in g:NERDTreeSortOrder that this path matches
line 380: function! s:Path.getSortOrderIndex()
line 392: 
line 393: " FUNCTION: Path._splitChunks(path) {{{1
line 394: " returns a list of path chunks
line 395: function! s:Path._splitChunks(path)
line 407: 
line 408: " FUNCTION: Path.getSortKey() {{{1
line 409: " returns a key used in compare function for sorting
line 410: function! s:Path.getSortKey()
line 445: 
line 446: " FUNCTION: Path.isHiddenUnder(path) {{{1
line 447: function! s:Path.isHiddenUnder(path)
line 465: 
line 466: " FUNCTION: Path.isUnixHiddenFile() {{{1
line 467: " check for unix hidden files
line 468: function! s:Path.isUnixHiddenFile()
line 471: 
line 472: " FUNCTION: Path.isUnixHiddenPath() {{{1
line 473: " check for unix path with hidden components
line 474: function! s:Path.isUnixHiddenPath()
line 486: 
line 487: " FUNCTION: Path.ignore(nerdtree) {{{1
line 488: " returns true if this path should be ignored
line 489: function! s:Path.ignore(nerdtree)
line 516: 
line 517: " FUNCTION: Path._ignorePatternMatches(pattern) {{{1
line 518: " returns true if this path matches the given ignore pattern
line 519: function! s:Path._ignorePatternMatches(pattern)
line 535: 
line 536: " FUNCTION: Path.isAncestor(path) {{{1
line 537: " return 1 if this path is somewhere above the given path in the filesystem.
line 538: "
line 539: " a:path should be a dir
line 540: function! s:Path.isAncestor(path)
line 549: 
line 550: " FUNCTION: Path.isUnder(path) {{{1
line 551: " return 1 if this path is somewhere under the given path in the filesystem.
line 552: function! s:Path.isUnder(path)
line 561: 
line 562: " FUNCTION: Path.JoinPathStrings(...) {{{1
line 563: function! s:Path.JoinPathStrings(...)
line 570: 
line 571: " FUNCTION: Path.equals() {{{1
line 572: "
line 573: " Determines whether 2 path objects are "equal".
line 574: " They are equal if the paths they represent are the same
line 575: "
line 576: " Args:
line 577: " path: the other path obj to compare this with
line 578: function! s:Path.equals(path)
line 585: 
line 586: " FUNCTION: Path.New(pathStr) {{{1
line 587: function! s:Path.New(pathStr)
line 597: 
line 598: " FUNCTION: Path.Slash() {{{1
line 599: " Return the path separator used by the underlying file system.  Special
line 600: " consideration is taken for the use of the 'shellslash' option on Windows
line 601: " systems.
line 602: function! s:Path.Slash()
line 614: 
line 615: " FUNCTION: Path.Resolve() {{{1
line 616: " Invoke the vim resolve() function and return the result
line 617: " This is necessary because in some versions of vim resolve() removes trailing
line 618: " slashes while in other versions it doesn't.  This always removes the trailing
line 619: " slash
line 620: function! s:Path.Resolve(path)
line 624: 
line 625: " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
line 626: "
line 627: "
line 628: " Throws NERDTree.Path.InvalidArguments exception.
line 629: function! s:Path.readInfoFromDisk(fullpath)
line 678: 
line 679: " FUNCTION: Path.refresh(nerdtree) {{{1
line 680: function! s:Path.refresh(nerdtree)
line 685: 
line 686: " FUNCTION: Path.refreshFlags(nerdtree) {{{1
line 687: function! s:Path.refreshFlags(nerdtree)
line 691: 
line 692: " FUNCTION: Path.rename() {{{1
line 693: "
line 694: " Renames this node on the filesystem
line 695: function! s:Path.rename(newPath)
line 714: 
line 715: " FUNCTION: Path.str() {{{1
line 716: " Return a string representation of this Path object.
line 717: "
line 718: " Args:
line 719: " This function takes a single dictionary (optional) with keys and values that
line 720: " specify how the returned pathname should be formatted.
line 721: "
line 722: " The dictionary may have the following keys:
line 723: "  'format'
line 724: "  'escape'
line 725: "  'truncateTo'
line 726: "
line 727: " The 'format' key may have a value of:
line 728: "  'Cd' - a string to be used with ":cd" and similar commands
line 729: "  'Edit' - a string to be used with ":edit" and similar commands
line 730: "  'UI' - a string to be displayed in the NERDTree user interface
line 731: "
line 732: " The 'escape' key, if specified, will cause the output to be escaped with
line 733: " Vim's internal "shellescape()" function.
line 734: "
line 735: " The 'truncateTo' key shortens the length of the path to that given by the
line 736: " value associated with 'truncateTo'. A '<' is prepended.
line 737: function! s:Path.str(...)
line 772: 
line 773: " FUNCTION: Path._strForUI() {{{1
line 774: function! s:Path._strForUI()
line 781: 
line 782: " FUNCTION: Path._strForCd() {{{1
line 783: " Return a string representation of this Path that is suitable for use as an
line 784: " argument to Vim's internal ":cd" command.
line 785: function! s:Path._strForCd()
line 788: 
line 789: " FUNCTION: Path._strForEdit() {{{1
line 790: " Return a string representation of this Path that is suitable for use as an
line 791: " argument to Vim's internal ":edit" command.
line 792: function! s:Path._strForEdit()
line 811: 
line 812: " FUNCTION: Path._strForGlob() {{{1
line 813: function! s:Path._strForGlob()
line 828: 
line 829: " FUNCTION: Path._str() {{{1
line 830: " Return the absolute pathname associated with this Path object.  The pathname
line 831: " returned is appropriate for the underlying file system.
line 832: function! s:Path._str()
line 842: 
line 843: " FUNCTION: Path.strTrunk() {{{1
line 844: " Gets the path without the last segment on the end.
line 845: function! s:Path.strTrunk()
line 848: 
line 849: " FUNCTION: Path.tabnr() {{{1
line 850: " return the number of the first tab that is displaying this file
line 851: "
line 852: " return 0 if no tab was found
line 853: function! s:Path.tabnr()
line 864: 
line 865: " FUNCTION: Path.WinToUnixPath(pathstr){{{1
line 866: " Takes in a windows path and returns the unix equiv
line 867: "
line 868: " A class level method
line 869: "
line 870: " Args:
line 871: " pathstr: the windows path to convert
line 872: function! s:Path.WinToUnixPath(pathstr)
line 890: 
line 891: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/path.vim
continuing in function nerdtree#loadClassFiles
line 2:     runtime lib/nerdtree/menu_controller.vim
Searching for "lib/nerdtree/menu_controller.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 2: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"
line 1: "CLASS: MenuController
line 2: "============================================================
line 3: let s:MenuController = {}
line 4: let g:NERDTreeMenuController = s:MenuController
line 5: 
line 6: "FUNCTION: MenuController.New(menuItems) {{{1
line 7: "create a new menu controller that operates on the given menu items
line 8: function! s:MenuController.New(menuItems)
line 17: 
line 18: " FUNCTION: s:MenuController.isMinimal() {{{1
line 19: function! s:MenuController.isMinimal()
line 22: 
line 23: " FUNCTION: MenuController.showMenu() {{{1
line 24: " Enter the main loop of the NERDTree menu, prompting the user to select
line 25: " a menu item.
line 26: function! s:MenuController.showMenu()
line 58: 
line 59: "FUNCTION: MenuController._echoPrompt() {{{1
line 60: function! s:MenuController._echoPrompt()
line 84: 
line 85: "FUNCTION: MenuController._current(key) {{{1
line 86: "get the MenuItem that is currently selected
line 87: function! s:MenuController._current()
line 90: 
line 91: "FUNCTION: MenuController._handleKeypress(key) {{{1
line 92: "change the selection (if appropriate) and return 1 if the user has made
line 93: "their choice, 0 otherwise
line 94: function! s:MenuController._handleKeypress(key)
line 116: 
line 117: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
line 118: "get indexes to all menu items with the given shortcut
line 119: function! s:MenuController._allIndexesFor(shortcut)
line 130: 
line 131: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
line 132: "get the index to the next menu item with the given shortcut, starts from the
line 133: "current cursor location and wraps around to the top again if need be
line 134: function! s:MenuController._nextIndexFor(shortcut)
line 149: 
line 150: "FUNCTION: MenuController._setCmdheight() {{{1
line 151: "sets &cmdheight to whatever is needed to display the menu
line 152: function! s:MenuController._setCmdheight()
line 159: 
line 160: "FUNCTION: MenuController._saveOptions() {{{1
line 161: "set any vim options that are required to make the menu work (saving their old
line 162: "values)
line 163: function! s:MenuController._saveOptions()
line 169: 
line 170: "FUNCTION: MenuController._restoreOptions() {{{1
line 171: "restore the options we saved in _saveOptions()
line 172: function! s:MenuController._restoreOptions()
line 176: 
line 177: "FUNCTION: MenuController._cursorDown() {{{1
line 178: "move the cursor to the next menu item, skipping separators
line 179: function! s:MenuController._cursorDown()
line 193: 
line 194: "FUNCTION: MenuController._cursorUp() {{{1
line 195: "move the cursor to the previous menu item, skipping separators
line 196: function! s:MenuController._cursorUp()
line 210: 
line 211: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim
continuing in function nerdtree#loadClassFiles
line 3:     runtime lib/nerdtree/menu_item.vim
Searching for "lib/nerdtree/menu_item.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 3: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"
line 1: "CLASS: MenuItem
line 2: "============================================================
line 3: let s:MenuItem = {}
line 4: let g:NERDTreeMenuItem = s:MenuItem
line 5: 
line 6: "FUNCTION: MenuItem.All() {{{1
line 7: "get all top level menu items
line 8: function! s:MenuItem.All()
line 14: 
line 15: "FUNCTION: MenuItem.AllEnabled() {{{1
line 16: "get all top level menu items that are currently enabled
line 17: function! s:MenuItem.AllEnabled()
line 26: 
line 27: "FUNCTION: MenuItem.Create(options) {{{1
line 28: "make a new menu item and add it to the global list
line 29: function! s:MenuItem.Create(options)
line 54: 
line 55: "FUNCTION: MenuItem.CreateSeparator(options) {{{1
line 56: "make a new separator menu item and add it to the global list
line 57: function! s:MenuItem.CreateSeparator(options)
line 65: 
line 66: "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
line 67: "make a new submenu and add it to global list
line 68: function! s:MenuItem.CreateSubmenu(options)
line 74: 
line 75: "FUNCTION: MenuItem.enabled() {{{1
line 76: "return 1 if this menu item should be displayed
line 77: "
line 78: "delegates off to the isActiveCallback, and defaults to 1 if no callback was
line 79: "specified
line 80: function! s:MenuItem.enabled()
line 86: 
line 87: "FUNCTION: MenuItem.execute() {{{1
line 88: "perform the action behind this menu item, if this menuitem has children then
line 89: "display a new menu for them, otherwise deletegate off to the menuitem's
line 90: "callback
line 91: function! s:MenuItem.execute()
line 101: 
line 102: "FUNCTION: MenuItem.isSeparator() {{{1
line 103: "return 1 if this menuitem is a separator
line 104: function! s:MenuItem.isSeparator()
line 107: 
line 108: "FUNCTION: MenuItem.isSubmenu() {{{1
line 109: "return 1 if this menuitem is a submenu
line 110: function! s:MenuItem.isSubmenu()
line 113: 
line 114: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim
continuing in function nerdtree#loadClassFiles
line 4:     runtime lib/nerdtree/key_map.vim
Searching for "lib/nerdtree/key_map.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/key_map.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 4: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"
line 1: "CLASS: KeyMap
line 2: "============================================================
line 3: let s:KeyMap = {}
line 4: let g:NERDTreeKeyMap = s:KeyMap
line 5: let s:keyMaps = {}
line 6: 
line 7: "FUNCTION: KeyMap.All() {{{1
line 8: function! s:KeyMap.All()
line 14: 
line 15: "FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1
line 16: function! s:KeyMap.Compare(keyMap1, keyMap2)
line 28: 
line 29: "FUNCTION: KeyMap.FindFor(key, scope) {{{1
line 30: function! s:KeyMap.FindFor(key, scope)
line 33: 
line 34: "FUNCTION: KeyMap.BindAll() {{{1
line 35: function! s:KeyMap.BindAll()
line 40: 
line 41: "FUNCTION: KeyMap.bind() {{{1
line 42: function! s:KeyMap.bind()
line 60: 
line 61: "FUNCTION: KeyMap.Remove(key, scope) {{{1
line 62: function! s:KeyMap.Remove(key, scope)
line 65: 
line 66: "FUNCTION: KeyMap.invoke() {{{1
line 67: "Call the KeyMaps callback function
line 68: function! s:KeyMap.invoke(...)
line 76: 
line 77: "FUNCTION: KeyMap.Invoke() {{{1
line 78: "Find a keymapping for a:key and the current scope invoke it.
line 79: "
line 80: "Scope is determined as follows:
line 81: "   * if the cursor is on a dir node then "DirNode"
line 82: "   * if the cursor is on a file node then "FileNode"
line 83: "   * if the cursor is on a bookmark then "Bookmark"
line 84: "
line 85: "If a keymap has the scope of "all" then it will be called if no other keymap
line 86: "is found for a:key and the scope.
line 87: function! s:KeyMap.Invoke(key)
line 140: 
line 141: "FUNCTION: KeyMap.Create(options) {{{1
line 142: function! s:KeyMap.Create(options)
line 158: 
line 159: "FUNCTION: KeyMap.Add(keymap) {{{1
line 160: function! s:KeyMap.Add(keymap)
line 163: 
line 164: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim
continuing in function nerdtree#loadClassFiles
line 5:     runtime lib/nerdtree/bookmark.vim
Searching for "lib/nerdtree/bookmark.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 5: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"
line 1: " ============================================================================
line 2: " CLASS: Bookmark
line 3: "
line 4: " The Bookmark class serves two purposes:
line 5: "   (1) It is the top-level prototype for new, concrete Bookmark objects.
line 6: "   (2) It provides an interface for client code to query and manipulate the
line 7: "       global list of Bookmark objects within the current Vim session.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Bookmark = {}
line 12: let g:NERDTreeBookmark = s:Bookmark
line 13: 
line 14: " FUNCTION: Bookmark.activate(nerdtree) {{{1
line 15: function! s:Bookmark.activate(nerdtree, ...)
line 18: 
line 19: " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
line 20: " Class method to add a new bookmark to the list, if a previous bookmark exists
line 21: " with the same name, just update the path for that bookmark
line 22: function! s:Bookmark.AddBookmark(name, path)
line 31: 
line 32: " FUNCTION: Bookmark.Bookmarks() {{{1
line 33: " Class method to get all bookmarks. Lazily initializes the bookmarks global
line 34: " variable
line 35: function! s:Bookmark.Bookmarks()
line 41: 
line 42: " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1
line 43: " class method that returns 1 if a bookmark with the given name is found, 0
line 44: " otherwise
line 45: function! s:Bookmark.BookmarkExistsFor(name)
line 53: 
line 54: " FUNCTION: Bookmark.BookmarkFor(name) {{{1
line 55: " Class method that returns the Bookmark object having the specified name.
line 56: " Throws "NERDTree.BookmarkNotFoundError" if no Bookmark is found.
line 57: function! s:Bookmark.BookmarkFor(name)
line 70: 
line 71: " FUNCTION: Bookmark.BookmarkNames() {{{1
line 72: " Class method to return an array of all bookmark names
line 73: function! s:Bookmark.BookmarkNames()
line 80: 
line 81: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
line 82: " Class method to read all bookmarks from the bookmarks file initialize
line 83: " bookmark objects for each one.
line 84: "
line 85: " Args:
line 86: " silent - dont echo an error msg if invalid bookmarks are found
line 87: function! s:Bookmark.CacheBookmarks(silent)
line 119: 
line 120: " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1
line 121: " Class method that indicates the relative position of two bookmarks when
line 122: " placed in alphabetical order by name. Case-sensitivity is determined by an
line 123: " option. Supports the "s:Bookmark.SortBookmarksList()" method.
line 124: function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)
line 141: 
line 142: " FUNCTION: Bookmark.ClearAll() {{{1
line 143: " Class method to delete all bookmarks.
line 144: function! s:Bookmark.ClearAll()
line 150: 
line 151: " FUNCTION: Bookmark.delete() {{{1
line 152: " Delete this bookmark. If the node for this bookmark is under the current
line 153: " root, then recache bookmarks for its Path object
line 154: function! s:Bookmark.delete()
line 158: 
line 159: " FUNCTION: s:Edit() {{{1
line 160: " opens the NERDTreeBookmarks file for manual editing
line 161: function! s:Bookmark.Edit()
line 165: 
line 166: " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
line 167: " Returns the tree node object associated with this Bookmark.
line 168: " Throws "NERDTree.BookmarkedNodeNotFoundError" if the node is not found.
line 169: "
line 170: " Args:
line 171: " searchFromAbsoluteRoot: boolean flag, search from the highest cached node
line 172: "   if true and from the current tree root if false
line 173: function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
line 185: 
line 186: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
line 187: " Class method that returns the tree node object for the Bookmark with the
line 188: " given name. Throws "NERDTree.BookmarkNotFoundError" if a Bookmark with the
line 189: " name does not exist. Throws "NERDTree.BookmarkedNodeNotFoundError" if a
line 190: " tree node for the named Bookmark could not be found.
line 191: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
line 195: 
line 196: " FUNCTION: Bookmark.GetSelected() {{{1
line 197: " returns the Bookmark the cursor is over, or {}
line 198: function! s:Bookmark.GetSelected()
line 210: 
line 211: " FUNCTION: Bookmark.InvalidBookmarks() {{{1
line 212: " Class method to get all invalid bookmark strings read from the bookmarks
line 213: " file
line 214: function! s:Bookmark.InvalidBookmarks()
line 220: 
line 221: " FUNCTION: Bookmark.mustExist() {{{1
line 222: function! s:Bookmark.mustExist()
line 229: 
line 230: " FUNCTION: Bookmark.New(name, path) {{{1
line 231: " Create a new bookmark object with the given name and path object
line 232: function! s:Bookmark.New(name, path)
line 242: 
line 243: " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
line 244: "Args:
line 245: "
line 246: "nerdtree: the tree to load open the bookmark in
line 247: "
line 248: "A dictionary containing the following keys (all optional):
line 249: "  'where': Specifies whether the node should be opened in new split/tab or in
line 250: "           the previous window. Can be either 'v' (vertical split), 'h'
line 251: "           (horizontal split), 't' (new tab) or 'p' (previous window).
line 252: "  'reuse': if a window is displaying the file then jump the cursor there
line 253: "  'keepopen': dont close the tree window
line 254: "  'stay': open the file, but keep the cursor in the tree win
line 255: "
line 256: function! s:Bookmark.open(nerdtree, ...)
line 270: 
line 271: " FUNCTION: Bookmark.openInNewTab(options) {{{1
line 272: " Create a new bookmark object with the given name and path object
line 273: function! s:Bookmark.openInNewTab(options)
line 277: 
line 278: " FUNCTION: Bookmark.setPath(path) {{{1
line 279: " makes this bookmark point to the given path
line 280: function! s:Bookmark.setPath(path)
line 283: 
line 284: " FUNCTION: Bookmark.SortBookmarksList() {{{1
line 285: " Class method that sorts the global list of bookmarks alphabetically by name.
line 286: " Note that case-sensitivity is determined by a user option.
line 287: function! s:Bookmark.SortBookmarksList()
line 290: 
line 291: " FUNCTION: Bookmark.str() {{{1
line 292: " Get the string that should be rendered in the view for this bookmark
line 293: function! s:Bookmark.str()
line 308: 
line 309: " FUNCTION: Bookmark.toRoot(nerdtree) {{{1
line 310: " Set the root of the given NERDTree to the node for this Bookmark. If a node
line 311: " for this Bookmark does not exist, a new one is initialized.
line 312: function! s:Bookmark.toRoot(nerdtree)
line 323: 
line 324: " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
line 325: " Class method that makes the Bookmark with the given name the root of
line 326: " specified NERDTree.
line 327: function! s:Bookmark.ToRoot(name, nerdtree)
line 331: 
line 332: " FUNCTION: Bookmark.validate() {{{1
line 333: function! s:Bookmark.validate()
line 342: 
line 343: " FUNCTION: Bookmark.Write() {{{1
line 344: " Class method to write all bookmarks to the bookmarks file
line 345: function! s:Bookmark.Write()
line 364: 
line 365: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim
continuing in function nerdtree#loadClassFiles
line 6:     runtime lib/nerdtree/tree_file_node.vim
Searching for "lib/nerdtree/tree_file_node.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 6: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeFileNode
line 3: "
line 4: " This class is the parent of the "TreeDirNode" class and is the "Component"
line 5: " part of the composite design pattern between the NERDTree node classes.
line 6: " ============================================================================
line 7: 
line 8: 
line 9: let s:TreeFileNode = {}
line 10: let g:NERDTreeFileNode = s:TreeFileNode
line 11: 
line 12: " FUNCTION: TreeFileNode.activate(...) {{{1
line 13: function! s:TreeFileNode.activate(...)
line 16: 
line 17: " FUNCTION: TreeFileNode.bookmark(name) {{{1
line 18: " bookmark this node with a:name
line 19: function! s:TreeFileNode.bookmark(name)
line 38: 
line 39: " FUNCTION: TreeFileNode.cacheParent() {{{1
line 40: " initializes self.parent if it isnt already
line 41: function! s:TreeFileNode.cacheParent()
line 50: 
line 51: " FUNCTION: TreeFileNode.clearBookmarks() {{{1
line 52: function! s:TreeFileNode.clearBookmarks()
line 60: 
line 61: " FUNCTION: TreeFileNode.copy(dest) {{{1
line 62: function! s:TreeFileNode.copy(dest)
line 73: 
line 74: " FUNCTION: TreeFileNode.delete {{{1
line 75: " Removes this node from the tree and calls the Delete method for its path obj
line 76: function! s:TreeFileNode.delete()
line 80: 
line 81: " FUNCTION: TreeFileNode.displayString() {{{1
line 82: "
line 83: " Returns a string that specifies how the node should be represented as a
line 84: " string
line 85: "
line 86: " Return:
line 87: " a string that can be used in the view to represent this node
line 88: function! s:TreeFileNode.displayString()
line 91: 
line 92: " FUNCTION: TreeFileNode.equals(treenode) {{{1
line 93: "
line 94: " Compares this treenode to the input treenode and returns 1 if they are the
line 95: " same node.
line 96: "
line 97: " Use this method instead of ==  because sometimes when the treenodes contain
line 98: " many children, vim seg faults when doing ==
line 99: "
line 100: " Args:
line 101: " treenode: the other treenode to compare to
line 102: function! s:TreeFileNode.equals(treenode)
line 105: 
line 106: " FUNCTION: TreeFileNode.findNode(path) {{{1
line 107: " Returns self if this node.path.Equals the given path.
line 108: " Returns {} if not equal.
line 109: "
line 110: " Args:
line 111: " path: the path object to compare against
line 112: function! s:TreeFileNode.findNode(path)
line 118: 
line 119: " FUNCTION: TreeFileNode.findSibling(direction) {{{1
line 120: " Find the next or previous sibling of this node.
line 121: "
line 122: " Args:
line 123: " direction: 0 for previous, 1 for next
line 124: "
line 125: " Return:
line 126: " The next/previous TreeFileNode object or an empty dictionary if not found.
line 127: function! s:TreeFileNode.findSibling(direction)
line 155: 
line 156: " FUNCTION: TreeFileNode.getNerdtree(){{{1
line 157: function! s:TreeFileNode.getNerdtree()
line 160: 
line 161: " FUNCTION: TreeFileNode.GetRootForTab(){{{1
line 162: " get the root node for this tab
line 163: function! s:TreeFileNode.GetRootForTab()
line 169: 
line 170: " FUNCTION: TreeFileNode.GetSelected() {{{1
line 171: " If the cursor is currently positioned on a tree node, return the node.
line 172: " Otherwise, return the empty dictionary.
line 173: function! s:TreeFileNode.GetSelected()
line 187: 
line 188: " FUNCTION: TreeFileNode.isVisible() {{{1
line 189: " returns 1 if this node should be visible according to the tree filters and
line 190: " hidden file filters (and their on/off status)
line 191: function! s:TreeFileNode.isVisible()
line 194: 
line 195: " FUNCTION: TreeFileNode.isRoot() {{{1
line 196: function! s:TreeFileNode.isRoot()
line 203: 
line 204: " FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
line 205: " Returns a new TreeNode object with the given path and parent
line 206: "
line 207: " Args:
line 208: " path: file/dir that the node represents
line 209: " nerdtree: the tree the node belongs to
line 210: function! s:TreeFileNode.New(path, nerdtree)
line 221: 
line 222: " FUNCTION: TreeFileNode.open() {{{1
line 223: function! s:TreeFileNode.open(...)
line 228: 
line 229: " FUNCTION: TreeFileNode.openSplit() {{{1
line 230: " Open this node in a new window
line 231: function! s:TreeFileNode.openSplit()
line 235: 
line 236: " FUNCTION: TreeFileNode.openVSplit() {{{1
line 237: " Open this node in a new vertical window
line 238: function! s:TreeFileNode.openVSplit()
line 242: 
line 243: " FUNCTION: TreeFileNode.openInNewTab(options) {{{1
line 244: function! s:TreeFileNode.openInNewTab(options)
line 248: 
line 249: " FUNCTION: TreeFileNode.openExplorer()
line 250: function! s:TreeFileNode.openExplorer()
line 254: 
line 255: " FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
line 256: " Places the cursor on the line number this node is rendered on
line 257: "
line 258: " Args:
line 259: " isJump: 1 if this cursor movement should be counted as a jump by vim
line 260: " recurseUpward: try to put the cursor on the parent if the this node isnt
line 261: " visible
line 262: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
line 281: 
line 282: " FUNCTION: TreeFileNode.refresh() {{{1
line 283: function! s:TreeFileNode.refresh()
line 286: 
line 287: " FUNCTION: TreeFileNode.refreshFlags() {{{1
line 288: function! s:TreeFileNode.refreshFlags()
line 291: 
line 292: " FUNCTION: TreeFileNode.rename() {{{1
line 293: " Calls the rename method for this nodes path obj
line 294: function! s:TreeFileNode.rename(newName)
line 307: 
line 308: " FUNCTION: TreeFileNode.renderToString {{{1
line 309: " returns a string representation for this tree to be rendered in the view
line 310: function! s:TreeFileNode.renderToString()
line 313: 
line 314: " Args:
line 315: " depth: the current depth in the tree for this call
line 316: " drawText: 1 if we should actually draw the line for this node (if 0 then the
line 317: " child nodes are rendered only)
line 318: " for each depth in the tree
line 319: function! s:TreeFileNode._renderToString(depth, drawText)
line 352: 
line 353: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim
continuing in function nerdtree#loadClassFiles
line 7:     runtime lib/nerdtree/tree_dir_node.vim
Searching for "lib/nerdtree/tree_dir_node.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 7: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeDirNode
line 3: "
line 4: " A subclass of NERDTreeFileNode.
line 5: "
line 6: " The 'composite' part of the file/dir composite.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:TreeDirNode = copy(g:NERDTreeFileNode)
line 11: let g:NERDTreeDirNode = s:TreeDirNode
line 12: 
line 13: " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
line 14: " Class method that returns the highest cached ancestor of the current root.
line 15: function! s:TreeDirNode.AbsoluteTreeRoot()
line 22: 
line 23: " FUNCTION: TreeDirNode.activate([options]) {{{1
line 24: function! s:TreeDirNode.activate(...)
line 38: 
line 39: " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
line 40: " Adds the given treenode to the list of children for this node
line 41: "
line 42: " Args:
line 43: " -treenode: the node to add
line 44: " -inOrder: 1 if the new node should be inserted in sorted order
line 45: function! s:TreeDirNode.addChild(treenode, inOrder)
line 53: 
line 54: " FUNCTION: TreeDirNode.close() {{{1
line 55: " Mark this TreeDirNode as closed.
line 56: function! s:TreeDirNode.close()
line 64: 
line 65: " FUNCTION: TreeDirNode.closeChildren() {{{1
line 66: " Recursively close any directory nodes that are descendants of this node.
line 67: function! s:TreeDirNode.closeChildren()
line 75: 
line 76: " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
line 77: " Instantiates a new child node for this node with the given path. The new
line 78: " nodes parent is set to this node.
line 79: "
line 80: " Args:
line 81: " path: a Path object that this node will represent/contain
line 82: " inOrder: 1 if the new node should be inserted in sorted order
line 83: "
line 84: " Returns:
line 85: " the newly created node
line 86: function! s:TreeDirNode.createChild(path, inOrder)
line 91: 
line 92: " FUNCTION: TreeDirNode.displayString() {{{1
line 93: " Assemble and return a string that can represent this TreeDirNode object in
line 94: " the NERDTree window.
line 95: function! s:TreeDirNode.displayString()
line 118: 
line 119: " FUNCTION: TreeDirNode.findNode(path) {{{1
line 120: " Will find one of the children (recursively) that has the given path
line 121: "
line 122: " Args:
line 123: " path: a path object
line 124: unlet s:TreeDirNode.findNode
line 125: function! s:TreeDirNode.findNode(path)
line 143: 
line 144: " FUNCTION: TreeDirNode.getCascade() {{{1
line 145: " Return an array of dir nodes (starting from self) that can be cascade opened.
line 146: function! s:TreeDirNode.getCascade()
line 156: 
line 157: " FUNCTION: TreeDirNode.getCascadeRoot() {{{1
line 158: " Return the first directory node in the cascade in which this directory node
line 159: " is rendered.
line 160: function! s:TreeDirNode.getCascadeRoot()
line 182: 
line 183: " FUNCTION: TreeDirNode.getChildCount() {{{1
line 184: " Returns the number of children this node has
line 185: function! s:TreeDirNode.getChildCount()
line 188: 
line 189: " FUNCTION: TreeDirNode.getChild(path) {{{1
line 190: " Returns child node of this node that has the given path or {} if no such node
line 191: " exists.
line 192: "
line 193: " This function doesnt not recurse into child dir nodes
line 194: "
line 195: " Args:
line 196: " path: a path object
line 197: function! s:TreeDirNode.getChild(path)
line 210: 
line 211: " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
line 212: " returns the child at the given index
line 213: "
line 214: " Args:
line 215: " indx: the index to get the child from
line 216: " visible: 1 if only the visible children array should be used, 0 if all the
line 217: " children should be searched.
line 218: function! s:TreeDirNode.getChildByIndex(indx, visible)
line 225: 
line 226: " FUNCTION: TreeDirNode.getChildIndex(path) {{{1
line 227: " Returns the index of the child node of this node that has the given path or
line 228: " -1 if no such node exists.
line 229: "
line 230: " This function doesnt not recurse into child dir nodes
line 231: "
line 232: " Args:
line 233: " path: a path object
line 234: function! s:TreeDirNode.getChildIndex(path)
line 256: 
line 257: " FUNCTION: TreeDirNode.getDirChildren() {{{1
line 258: " Return a list of all child nodes from "self.children" that are of type
line 259: " TreeDirNode. This function supports http://github.com/scrooloose/nerdtree-project-plugin.git.
line 260: function! s:TreeDirNode.getDirChildren()
line 263: 
line 264: " FUNCTION: TreeDirNode._glob(pattern, all) {{{1
line 265: " Return a list of strings naming the descendants of the directory in this
line 266: " TreeDirNode object that match the specified glob pattern.
line 267: "
line 268: " Args:
line 269: " pattern: (string) the glob pattern to apply
line 270: " all: (0 or 1) if 1, include "." and ".." if they match "pattern"; if 0,
line 271: "      always exclude them
line 272: "
line 273: " Note: If the pathnames in the result list are below the working directory,
line 274: " they are returned as pathnames relative to that directory. This is because
line 275: " this function, internally, attempts to obey 'wildignore' rules that use
line 276: " relative paths.
line 277: function! s:TreeDirNode._glob(pattern, all)
line 337: 
line 338: " FUNCTION: TreeDirNode.GetSelected() {{{1
line 339: " Returns the current node if it is a dir node, or else returns the current
line 340: " nodes parent
line 341: unlet s:TreeDirNode.GetSelected
line 342: function! s:TreeDirNode.GetSelected()
line 351: 
line 352: " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
line 353: " Returns the number of visible children this node has
line 354: function! s:TreeDirNode.getVisibleChildCount()
line 357: 
line 358: " FUNCTION: TreeDirNode.getVisibleChildren() {{{1
line 359: " Returns a list of children to display for this node, in the correct order
line 360: "
line 361: " Return:
line 362: " an array of treenodes
line 363: function! s:TreeDirNode.getVisibleChildren()
line 372: 
line 373: " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
line 374: " returns 1 if this node has any childre, 0 otherwise..
line 375: function! s:TreeDirNode.hasVisibleChildren()
line 378: 
line 379: " FUNCTION: TreeDirNode.isCascadable() {{{1
line 380: " true if this dir has only one visible child that is also a dir
line 381: " false if this dir is bookmarked or symlinked. Why? Two reasons:
line 382: "  1. If cascaded, we don't know which dir is bookmarked or is a symlink.
line 383: "  2. If the parent is a symlink or is bookmarked, you end up with unparsable
line 384: "     text, and NERDTree cannot get the path of any child node.
line 385: function! s:TreeDirNode.isCascadable()
line 403: 
line 404: " FUNCTION: TreeDirNode._initChildren() {{{1
line 405: " Removes all childen from this node and re-reads them
line 406: "
line 407: " Args:
line 408: " silent: 1 if the function should not echo any "please wait" messages for
line 409: " large directories
line 410: "
line 411: " Return: the number of child nodes read
line 412: function! s:TreeDirNode._initChildren(silent)
line 442: 
line 443: " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
line 444: " Return a new TreeDirNode object with the given path and parent.
line 445: "
line 446: " Args:
line 447: " path: dir that the node represents
line 448: " nerdtree: the tree the node belongs to
line 449: function! s:TreeDirNode.New(path, nerdtree)
line 465: 
line 466: " FUNCTION: TreeDirNode.open([options]) {{{1
line 467: " Open this directory node in the current tree or elsewhere if special options
line 468: " are provided. Return 0 if options were processed. Otherwise, return the
line 469: " number of new cached nodes.
line 470: function! s:TreeDirNode.open(...)
line 500: 
line 501: " FUNCTION: TreeDirNode.openAlong([opts]) {{{1
line 502: " recursive open the dir if it has only one directory child.
line 503: "
line 504: " return the level of opened directories.
line 505: function! s:TreeDirNode.openAlong(...)
line 521: 
line 522: " FUNCTION: TreeDirNode.openExplorer() {{{1
line 523: " Open an explorer window for this node in the previous window. The explorer
line 524: " can be a NERDTree window or a netrw window.
line 525: function! s:TreeDirNode.openExplorer()
line 529: 
line 530: " FUNCTION: TreeDirNode.openInNewTab(options) {{{1
line 531: unlet s:TreeDirNode.openInNewTab
line 532: function! s:TreeDirNode.openInNewTab(options)
line 536: 
line 537: " FUNCTION: TreeDirNode._openInNewTab() {{{1
line 538: function! s:TreeDirNode._openInNewTab()
line 542: 
line 543: " FUNCTION: TreeDirNode.openRecursively() {{{1
line 544: " Open this directory node and any descendant directory nodes whose pathnames
line 545: " are not ignored.
line 546: function! s:TreeDirNode.openRecursively()
line 555: 
line 556: " FUNCTION: TreeDirNode.refresh() {{{1
line 557: function! s:TreeDirNode.refresh()
line 594: 
line 595: " FUNCTION: TreeDirNode.refreshFlags() {{{1
line 596: unlet s:TreeDirNode.refreshFlags
line 597: function! s:TreeDirNode.refreshFlags()
line 603: 
line 604: " FUNCTION: TreeDirNode.refreshDirFlags() {{{1
line 605: function! s:TreeDirNode.refreshDirFlags()
line 608: 
line 609: " FUNCTION: TreeDirNode.reveal(path) {{{1
line 610: " reveal the given path, i.e. cache and open all treenodes needed to display it
line 611: " in the UI
line 612: " Returns the revealed node
line 613: function! s:TreeDirNode.reveal(path, ...)
line 643: 
line 644: " FUNCTION: TreeDirNode.removeChild(treenode) {{{1
line 645: " Remove the given treenode from "self.children".
line 646: " Throws "NERDTree.ChildNotFoundError" if the node is not found.
line 647: "
line 648: " Args:
line 649: " treenode: the node object to remove
line 650: function! s:TreeDirNode.removeChild(treenode)
line 660: 
line 661: " FUNCTION: TreeDirNode.sortChildren() {{{1
line 662: " Sort "self.children" by alphabetical order and directory priority.
line 663: function! s:TreeDirNode.sortChildren()
line 671: 
line 672: " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
line 673: " Opens this directory if it is closed and vice versa
line 674: function! s:TreeDirNode.toggleOpen(...)
line 686: 
line 687: " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
line 688: " Replaces the child of this with the given node (where the child node's full
line 689: " path matches a:newNode's fullpath). The search for the matching node is
line 690: " non-recursive
line 691: "
line 692: " Arg:
line 693: " newNode: the node to graft into the tree
line 694: function! s:TreeDirNode.transplantChild(newNode)
line 703: 
line 704: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim
continuing in function nerdtree#loadClassFiles
line 8:     runtime lib/nerdtree/opener.vim
Searching for "lib/nerdtree/opener.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/opener.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 8: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"
line 1: " ============================================================================
line 2: " CLASS: Opener
line 3: "
line 4: " The Opener class defines an API for "opening" operations.
line 5: " ============================================================================
line 6: 
line 7: 
line 8: let s:Opener = {}
line 9: let g:NERDTreeOpener = s:Opener
line 10: 
line 11: " FUNCTION: s:Opener._bufInWindows(bnum) {{{1
line 12: " [[STOLEN FROM VTREEEXPLORER.VIM]]
line 13: " Determine the number of windows open to this buffer number.
line 14: " Care of Yegappan Lakshman.  Thanks!
line 15: "
line 16: " Args:
line 17: " bnum: the subject buffers buffer number
line 18: function! s:Opener._bufInWindows(bnum)
line 34: 
line 35: " FUNCTION: Opener._checkToCloseTree(newtab) {{{1
line 36: " Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
line 37: " if the tree should be closed now.
line 38: "
line 39: " Args:
line 40: " a:newtab - boolean. If set, only close the tree now if we are opening the
line 41: " target in a new tab. This is needed because we have to close tree before we
line 42: " leave the tab
line 43: function! s:Opener._checkToCloseTree(newtab)
line 52: 
line 53: " FUNCTION: s:Opener._firstUsableWindow() {{{1
line 54: " find the window number of the first normal window
line 55: function! s:Opener._firstUsableWindow()
line 69: 
line 70: " FUNCTION: Opener._gotoTargetWin() {{{1
line 71: function! s:Opener._gotoTargetWin()
line 96: 
line 97: " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
line 98: " Returns 0 if opening a file from the tree in the given window requires it to
line 99: " be split, 1 otherwise
line 100: "
line 101: " Args:
line 102: " winnumber: the number of the window in question
line 103: function! s:Opener._isWindowUsable(winnumber)
line 127: 
line 128: " FUNCTION: Opener.New(path, opts) {{{1
line 129: " Instantiate a new NERDTreeOpener object.
line 130: " Args:
line 131: " a:path: the path object that is to be opened
line 132: " a:opts: a dictionary containing the following optional keys...
line 133: "   'where': specifies whether the node should be opened in new split, in
line 134: "            a new tab or, in the last window; takes values "v", "h", or "t"
line 135: "   'reuse': if file is already shown in a window, jump there; takes values
line 136: "            "all", "currenttab", or empty
line 137: "   'keepopen': boolean (0 or 1); if true, the tree window will not be closed
line 138: "   'stay': boolean (0 or 1); if true, remain in tree window after opening
line 139: function! s:Opener.New(path, opts)
line 153: 
line 154: " FUNCTION: Opener._newSplit() {{{1
line 155: function! s:Opener._newSplit()
line 213: 
line 214: " FUNCTION: Opener._newVSplit() {{{1
line 215: function! s:Opener._newVSplit()
line 233: 
line 234: " FUNCTION: Opener.open(target) {{{1
line 235: function! s:Opener.open(target)
line 243: 
line 244: " FUNCTION: Opener._openFile() {{{1
line 245: function! s:Opener._openFile()
line 264: 
line 265: " FUNCTION: Opener._openDirectory(node) {{{1
line 266: function! s:Opener._openDirectory(node)
line 285: 
line 286: " FUNCTION: Opener._previousWindow() {{{1
line 287: function! s:Opener._previousWindow()
line 305: 
line 306: " FUNCTION: Opener._restoreCursorPos() {{{1
line 307: function! s:Opener._restoreCursorPos()
line 311: 
line 312: " FUNCTION: Opener._reuseWindow() {{{1
line 313: " put the cursor in the first window we find for this file
line 314: "
line 315: " return 1 if we were successful
line 316: function! s:Opener._reuseWindow()
line 345: 
line 346: " FUNCTION: Opener._saveCursorPos() {{{1
line 347: function! s:Opener._saveCursorPos()
line 351: 
line 352: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/opener.vim
continuing in function nerdtree#loadClassFiles
line 9:     runtime lib/nerdtree/creator.vim
Searching for "lib/nerdtree/creator.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/creator.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 9: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"
line 1: " ============================================================================
line 2: " CLASS: Creator
line 3: "
line 4: " This class is responsible for creating NERDTree instances.  The new NERDTree
line 5: " may be a tab tree, a window tree, or a mirrored tree.  In the process of
line 6: " creating a NERDTree, it sets up all of the window and buffer options and key
line 7: " mappings etc.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Creator = {}
line 12: let g:NERDTreeCreator = s:Creator
line 13: 
line 14: " FUNCTION: s:Creator._bindMappings() {{{1
line 15: function! s:Creator._bindMappings()
line 28: 
line 29: " FUNCTION: s:Creator._broadcastInitEvent() {{{1
line 30: function! s:Creator._broadcastInitEvent()
line 33: 
line 34: " FUNCTION: s:Creator.BufNamePrefix() {{{1
line 35: function! s:Creator.BufNamePrefix()
line 38: 
line 39: " FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
line 40: function! s:Creator.CreateTabTree(name)
line 44: 
line 45: " FUNCTION: s:Creator.createTabTree(a:name) {{{1
line 46: " name: the name of a bookmark or a directory
line 47: function! s:Creator.createTabTree(name)
line 73: 
line 74: " FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
line 75: function! s:Creator.CreateWindowTree(dir)
line 79: 
line 80: " FUNCTION: s:Creator.createWindowTree(dir) {{{1
line 81: function! s:Creator.createWindowTree(dir)
line 106: 
line 107: " FUNCTION: s:Creator._createNERDTree(path) {{{1
line 108: function! s:Creator._createNERDTree(path, type)
line 118: 
line 119: " FUNCTION: s:Creator.CreateMirror() {{{1
line 120: function! s:Creator.CreateMirror()
line 124: 
line 125: " FUNCTION: s:Creator.createMirror() {{{1
line 126: function! s:Creator.createMirror()
line 177: 
line 178: " FUNCTION: s:Creator._createTreeWin() {{{1
line 179: " Initialize the NERDTree window.  Open the window, size it properly, set all
line 180: " local options, etc.
line 181: function! s:Creator._createTreeWin()
line 204: 
line 205: " FUNCTION: s:Creator._isBufHidden(nr) {{{1
line 206: function! s:Creator._isBufHidden(nr)
line 213: 
line 214: " FUNCTION: s:Creator.New() {{{1
line 215: function! s:Creator.New()
line 219: 
line 220: " FUNCTION: s:Creator._nextBufferName() {{{1
line 221: " returns the buffer name for the next nerd tree
line 222: function! s:Creator._nextBufferName()
line 226: 
line 227: " FUNCTION: s:Creator._nextBufferNumber() {{{1
line 228: " the number to add to the nerd tree buffer name to make the buf name unique
line 229: function! s:Creator._nextBufferNumber()
line 238: 
line 239: " FUNCTION: s:Creator._pathForString(str) {{{1
line 240: " find a bookmark or adirectory for the given string
line 241: function! s:Creator._pathForString(str)
line 267: 
line 268: " Function: s:Creator._removeTreeBufForTab()   {{{1
line 269: function! s:Creator._removeTreeBufForTab()
line 284: 
line 285: " FUNCTION: s:Creator._setCommonBufOptions() {{{1
line 286: function! s:Creator._setCommonBufOptions()
line 322: 
line 323: " FUNCTION: s:Creator._setupStatusline() {{{1
line 324: function! s:Creator._setupStatusline()
line 329: 
line 330: " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
line 331: function! s:Creator._tabpagevar(tabnr, var)
line 347: 
line 348: " FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
line 349: function! s:Creator.ToggleTabTree(dir)
line 353: 
line 354: " FUNCTION: s:Creator.toggleTabTree(dir) {{{1
line 355: " Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
line 356: " closed it is restored or initialized (if it doesnt exist)
line 357: "
line 358: " Args:
line 359: " dir: the full path for the root node (is only used if the NERD tree is being
line 360: " initialized.
line 361: function! s:Creator.toggleTabTree(dir)
line 376: 
line 377: " Function: s:Creator._uniq(list)   {{{1
line 378: " returns a:list without duplicates
line 379: function! s:Creator._uniq(list)
line 388: 
line 389: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/creator.vim
continuing in function nerdtree#loadClassFiles
line 10:     runtime lib/nerdtree/flag_set.vim
Searching for "lib/nerdtree/flag_set.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 10: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"
line 1: "CLASS: FlagSet
line 2: "============================================================
line 3: let s:FlagSet = {}
line 4: let g:NERDTreeFlagSet = s:FlagSet
line 5: 
line 6: "FUNCTION: FlagSet.addFlag(scope, flag) {{{1
line 7: function! s:FlagSet.addFlag(scope, flag)
line 13: 
line 14: "FUNCTION: FlagSet.clearFlags(scope) {{{1
line 15: function! s:FlagSet.clearFlags(scope)
line 18: 
line 19: "FUNCTION: FlagSet._flagsForScope(scope) {{{1
line 20: function! s:FlagSet._flagsForScope(scope)
line 26: 
line 27: "FUNCTION: FlagSet.New() {{{1
line 28: function! s:FlagSet.New()
line 33: 
line 34: "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
line 35: function! s:FlagSet.removeFlag(scope, flag)
line 43: 
line 44: "FUNCTION: FlagSet.renderToString() {{{1
line 45: function! s:FlagSet.renderToString()
line 57: 
line 58: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim
continuing in function nerdtree#loadClassFiles
line 11:     runtime lib/nerdtree/nerdtree.vim
Searching for "lib/nerdtree/nerdtree.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 11: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"
line 1: "CLASS: NERDTree
line 2: "============================================================
line 3: let s:NERDTree = {}
line 4: let g:NERDTree = s:NERDTree
line 5: 
line 6: "FUNCTION: s:NERDTree.AddPathFilter() {{{1
line 7: function! s:NERDTree.AddPathFilter(callback)
line 10: 
line 11: "FUNCTION: s:NERDTree.changeRoot(node) {{{1
line 12: function! s:NERDTree.changeRoot(node)
line 32: 
line 33: "FUNCTION: s:NERDTree.Close() {{{1
line 34: "Closes the tab tree window for this tab
line 35: function! s:NERDTree.Close()
line 65: 
line 66: "FUNCTION: s:NERDTree.CloseIfQuitOnOpen() {{{1
line 67: "Closes the NERD tree window if the close on open option is set
line 68: function! s:NERDTree.CloseIfQuitOnOpen()
line 73: 
line 74: "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
line 75: "Places the cursor at the top of the bookmarks table
line 76: function! s:NERDTree.CursorToBookmarkTable()
line 96: 
line 97: "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
line 98: "Places the cursor in the nerd tree window
line 99: function! s:NERDTree.CursorToTreeWin()
line 103: 
line 104: " Function: s:NERDTree.ExistsForBuffer()   {{{1
line 105: " Returns 1 if a nerd tree root exists in the current buffer
line 106: function! s:NERDTree.ExistsForBuf()
line 109: 
line 110: " Function: s:NERDTree.ExistsForTab()   {{{1
line 111: " Returns 1 if a nerd tree root exists in the current tab
line 112: function! s:NERDTree.ExistsForTab()
line 120: 
line 121: function! s:NERDTree.ForCurrentBuf()
line 128: 
line 129: "FUNCTION: s:NERDTree.ForCurrentTab() {{{1
line 130: function! s:NERDTree.ForCurrentTab()
line 138: 
line 139: "FUNCTION: s:NERDTree.getRoot() {{{1
line 140: function! s:NERDTree.getRoot()
line 143: 
line 144: "FUNCTION: s:NERDTree.GetWinNum() {{{1
line 145: "gets the nerd tree window number for this tab
line 146: function! s:NERDTree.GetWinNum()
line 153: 
line 154: "FUNCTION: s:NERDTree.IsOpen() {{{1
line 155: function! s:NERDTree.IsOpen()
line 158: 
line 159: "FUNCTION: s:NERDTree.isTabTree() {{{1
line 160: function! s:NERDTree.isTabTree()
line 163: 
line 164: "FUNCTION: s:NERDTree.isWinTree() {{{1
line 165: function! s:NERDTree.isWinTree()
line 168: 
line 169: "FUNCTION: s:NERDTree.MustBeOpen() {{{1
line 170: function! s:NERDTree.MustBeOpen()
line 175: 
line 176: "FUNCTION: s:NERDTree.New() {{{1
line 177: function! s:NERDTree.New(path, type)
line 184: 
line 185: "FUNCTION: s:NERDTree.PathFilters() {{{1
line 186: function! s:NERDTree.PathFilters()
line 192: 
line 193: "FUNCTION: s:NERDTree.previousBuf() {{{1
line 194: function! s:NERDTree.previousBuf()
line 197: 
line 198: function! s:NERDTree.setPreviousBuf(bnum)
line 201: 
line 202: "FUNCTION: s:NERDTree.render() {{{1
line 203: "A convenience function - since this is called often
line 204: function! s:NERDTree.render()
line 207: 
line 208: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim
continuing in function nerdtree#loadClassFiles
line 12:     runtime lib/nerdtree/ui.vim
Searching for "lib/nerdtree/ui.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/ui.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 12: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"
line 1: " ============================================================================
line 2: " CLASS: UI
line 3: " ============================================================================
line 4: 
line 5: 
line 6: let s:UI = {}
line 7: let g:NERDTreeUI = s:UI
line 8: 
line 9: " FUNCTION: s:UI.centerView() {{{1
line 10: " centers the nerd tree window around the cursor (provided the nerd tree
line 11: " options permit)
line 12: function! s:UI.centerView()
line 22: 
line 23: " FUNCTION: s:UI._dumpHelp  {{{1
line 24: " prints out the quick help
line 25: function! s:UI._dumpHelp()
line 135: 
line 136: 
line 137: " FUNCTION: s:UI.new(nerdtree) {{{1
line 138: function! s:UI.New(nerdtree)
line 149: 
line 150: " FUNCTION: s:UI.getPath(ln) {{{1
line 151: " Return the "Path" object for the node that is rendered on the given line
line 152: " number.  If the "up a dir" line is selected, return the "Path" object for
line 153: " the parent of the root.  Return the empty dictionary if the given line
line 154: " does not reference a tree node.
line 155: function! s:UI.getPath(ln)
line 203: 
line 204: " FUNCTION: s:UI.getLineNum(node) {{{1
line 205: " Return the line number where the given node is rendered.  Return -1 if the
line 206: " given node is not visible.
line 207: function! s:UI.getLineNum(node)
line 252: 
line 253: " FUNCTION: s:UI.getRootLineNum(){{{1
line 254: " gets the line number of the root node
line 255: function! s:UI.getRootLineNum()
line 262: 
line 263: " FUNCTION: s:UI.getShowBookmarks() {{{1
line 264: function! s:UI.getShowBookmarks()
line 267: 
line 268: " FUNCTION: s:UI.getShowFiles() {{{1
line 269: function! s:UI.getShowFiles()
line 272: 
line 273: " FUNCTION: s:UI.getShowHelp() {{{1
line 274: function! s:UI.getShowHelp()
line 277: 
line 278: " FUNCTION: s:UI.getShowHidden() {{{1
line 279: function! s:UI.getShowHidden()
line 282: 
line 283: " FUNCTION: s:UI._indentLevelFor(line) {{{1
line 284: function! s:UI._indentLevelFor(line)
line 291: 
line 292: " FUNCTION: s:UI.IndentWid() {{{1
line 293: function! s:UI.IndentWid()
line 296: 
line 297: " FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
line 298: function! s:UI.isIgnoreFilterEnabled()
line 301: 
line 302: " FUNCTION: s:UI.isMinimal() {{{1
line 303: function! s:UI.isMinimal()
line 306: 
line 307: " FUNCTION: s:UI.MarkupReg() {{{1
line 308: function! s:UI.MarkupReg()
line 311: 
line 312: " FUNCTION: s:UI._renderBookmarks {{{1
line 313: function! s:UI._renderBookmarks()
line 332: 
line 333: " FUNCTION: s:UI.restoreScreenState() {{{1
line 334: "
line 335: " Sets the screen state back to what it was when nerdtree#saveScreenState was last
line 336: " called.
line 337: "
line 338: " Assumes the cursor is in the NERDTree window
line 339: function! s:UI.restoreScreenState()
line 352: 
line 353: " FUNCTION: s:UI.saveScreenState() {{{1
line 354: " Saves the current cursor position in the current buffer and the window
line 355: " scroll position
line 356: function! s:UI.saveScreenState()
line 365: 
line 366: " FUNCTION: s:UI.setShowHidden(val) {{{1
line 367: function! s:UI.setShowHidden(val)
line 370: 
line 371: " FUNCTION: s:UI._stripMarkup(line){{{1
line 372: " find the filename in the given line, and return it.
line 373: "
line 374: " Args:
line 375: " line: the subject line
line 376: function! s:UI._stripMarkup(line)
line 380: 
line 381: " FUNCTION: s:UI.render() {{{1
line 382: function! s:UI.render()
line 433: 
line 434: 
line 435: " FUNCTION: UI.renderViewSavingPosition {{{1
line 436: " Renders the tree and ensures the cursor stays on the current node or the
line 437: " current nodes parent if it is no longer available upon re-rendering
line 438: function! s:UI.renderViewSavingPosition()
line 453: 
line 454: " FUNCTION: s:UI.toggleHelp() {{{1
line 455: function! s:UI.toggleHelp()
line 458: 
line 459: " FUNCTION: s:UI.toggleIgnoreFilter() {{{1
line 460: " toggles the use of the NERDTreeIgnore option
line 461: function! s:UI.toggleIgnoreFilter()
line 466: 
line 467: " FUNCTION: s:UI.toggleShowBookmarks() {{{1
line 468: " Toggle the visibility of the Bookmark table.
line 469: function! s:UI.toggleShowBookmarks()
line 487: 
line 488: " FUNCTION: s:UI.toggleShowFiles() {{{1
line 489: " toggles the display of hidden files
line 490: function! s:UI.toggleShowFiles()
line 495: 
line 496: " FUNCTION: s:UI.toggleShowHidden() {{{1
line 497: " toggles the display of hidden files
line 498: function! s:UI.toggleShowHidden()
line 503: 
line 504: " FUNCTION: s:UI.toggleZoom() {{{1
line 505: " zoom (maximize/minimize) the NERDTree window
line 506: function! s:UI.toggleZoom()
line 516: 
line 517: " FUNCTION: s:UI.UpDirLine() {{{1
line 518: function! s:UI.UpDirLine()
line 521: 
line 522: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/ui.vim
continuing in function nerdtree#loadClassFiles
line 13:     runtime lib/nerdtree/event.vim
Searching for "lib/nerdtree/event.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/event.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/event.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 13: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/event.vim"
line 1: "CLASS: Event
line 2: "============================================================
line 3: let s:Event = {}
line 4: let g:NERDTreeEvent = s:Event
line 5: 
line 6: function! s:Event.New(nerdtree, subject, action, params) abort
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/event.vim
continuing in function nerdtree#loadClassFiles
line 14:     runtime lib/nerdtree/notifier.vim
Searching for "lib/nerdtree/notifier.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/lib/nerdtree/notifier.vim"
Searching for "/home/w/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"
chdir(/home/w/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 14: sourcing "/home/w/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"
line 1: "CLASS: Notifier
line 2: "============================================================
line 3: let s:Notifier = {}
line 4: 
line 5: function! s:Notifier.AddListener(event, funcname)
line 13: 
line 14: function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
line 21: 
line 22: function! s:Notifier.GetListenersMap()
line 28: 
line 29: function! s:Notifier.GetListenersForEvent(name)
line 33: 
line 34: let g:NERDTreePathNotifier = deepcopy(s:Notifier)
finished sourcing /home/w/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim
continuing in function nerdtree#loadClassFiles
function nerdtree#loadClassFiles returning #0

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 164: 
line 165: " SECTION: Commands {{{1
line 166: "============================================================
line 167: call nerdtree#ui_glue#setupCommands()
Searching for "autoload/nerdtree/ui_glue.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/w/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"
chdir(/home/w/.vim/bundle/nerdtree/autoload/nerdtree)
fchdir() to previous dir
line 167: sourcing "/home/w/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"
line 1: if exists("g:loaded_nerdtree_ui_glue_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_ui_glue_autoload = 1
line 5: 
line 6: " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
line 7: function! nerdtree#ui_glue#createDefaultBindings()
line 79: 
line 80: 
line 81: "SECTION: Interface bindings {{{1
line 82: "============================================================
line 83: 
line 84: "FUNCTION: s:customOpenFile() {{{1
line 85: " Open file node with the "custom" key, initially <CR>.
line 86: function! s:customOpenFile(node)
line 89: 
line 90: "FUNCTION: s:customOpenDir() {{{1
line 91: " Open directory node with the "custom" key, initially <CR>.
line 92: function! s:customOpenDir(node)
line 95: 
line 96: "FUNCTION: s:customOpenBookmark() {{{1
line 97: " Open bookmark node with the "custom" key, initially <CR>.
line 98: function! s:customOpenBookmark(node)
line 105: 
line 106: "FUNCTION: s:initCustomOpenArgs() {{{1
line 107: " Make sure NERDTreeCustomOpenArgs has needed keys
line 108: function! s:initCustomOpenArgs()
line 112: 
line 113: "FUNCTION: s:activateAll() {{{1
line 114: "handle the user activating the updir line
line 115: function! s:activateAll()
line 120: 
line 121: " FUNCTION: s:activateDirNode(directoryNode, options) {{{1
line 122: " Open a directory with optional options
line 123: function! s:activateDirNode(directoryNode, ...)
line 132: 
line 133: "FUNCTION: s:activateFileNode() {{{1
line 134: "handle the user activating a tree node
line 135: function! s:activateFileNode(node)
line 138: 
line 139: "FUNCTION: s:activateBookmark(bookmark) {{{1
line 140: "handle the user activating a bookmark
line 141: function! s:activateBookmark(bm)
line 144: 
line 145: " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
line 146: " Associate the current node with the given name
line 147: function! nerdtree#ui_glue#bookmarkNode(...)
line 164: 
line 165: " FUNCTION: s:chCwd(node) {{{1
line 166: function! s:chCwd(node)
line 173: 
line 174: " FUNCTION: s:chRoot(node) {{{1
line 175: " changes the current root to the selected one
line 176: function! s:chRoot(node)
line 179: 
line 180: " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
line 181: " Change the NERDTree root to match the current working directory.
line 182: function! nerdtree#ui_glue#chRootCwd()
line 185: 
line 186: " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
line 187: function! nerdtree#ui_glue#clearBookmarks(bookmarks)
line 202: 
line 203: " FUNCTION: s:closeChildren(node) {{{1
line 204: " closes all childnodes of the current node
line 205: function! s:closeChildren(node)
line 210: 
line 211: " FUNCTION: s:closeCurrentDir(node) {{{1
line 212: " Close the parent directory of the current node.
line 213: function! s:closeCurrentDir(node)
line 235: 
line 236: " FUNCTION: s:closeTreeWindow() {{{1
line 237: " close the tree window
line 238: function! s:closeTreeWindow()
line 249: 
line 250: " FUNCTION: s:deleteBookmark(bookmark) {{{1
line 251: " Prompt the user to confirm the deletion of the selected bookmark.
line 252: function! s:deleteBookmark(bookmark)
line 275: 
line 276: " FUNCTION: s:displayHelp() {{{1
line 277: " toggles the help display
line 278: function! s:displayHelp()
line 283: 
line 284: " FUNCTION: s:findAndRevealPath(pathStr) {{{1
line 285: function! s:findAndRevealPath(pathStr)
line 330: 
line 331: "FUNCTION: s:handleLeftClick() {{{1
line 332: "Checks if the click should open the current node
line 333: function! s:handleLeftClick()
line 366: 
line 367: " FUNCTION: s:handleMiddleMouse() {{{1
line 368: function! s:handleMiddleMouse()
line 387: 
line 388: " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
line 389: "this is needed since I cant figure out how to invoke dict functions from a
line 390: "key map
line 391: function! nerdtree#ui_glue#invokeKeyMap(key)
line 394: 
line 395: " FUNCTION: s:jumpToFirstChild(node) {{{1
line 396: function! s:jumpToFirstChild(node)
line 399: 
line 400: " FUNCTION: s:jumpToLastChild(node) {{{1
line 401: function! s:jumpToLastChild(node)
line 404: 
line 405: " FUNCTION: s:jumpToChild(node, last) {{{1
line 406: " Jump to the first or last child node at the same file system level.
line 407: "
line 408: " Args:
line 409: " node: the node on which the cursor currently sits
line 410: " last: 1 (true) if jumping to last child, 0 (false) if jumping to first
line 411: function! s:jumpToChild(node, last)
line 426: 
line 427: " FUNCTION: s:jumpToParent(node) {{{1
line 428: " Move the cursor to the parent of the specified node.  For a cascade, move to
line 429: " the parent of the cascade's first node.  At the root node, do nothing.
line 430: function! s:jumpToParent(node)
line 445: 
line 446: " FUNCTION: s:jumpToRoot() {{{1
line 447: " moves the cursor to the root node
line 448: function! s:jumpToRoot()
line 452: 
line 453: " FUNCTION: s:jumpToNextSibling(node) {{{1
line 454: function! s:jumpToNextSibling(node)
line 457: 
line 458: " FUNCTION: s:jumpToPrevSibling(node) {{{1
line 459: function! s:jumpToPrevSibling(node)
line 462: 
line 463: " FUNCTION: s:jumpToSibling(node, forward) {{{1
line 464: " Move the cursor to the next or previous node at the same file system level.
line 465: "
line 466: " Args:
line 467: " node: the node on which the cursor currently sits
line 468: " forward: 0 to jump to previous sibling, 1 to jump to next sibling
line 469: function! s:jumpToSibling(node, forward)
line 480: 
line 481: " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
line 482: " Open the Bookmark that has the specified name. This function provides the
line 483: " implementation for the ":OpenBookmark" command.
line 484: function! nerdtree#ui_glue#openBookmark(name)
line 497: 
line 498: " FUNCTION: s:openHSplit(target) {{{1
line 499: function! s:openHSplit(target)
line 502: 
line 503: " FUNCTION: s:openVSplit(target) {{{1
line 504: function! s:openVSplit(target)
line 507: 
line 508: " FUNCTION: s:openExplorer(node) {{{1
line 509: function! s:openExplorer(node)
line 512: 
line 513: " FUNCTION: s:openInNewTab(target) {{{1
line 514: function! s:openInNewTab(target)
line 518: 
line 519: " FUNCTION: s:openInNewTabSilent(target) {{{1
line 520: function! s:openInNewTabSilent(target)
line 524: 
line 525: " FUNCTION: s:openNodeRecursively(node) {{{1
line 526: function! s:openNodeRecursively(node)
line 532: 
line 533: " FUNCTION: s:previewBookmark(bookmark) {{{1
line 534: function! s:previewBookmark(bookmark)
line 541: 
line 542: "FUNCTION: s:previewNodeCurrent(node) {{{1
line 543: function! s:previewNodeCurrent(node)
line 546: 
line 547: "FUNCTION: s:previewNodeHSplit(node) {{{1
line 548: function! s:previewNodeHSplit(node)
line 551: 
line 552: "FUNCTION: s:previewNodeVSplit(node) {{{1
line 553: function! s:previewNodeVSplit(node)
line 556: 
line 557: " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
line 558: " put the cursor on the node associate with the given name
line 559: function! nerdtree#ui_glue#revealBookmark(name)
line 567: 
line 568: " FUNCTION: s:refreshRoot() {{{1
line 569: " Reloads the current root. All nodes below this will be lost and the root dir
line 570: " will be reloaded.
line 571: function! s:refreshRoot()
line 585: 
line 586: " FUNCTION: s:refreshCurrent(node) {{{1
line 587: " refreshes the root for the current node
line 588: function! s:refreshCurrent(node)
line 599: 
line 600: " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
line 601: function! nerdtree#ui_glue#setupCommands()
line 612: 
line 613: " Function: s:SID()   {{{1
line 614: function s:SID()
line 620: 
line 621: " FUNCTION: s:showMenu(node) {{{1
line 622: function! s:showMenu(node)
line 626: 
line 627: " FUNCTION: s:toggleIgnoreFilter() {{{1
line 628: function! s:toggleIgnoreFilter()
line 631: 
line 632: " FUNCTION: s:toggleShowBookmarks() {{{1
line 633: function! s:toggleShowBookmarks()
line 636: 
line 637: " FUNCTION: s:toggleShowFiles() {{{1
line 638: function! s:toggleShowFiles()
line 641: 
line 642: " FUNCTION: s:toggleShowHidden() {{{1
line 643: " toggles the display of hidden files
line 644: function! s:toggleShowHidden()
line 647: 
line 648: " FUNCTION: s:toggleZoom() {{{1
line 649: function! s:toggleZoom()
line 652: 
line 653: " FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1
line 654: " Move the NERDTree up one level.
line 655: "
line 656: " Args:
line 657: " preserveState: if 1, the current root is left open when the new tree is
line 658: " rendered; if 0, the current root node is closed
line 659: function! nerdtree#ui_glue#upDir(preserveState)
line 681: 
line 682: " FUNCTION: s:upDirCurrentRootOpen() {{{1
line 683: function! s:upDirCurrentRootOpen()
line 686: 
line 687: " FUNCTION: s:upDirCurrentRootClosed() {{{1
line 688: function! s:upDirCurrentRootClosed()
line 691: 
line 692: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim
continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#ui_glue#setupCommands()

line 1:     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
line 2:     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
line 3:     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
line 4:     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
line 5:     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
line 6:     command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
line 7:     command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()
line 8:     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
line 9:     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
function nerdtree#ui_glue#setupCommands returning #0

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 168: 
line 169: " SECTION: Auto commands {{{1
line 170: "============================================================
line 171: augroup NERDTree
line 172:     "Save the cursor position whenever we close the nerd tree
line 173:     exec "autocmd BufLeave ". g:NERDTreeCreator.BufNamePrefix() ."* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif"
calling function 188()

line 1:     return 'NERD_tree_'
function 188 returning 'NERD_tree_'

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 173: autocmd BufLeave NERD_tree_* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif
line 174: 
line 175:     "disallow insert mode in the NERDTree
line 176:     exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
calling function 188()

line 1:     return 'NERD_tree_'
function 188 returning 'NERD_tree_'

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 176: autocmd BufEnter NERD_tree_* stopinsert
line 177: augroup END
line 178: 
line 179: if g:NERDTreeHijackNetrw
line 180:     augroup NERDTreeHijackNetrw
line 181:         autocmd VimEnter * silent! autocmd! FileExplorer
line 182:         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
line 183:     augroup END
line 184: endif
line 185: 
line 186: " SECTION: Public API {{{1
line 187: "============================================================
line 188: function! NERDTreeAddMenuItem(options)
line 191: 
line 192: function! NERDTreeAddMenuSeparator(...)
line 196: 
line 197: function! NERDTreeAddSubmenu(options)
line 200: 
line 201: function! NERDTreeAddKeyMap(options)
line 204: 
line 205: function! NERDTreeRender()
line 208: 
line 209: function! NERDTreeFocus()
line 216: 
line 217: function! NERDTreeCWD()
line 241: 
line 242: function! NERDTreeAddPathFilter(callback)
line 245: 
line 246: " SECTION: Post Source Actions {{{1
line 247: call nerdtree#postSourceActions()
calling function nerdtree#postSourceActions()

line 1:     call g:NERDTreeBookmark.CacheBookmarks(1)
calling function nerdtree#postSourceActions[1]..87(1)

line 1:     if filereadable(g:NERDTreeBookmarksFile)
line 2:         let g:NERDTreeBookmarks = []
line 3:         let g:NERDTreeInvalidBookmarks = []
line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
line 5:         let invalidBookmarksFound = 0
line 6:         for i in bookmarkStrings
line 7: 
line 8:             "ignore blank lines
line 9:             if i != ''
line 10: 
line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
line 13:                 let path = fnamemodify(path, ':p')
line 14: 
line 15:                 try
line 16:                     let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
line 17:                     call add(g:NERDTreeBookmarks, bookmark)
line 18:                 catch /^NERDTree.InvalidArgumentsError/
line 19:                     call add(g:NERDTreeInvalidBookmarks, i)
line 20:                     let invalidBookmarksFound += 1
line 21:                 endtry
line 22:             endif
line 23:         endfor
line 24:         if invalidBookmarksFound
line 25:             call s:Bookmark.Write()
line 26:             if !a:silent
line 27:                 call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
line 28:             endif
line 29:         endif
line 30:     endif
function nerdtree#postSourceActions[1]..87 returning #0

continuing in function nerdtree#postSourceActions

line 2:     call nerdtree#ui_glue#createDefaultBindings()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings()

line 1:     let s = '<SNR>' . s:SID() . '_'
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>28_SID()

line 1:     if !exists("s:sid")
line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
line 3:     endif
line 4:     return s:sid
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>28_SID returning '28'

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 2: 
line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>28_handleMiddleMouse'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>28_handleMiddleMouse'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79[4]..73('<MiddleMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...leMiddleMouse', 'key': '<MiddleMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>28_handleLeftClick'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>28_handleLeftClick'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79[4]..73('<LeftRelease>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ndleLeftClick', 'key': '<LeftRelease>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>28_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>28_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79[4]..73('<2-LeftMouse>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...tivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>28_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>28_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79[4]..73('<2-LeftMouse>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>28_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>28_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79[4]..73('<2-LeftMouse>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>28_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>28_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79[4]..73('<2-LeftMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...8_activateAll', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 9: 
line 10:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'FileNode', 'callback': s."customOpenFile"})
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'FileNode', 'callback': '<SNR>28_customOpenFile'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79({'key': '<CR>', 'scope': 'FileNode', 'callback': '<SNR>28_customOpenFile'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79[4]..73('<CR>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...<SNR>28_customOpenFile', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[10]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'DirNode', 'callback': s."customOpenDir"})
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'DirNode', 'callback': '<SNR>28_customOpenDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79({'key': '<CR>', 'scope': 'DirNode', 'callback': '<SNR>28_customOpenDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79[4]..73('<CR>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...'<SNR>28_customOpenDir', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'Bookmark', 'callback': s."customOpenBookmark"})
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'Bookmark', 'callback': '<SNR>28_customOpenBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79({'key': '<CR>', 'scope': 'Bookmark', 'callback': '<SNR>28_customOpenBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79[4]..73('<CR>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...>28_customOpenBookmark', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'all', 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap({'key': '<CR>', 'scope': 'all', 'callback': '<SNR>28_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79({'key': '<CR>', 'scope': 'all', 'callback': '<SNR>28_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79[4]..73('<CR>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...: '<SNR>28_activateAll', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 14: 
line 15:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>28_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>28_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79[4]..73('o', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun... '<SNR>28_activateDirNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[15]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>28_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>28_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79[4]..73('o', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...'<SNR>28_activateFileNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>28_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>28_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79[4]..73('o', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...'<SNR>28_activateBookmark', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 18:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Bookmark", 'callback': s."previewBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>28_previewBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>28_previewBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79[4]..73('go', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...'<SNR>28_previewBookmark', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[18]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'all', 'callback': '<SNR>28_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79({'key': 'o', 'scope': 'all', 'callback': '<SNR>28_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79[4]..73('o', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ck': '<SNR>28_activateAll', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 20: 
line 21:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap({'key': 'i', 'scope': 'Node', 'callback': '<SNR>28_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79({'key': 'i', 'scope': 'Node', 'callback': '<SNR>28_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79[4]..73('i', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ack': '<SNR>28_openHSplit', 'key': 'i'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 22:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap({'key': 's', 'scope': 'Node', 'callback': '<SNR>28_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79({'key': 's', 'scope': 'Node', 'callback': '<SNR>28_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79[4]..73('s', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ack': '<SNR>28_openVSplit', 'key': 's'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 23: 
line 24:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap({'key': 'go', 'scope': 'Node', 'callback': '<SNR>28_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79({'key': 'go', 'scope': 'Node', 'callback': '<SNR>28_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79[4]..73('go', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...NR>28_previewNodeCurrent', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 25:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>28_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>28_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79[4]..73('gs', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...SNR>28_previewNodeVSplit', 'key': 'gs'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>28_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>28_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79[4]..73('gi', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...SNR>28_previewNodeHSplit', 'key': 'gi'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 27: 
line 28:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>28_openNodeRecursively'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>28_openNodeRecursively'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79[4]..73('O', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...NR>28_openNodeRecursively', 'key': 'O'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 29: 
line 30:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap({'key': 'u', 'scope': 'all', 'callback': '<SNR>28_upDirCurrentRootClosed'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79({'key': 'u', 'scope': 'all', 'callback': '<SNR>28_upDirCurrentRootClosed'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79[4]..73('u', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...28_upDirCurrentRootClosed', 'key': 'u'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 31:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap({'key': 'U', 'scope': 'all', 'callback': '<SNR>28_upDirCurrentRootOpen'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79({'key': 'U', 'scope': 'all', 'callback': '<SNR>28_upDirCurrentRootOpen'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79[4]..73('U', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...R>28_upDirCurrentRootOpen', 'key': 'U'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 32:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap({'key': 'C', 'scope': 'Node', 'callback': '<SNR>28_chRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79({'key': 'C', 'scope': 'Node', 'callback': '<SNR>28_chRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79[4]..73('C', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...allback': '<SNR>28_chRoot', 'key': 'C'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 33: 
line 34:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>28_chCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>28_chCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79[4]..73('cd', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...allback': '<SNR>28_chCwd', 'key': 'cd'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 35: 
line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap({'key': 'q', 'scope': 'all', 'callback': '<SNR>28_closeTreeWindow'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79({'key': 'q', 'scope': 'all', 'callback': '<SNR>28_closeTreeWindow'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79[4]..73('q', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun... '<SNR>28_closeTreeWindow', 'key': 'q'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 37: 
line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#ui_glue#chRootCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79[4]..73('CD', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...rdtree#ui_glue#chRootCwd', 'key': 'CD'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 39: 
line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap({'key': 'R', 'scope': 'all', 'callback': '<SNR>28_refreshRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79({'key': 'R', 'scope': 'all', 'callback': '<SNR>28_refreshRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79[4]..73('R', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ck': '<SNR>28_refreshRoot', 'key': 'R'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 41:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap({'key': 'r', 'scope': 'Node', 'callback': '<SNR>28_refreshCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79({'key': 'r', 'scope': 'Node', 'callback': '<SNR>28_refreshCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79[4]..73('r', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...: '<SNR>28_refreshCurrent', 'key': 'r'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 42: 
line 43:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap({'key': '?', 'scope': 'all', 'callback': '<SNR>28_displayHelp'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79({'key': '?', 'scope': 'all', 'callback': '<SNR>28_displayHelp'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79[4]..73('?', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ck': '<SNR>28_displayHelp', 'key': '?'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 44:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap({'key': 'A', 'scope': 'all', 'callback': '<SNR>28_toggleZoom'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79({'key': 'A', 'scope': 'all', 'callback': '<SNR>28_toggleZoom'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79[4]..73('A', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ack': '<SNR>28_toggleZoom', 'key': 'A'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[44]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap({'key': 'I', 'scope': 'all', 'callback': '<SNR>28_toggleShowHidden'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79({'key': 'I', 'scope': 'all', 'callback': '<SNR>28_toggleShowHidden'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79[4]..73('I', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...'<SNR>28_toggleShowHidden', 'key': 'I'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 46:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap({'key': 'f', 'scope': 'all', 'callback': '<SNR>28_toggleIgnoreFilter'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79({'key': 'f', 'scope': 'all', 'callback': '<SNR>28_toggleIgnoreFilter'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79[4]..73('f', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...SNR>28_toggleIgnoreFilter', 'key': 'f'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 47:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap({'key': 'F', 'scope': 'all', 'callback': '<SNR>28_toggleShowFiles'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79({'key': 'F', 'scope': 'all', 'callback': '<SNR>28_toggleShowFiles'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79[4]..73('F', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun... '<SNR>28_toggleShowFiles', 'key': 'F'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap({'key': 'B', 'scope': 'all', 'callback': '<SNR>28_toggleShowBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79({'key': 'B', 'scope': 'all', 'callback': '<SNR>28_toggleShowBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79[4]..73('B', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...NR>28_toggleShowBookmarks', 'key': 'B'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 49: 
line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap({'key': 'x', 'scope': 'Node', 'callback': '<SNR>28_closeCurrentDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79({'key': 'x', 'scope': 'Node', 'callback': '<SNR>28_closeCurrentDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79[4]..73('x', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun... '<SNR>28_closeCurrentDir', 'key': 'x'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 51:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>28_closeChildren'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>28_closeChildren'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79[4]..73('X', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...': '<SNR>28_closeChildren', 'key': 'X'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 52: 
line 53:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap({'key': 'm', 'scope': 'Node', 'callback': '<SNR>28_showMenu'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79({'key': 'm', 'scope': 'Node', 'callback': '<SNR>28_showMenu'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79[4]..73('m', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...lback': '<SNR>28_showMenu', 'key': 'm'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 54: 
line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap({'key': 'p', 'scope': 'Node', 'callback': '<SNR>28_jumpToParent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79({'key': 'p', 'scope': 'Node', 'callback': '<SNR>28_jumpToParent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79[4]..73('p', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...k': '<SNR>28_jumpToParent', 'key': 'p'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 56:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap({'key': 'K', 'scope': 'Node', 'callback': '<SNR>28_jumpToFirstChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79({'key': 'K', 'scope': 'Node', 'callback': '<SNR>28_jumpToFirstChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79[4]..73('K', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...'<SNR>28_jumpToFirstChild', 'key': 'K'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[56]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 57:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap({'key': 'J', 'scope': 'Node', 'callback': '<SNR>28_jumpToLastChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79({'key': 'J', 'scope': 'Node', 'callback': '<SNR>28_jumpToLastChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79[4]..73('J', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun... '<SNR>28_jumpToLastChild', 'key': 'J'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 58:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap({'key': 'P', 'scope': 'all', 'callback': '<SNR>28_jumpToRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79({'key': 'P', 'scope': 'all', 'callback': '<SNR>28_jumpToRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79[4]..73('P', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...ack': '<SNR>28_jumpToRoot', 'key': 'P'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 59:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>28_jumpToNextSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>28_jumpToNextSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79[4]..73('<C-j>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...>28_jumpToNextSibling', 'key': '<C-j>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>28_jumpToPrevSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>28_jumpToPrevSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79[4]..73('<C-k>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...>28_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 61: 
line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Node', 'callback': '<SNR>28_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79({'key': 't', 'scope': 'Node', 'callback': '<SNR>28_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79[4]..73('t', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...k': '<SNR>28_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 63:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Node', 'callback': '<SNR>28_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79({'key': 'T', 'scope': 'Node', 'callback': '<SNR>28_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79[4]..73('T', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...SNR>28_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[63]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>28_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>28_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79[4]..73('t', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...k': '<SNR>28_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 65:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>28_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>28_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79[4]..73('T', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...SNR>28_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 66: 
line 67:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>28_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>28_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79[4]..73('e', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...k': '<SNR>28_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 68:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "FileNode", 'callback': s."openExplorer" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap({'key': 'e', 'scope': 'FileNode', 'callback': '<SNR>28_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79({'key': 'e', 'scope': 'FileNode', 'callback': '<SNR>28_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79[4]..73('e', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...k': '<SNR>28_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[68]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 69: 
line 70:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>28_deleteBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>28_deleteBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79[4]..73('D', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79[4]..73 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79[14]..80({'All': function('71'), 'BindAll': fun...: '<SNR>28_deleteBookmark', 'key': 'D'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79[14]..80 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap[1]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[70]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings returning #0

continuing in function nerdtree#postSourceActions

line 3: 
line 4:     "load all nerdtree plugins
line 5:     runtime! nerdtree_plugin/**/*.vim
Searching for "nerdtree_plugin/**/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/nerdtree_plugin/**/*.vim"
chdir(/home/w/.vim/bundle/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/w/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim"
line 1: " ============================================================================
line 2: " File:        exec_menuitem.vim
line 3: " Description: plugin for NERD Tree that provides an execute file menu item
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_exec_menuitem")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_exec_menuitem = 1
line 16: 
line 21: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning []

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...reeExecFile', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim

line 22: 
line 23: function! NERDTreeExecFileActive()
line 27: 
line 28: function! NERDTreeExecFile()
finished sourcing /home/w/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
continuing in function nerdtree#postSourceActions
chdir(/home/w/.vim/bundle/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim"
line 1: " ============================================================================
line 2: " File:        fs_menu.vim
line 3: " Description: plugin for the NERD Tree that provides a file system menu
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_fs_menu")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_fs_menu = 1
line 16: 
line 17: "Automatically delete the buffer after deleting or renaming a file
line 18: if !exists("g:NERDTreeAutoDeleteBuffer")
line 19:     let g:NERDTreeAutoDeleteBuffer = 0
line 20: endif
line 21: 
line 22: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...eeExecFile', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...TreeAddNode', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 23: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...reeAddNode', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...reeMoveNode', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 24: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...eeMoveNode', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...eDeleteNode', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 25: 
line 26: if has("gui_mac") || has("gui_macvim") || has("mac")
line 27:     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
line 28:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
line 29:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
line 30: endif
line 31: 
line 32: if executable("xdg-open")
line 33:     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...DeleteNode', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...alFileLinux', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 34:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...lFileLinux', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...teFileLinux', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 35: endif
line 36: 
line 37: if g:NERDTreePath.CopyingSupported()
calling function 9()

line 1:     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
function 9 returning #1

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 38:     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...eFileLinux', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...reeCopyNode', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 39: endif
line 40: call NERDTreeAddMenuItem({'text': (has("clipboard")?'copy (p)ath to clipboard':'print (p)ath to screen'), 'shortcut': 'p', 'callback': 'NERDTreeCopyPath'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeCopyPath', 'shor... 'p', 'text': 'print (p)ath to screen'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeCopyPath', 'shor... 'p', 'text': 'print (p)ath to screen'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...eeCopyNode', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...reeCopyPath', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 41: 
line 42: if has("unix") || has("osx")
line 43:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..64({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..64[20]..62()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..64[20]..62 returning [{'All': function('62'), 'isActiveCall...eeCopyPath', 'Create': function('64')}]

continuing in function NERDTreeAddMenuItem[1]..64

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..64 returning {'All': function('62'), 'isActiveCallb...reeListNode', 'Create': function('64')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 44: else
line 45:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
line 46: endif
line 47: 
line 48: "FUNCTION: s:inputPrompt(action){{{1
line 49: "returns the string that should be prompted to the user for the given action
line 50: "
line 51: "Args:
line 52: "action: the action that is being performed, e.g. 'delete'
line 53: function! s:inputPrompt(action)
line 88: 
line 89: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
line 90: "prints out the given msg and, if the user responds by pushing 'y' then the
line 91: "buffer with the given bufnum is deleted
line 92: "
line 93: "Args:
line 94: "bufnum: the buffer that may be deleted
line 95: "msg: a message that will be echoed to the user asking them if they wish to
line 96: "     del the buffer
line 97: function! s:promptToDelBuffer(bufnum, msg)
line 127: 
line 128: "FUNCTION: s:renameBuffer(bufNum, newNodeName, isDirectory){{{1
line 129: "The buffer with the given bufNum is replaced with a new one
line 130: "
line 131: "Args:
line 132: "bufNum: the buffer that may be deleted
line 133: "newNodeName: the name given to the renamed node
line 134: "isDirectory: determines how to do the create the new filenames
line 135: function! s:renameBuffer(bufNum, newNodeName, isDirectory)
line 159: 
line 160: "FUNCTION: NERDTreeAddNode(){{{1
line 161: function! NERDTreeAddNode()
line 193: 
line 194: "FUNCTION: NERDTreeMoveNode(){{{1
line 195: function! NERDTreeMoveNode()
line 242: 
line 243: " FUNCTION: NERDTreeDeleteNode() {{{1
line 244: function! NERDTreeDeleteNode()
line 284: 
line 285: " FUNCTION: NERDTreeListNode() {{{1
line 286: function! NERDTreeListNode()
line 306: 
line 307: " FUNCTION: NERDTreeListNodeWin32() {{{1
line 308: function! NERDTreeListNodeWin32()
line 324: 
line 325: " FUNCTION: NERDTreeCopyNode() {{{1
line 326: function! NERDTreeCopyNode()
line 367: 
line 368: " FUNCTION: NERDTreeCopyPath() {{{1
line 369: function! NERDTreeCopyPath()
line 378: 
line 379: " FUNCTION: NERDTreeQuickLook() {{{1
line 380: function! NERDTreeQuickLook()
line 386: 
line 387: " FUNCTION: NERDTreeRevealInFinder() {{{1
line 388: function! NERDTreeRevealInFinder()
line 394: 
line 395: " FUNCTION: NERDTreeExecuteFile() {{{1
line 396: function! NERDTreeExecuteFile()
line 402: 
line 403: " FUNCTION: NERDTreeRevealFileLinux() {{{1
line 404: function! NERDTreeRevealFileLinux()
line 411: 
line 412: " FUNCTION: NERDTreeExecuteFileLinux() {{{1
line 413: function! NERDTreeExecuteFileLinux()
line 419: 
line 420: " vim: set sw=4 sts=4 et fdm=marker:
line 421: 
finished sourcing /home/w/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
continuing in function nerdtree#postSourceActions
chdir(/home/w/.vim/bundle/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/w/.vim/bundle/nerdtree/nerdtree_plugin/vcs.vim"
line 1: " ============================================================================
line 2: " File:        vcs.vim
line 3: " Description: NERDTree plugin that provides a command to open on the root of
line 4: "              a version control system repository.
line 5: " Maintainer:  Phil Runninger
line 6: " License:     This program is free software. It comes without any warranty,
line 7: "              to the extent permitted by applicable law. You can redistribute
line 8: "              it and/or modify it under the terms of the Do What The Fuck You
line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 11: "
line 12: " ============================================================================
line 13: command! -n=? -complete=dir -bar NERDTreeVCS :call <SID>CreateTabTreeVCS('<args>')
line 14: 
line 15: " FUNCTION: s:CreateTabTreeVCS(a:name) {{{1
line 16: function! s:CreateTabTreeVCS(name)
line 21: 
line 22: " FUNCTION: s:FindParentVCSRoot(a:path) {{{1
line 23: " Finds the root version control system folder of the given path. If a:path is
line 24: " not part of a repository, return the original path.
line 25: function! s:FindParentVCSRoot(path)
line 38: 
finished sourcing /home/w/.vim/bundle/nerdtree/nerdtree_plugin/vcs.vim
continuing in function nerdtree#postSourceActions
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/**/*.vim"
chdir(/home/w/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/w/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim"
line 1: " === plugin configuration variables === {{{
line 2: "
line 3: " Open NERDTree on gvim/macvim startup. When set to `2`,
line 4: " open only if directory was given as startup argument.
line 5: if !exists('g:nerdtree_tabs_open_on_gui_startup')
line 6:   let g:nerdtree_tabs_open_on_gui_startup = 1
line 7: endif
line 8: 
line 9: " Open NERDTree on console vim startup (off by default). When set to `2`,
line 10: " open only if directory was given as startup argument.
line 11: if !exists('g:nerdtree_tabs_open_on_console_startup')
line 12:   let g:nerdtree_tabs_open_on_console_startup = 0
line 13: endif
line 14: 
line 15: " do not open NERDTree if vim starts in diff mode
line 16: if !exists('g:nerdtree_tabs_no_startup_for_diff')
line 17:     let g:nerdtree_tabs_no_startup_for_diff = 1
line 18: endif
line 19: 
line 20: " On startup - focus NERDTree when opening a directory, focus the file if
line 21: " editing a specified file. When set to `2`, always focus file after startup.
line 22: if !exists('g:nerdtree_tabs_smart_startup_focus')
line 23:   let g:nerdtree_tabs_smart_startup_focus = 1
line 24: endif
line 25: 
line 26: " Open NERDTree on new tab creation if NERDTree was globally opened
line 27: " by :NERDTreeTabsToggle
line 28: if !exists('g:nerdtree_tabs_open_on_new_tab')
line 29:   let g:nerdtree_tabs_open_on_new_tab = 1
line 30: endif
line 31: 
line 32: " unfocus NERDTree when leaving a tab so that you have descriptive tab names
line 33: " and not names like 'NERD_tree_1'
line 34: if !exists('g:nerdtree_tabs_meaningful_tab_names')
line 35:   let g:nerdtree_tabs_meaningful_tab_names = 1
line 36: endif
line 37: 
line 38: " close current tab if there is only one window in it and it's NERDTree
line 39: if !exists('g:nerdtree_tabs_autoclose')
line 40:   let g:nerdtree_tabs_autoclose = 1
line 41: endif
line 42: 
line 43: " synchronize view of all NERDTree windows (scroll and cursor position)
line 44: if !exists('g:nerdtree_tabs_synchronize_view')
line 45:   let g:nerdtree_tabs_synchronize_view = 1
line 46: endif
line 47: 
line 48: " synchronize focus when switching tabs (focus NERDTree after tab switch
line 49: " if and only if it was focused before tab switch)
line 50: if !exists('g:nerdtree_tabs_synchronize_focus')
line 51:   let g:nerdtree_tabs_synchronize_focus = 1
line 52: endif
line 53: 
line 54: " when switching into a tab, make sure that focus will always be in file
line 55: " editing window, not in NERDTree window (off by default)
line 56: if !exists('g:nerdtree_tabs_focus_on_files')
line 57:   let g:nerdtree_tabs_focus_on_files = 0
line 58: endif
line 59: 
line 60: " when starting up with a directory name as a parameter, cd into it
line 61: if !exists('g:nerdtree_tabs_startup_cd')
line 62:   let g:nerdtree_tabs_startup_cd = 1
line 63: endif
line 64: 
line 65: " automatically find and select currently opened file
line 66: if !exists('g:nerdtree_tabs_autofind')
line 67:   let g:nerdtree_tabs_autofind = 0
line 68: endif
line 69: "
line 70: " }}}
line 71: " === plugin mappings === {{{
line 72: "
line 73: noremap <silent> <script> <Plug>NERDTreeTabsOpen     :call <SID>NERDTreeOpenAllTabs()
line 74: noremap <silent> <script> <Plug>NERDTreeTabsClose    :call <SID>NERDTreeCloseAllTabs()
line 75: noremap <silent> <script> <Plug>NERDTreeTabsToggle   :call <SID>NERDTreeToggleAllTabs()
line 76: noremap <silent> <script> <Plug>NERDTreeTabsFind     :call <SID>NERDTreeFindFile()
line 77: noremap <silent> <script> <Plug>NERDTreeMirrorOpen   :call <SID>NERDTreeMirrorOrCreate()
line 78: noremap <silent> <script> <Plug>NERDTreeMirrorToggle :call <SID>NERDTreeMirrorToggle()
line 79: noremap <silent> <script> <Plug>NERDTreeSteppedOpen  :call <SID>NERDTreeSteppedOpen()
line 80: noremap <silent> <script> <Plug>NERDTreeSteppedClose :call <SID>NERDTreeSteppedClose()
line 81: noremap <silent> <script> <Plug>NERDTreeFocusToggle  :call <SID>NERDTreeFocusToggle()
line 82: "
line 83: " }}}
line 84: " === plugin commands === {{{
line 85: "
line 86: command! NERDTreeTabsOpen     call <SID>NERDTreeOpenAllTabs()
line 87: command! NERDTreeTabsClose    call <SID>NERDTreeCloseAllTabs()
line 88: command! NERDTreeTabsToggle   call <SID>NERDTreeToggleAllTabs()
line 89: command! NERDTreeTabsFind     call <SID>NERDTreeFindFile()
line 90: command! NERDTreeMirrorOpen   call <SID>NERDTreeMirrorOrCreate()
line 91: command! NERDTreeMirrorToggle call <SID>NERDTreeMirrorToggle()
line 92: command! NERDTreeSteppedOpen  call <SID>NERDTreeSteppedOpen()
line 93: command! NERDTreeSteppedClose call <SID>NERDTreeSteppedClose()
line 94: command! NERDTreeFocusToggle  call <SID>NERDTreeFocusToggle()
line 95: "
line 96: " }}}
line 97: " === plugin functions === {{{
line 98: "
line 99: " === NERDTree manipulation (opening, closing etc.) === {{{
line 100: "
line 101: " s:NERDTreeMirrorOrCreate() {{{
line 102: "
line 103: " switch NERDTree on for current tab -- mirror it if possible, otherwise create it
line 104: fun! s:NERDTreeMirrorOrCreate()
line 120: 
line 121: " }}}
line 122: " s:NERDTreeMirrorToggle() {{{
line 123: "
line 124: " toggle NERDTree in current tab, use mirror if possible
line 125: fun! s:NERDTreeMirrorToggle()
line 134: 
line 135: " }}}
line 136: " s:NERDTreeOpenAllTabs() {{{
line 137: "
line 138: " switch NERDTree on for all tabs while making sure there is only one NERDTree buffer
line 139: fun! s:NERDTreeOpenAllTabs()
line 151: 
line 152: " }}}
line 153: " s:NERDTreeCloseAllTabs() {{{
line 154: "
line 155: " close NERDTree across all tabs
line 156: fun! s:NERDTreeCloseAllTabs()
line 164: 
line 165: " }}}
line 166: " s:NERDTreeToggleAllTabs() {{{
line 167: "
line 168: " toggle NERDTree in current tab and match the state in all other tabs
line 169: fun! s:NERDTreeToggleAllTabs()
line 185: 
line 186: " }}}
line 187: " s:NERDTreeSteppedOpen() {{{
line 188: "
line 189: " focus the NERDTree view, creating one first if none is present
line 190: fun! s:NERDTreeSteppedOpen()
line 199: 
line 200: " }}}
line 201: " s:NERDTreeSteppedClose{() {{{
line 202: "
line 203: " unfocus the NERDTree view or closes it if it hadn't had focus at the time of
line 204: " the call
line 205: fun! s:NERDTreeSteppedClose()
line 216: 
line 217: " }}}
line 218: " s:NERDTreeFocusToggle() {{{
line 219: "
line 220: " focus the NERDTree view or creates it if in a file,
line 221: " or unfocus NERDTree view if in NERDTree
line 222: fun! s:NERDTreeFocusToggle()
line 234: " }}}
line 235: "
line 236: " === NERDTree manipulation (opening, closing etc.) === }}}
line 237: " === focus functions === {{{
line 238: "
line 239: " s:NERDTreeFocus() {{{
line 240: "
line 241: " if the current window is NERDTree, move focus to the next window
line 242: fun! s:NERDTreeFocus()
line 247: 
line 248: " }}}
line 249: " s:NERDTreeUnfocus() {{{
line 250: "
line 251: " if the current window is NERDTree, move focus to the next window
line 252: fun! s:NERDTreeUnfocus()
line 265: 
line 266: " }}}
line 267: " s:NERDTreeRestoreFocus() {{{
line 268: "
line 269: " restore focus to the window that was focused before leaving current tab
line 270: fun! s:NERDTreeRestoreFocus()
line 281: 
line 282: " }}}
line 283: " s:SaveGlobalFocus() {{{
line 284: "
line 285: fun! s:SaveGlobalFocus()
line 288: 
line 289: " }}}
line 290: " s:IfFocusOnStartup() {{{
line 291: "
line 292: fun! s:IfFocusOnStartup()
line 295: 
line 296: " }}}
line 297: "
line 298: " === focus functions === }}}
line 299: " === utility functions === {{{
line 300: "
line 301: " s:NextNormalWindow() {{{
line 302: "
line 303: " find next window with a normal buffer
line 304: fun! s:NextNormalWindow()
line 331: 
line 332: " }}}
line 333: " s:CloseIfOnlyNerdTreeLeft() {{{
line 334: "
line 335: " Close all open buffers on entering a window if the only
line 336: " buffer that's left is the NERDTree buffer
line 337: fun! s:CloseIfOnlyNerdTreeLeft()
line 342: 
line 343: " }}}
line 344: " s:IsCurrentWindowNERDTree() {{{
line 345: "
line 346: " returns 1 if current window is NERDTree, false otherwise
line 347: fun! s:IsCurrentWindowNERDTree()
line 350: 
line 351: " }}}
line 352: " s:IsNERDTreeOpenInCurrentTab() {{{
line 353: "
line 354: " check if NERDTree is open in current tab
line 355: fun! s:IsNERDTreeOpenInCurrentTab()
line 358: 
line 359: " }}}
line 360: " s:IsNERDTreePresentInCurrentTab() {{{
line 361: "
line 362: " check if NERDTree is present in current tab (not necessarily visible)
line 363: fun! s:IsNERDTreePresentInCurrentTab()
line 366: 
line 367: " }}}
line 368: "
line 369: " === utility functions === }}}
line 370: " === NERDTree view manipulation (scroll and cursor positions) === {{{
line 371: "
line 372: " s:SaveNERDTreeViewIfPossible() {{{
line 373: "
line 374: fun! s:SaveNERDTreeViewIfPossible()
line 387: 
line 388: " }}}
line 389: " s:RestoreNERDTreeViewIfPossible() {{{
line 390: "
line 391: fun! s:RestoreNERDTreeViewIfPossible()
line 414: 
line 415: " }}}
line 416: " s:NERDTreeFindFile() {{{
line 417: "
line 418: fun! s:NERDTreeFindFile()
line 423: 
line 424: " }}}
line 425: "
line 426: " === NERDTree view manipulation (scroll and cursor positions) === }}}
line 427: "
line 428: " === plugin functions ===  }}}
line 429: " === plugin event handlers === {{{
line 430: "
line 431: " s:LoadPlugin() {{{
line 432: "
line 433: fun! s:LoadPlugin()
line 469: 
line 470: " }}}
line 471: " s:VimEnterHandler() {{{
line 472: "
line 473: fun! s:VimEnterHandler()
line 524: 
line 525: " }}} s:NewTabCreated {{{
line 526: "
line 527: " A flag to indicate that a new tab has just been created.
line 528: "
line 529: " We will handle the remaining work for this newly created tab separately in
line 530: " BufWinEnter event.
line 531: "
line 532: let s:NewTabCreated = 0
line 533: 
line 534: " }}}
line 535: " s:TabEnterHandler() {{{
line 536: "
line 537: fun! s:TabEnterHandler()
line 563: 
line 564: " }}}
line 565: " s:TabLeaveHandler() {{{
line 566: "
line 567: fun! s:TabLeaveHandler()
line 573: 
line 574: " }}}
line 575: " s:WinEnterHandler() {{{
line 576: "
line 577: fun! s:WinEnterHandler()
line 591: 
line 592: " }}}
line 593: " s:WinLeaveHandler() {{{
line 594: "
line 595: fun! s:WinLeaveHandler()
line 604: 
line 605: " }}}
line 606: " s:BufWinEnterHandler() {{{
line 607: "
line 608: " BufWinEnter event only gets triggered after a new buffer has been
line 609: " successfully loaded, it is a proper time to finish the remaining
line 610: " work for newly opened tab.
line 611: "
line 612: fun! s:BufWinEnterHandler()
line 623: 
line 624: " }}}
line 625: " s:BufReadHandler() {{{
line 626: "
line 627: " BufRead event gets triggered after a new buffer has been
line 628: " successfully read from file.
line 629: "
line 630: fun! s:BufReadHandler()
line 637: 
line 638: " }}}
line 639: "
line 640: " === plugin event handlers === }}}
line 641: 
line 642: call s:LoadPlugin()
calling function <SNR>32_LoadPlugin()

line 1:   if exists('g:nerdtree_tabs_loaded')
line 2:     return
line 3:   endif
line 4: 
line 5:   let g:NERDTreeHijackNetrw = 0
line 6: 
line 7:   let s:disable_handlers_for_tabdo = 0
line 8: 
line 9:   " global on/off NERDTree state
line 10:   " the exists check is to enable script reloading without resetting the state
line 11:   if !exists('s:nerdtree_globally_active')
line 12:     let s:nerdtree_globally_active = 0
line 13:   endif
line 14: 
line 15:   " global focused/unfocused NERDTree state
line 16:   " the exists check is to enable script reloading without resetting the state
line 17:   if !exists('s:is_nerdtree_globally_focused')
line 18:     call s:SaveGlobalFocus()
calling function <SNR>32_LoadPlugin[18]..<SNR>32_SaveGlobalFocus()

line 1:   let s:is_nerdtree_globally_focused = s:IsCurrentWindowNERDTree()
calling function <SNR>32_LoadPlugin[18]..<SNR>32_SaveGlobalFocus[1]..<SNR>32_IsCurrentWindowNERDTree()

line 1:   return exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) == winnr()
function <SNR>32_LoadPlugin[18]..<SNR>32_SaveGlobalFocus[1]..<SNR>32_IsCurrentWindowNERDTree returning #0

continuing in function <SNR>32_LoadPlugin[18]..<SNR>32_SaveGlobalFocus

function <SNR>32_LoadPlugin[18]..<SNR>32_SaveGlobalFocus returning #0

continuing in function <SNR>32_LoadPlugin

line 19:   end
line 20: 
line 21:   augroup NERDTreeTabs
line 22:     autocmd!
line 23:     autocmd VimEnter * call <SID>VimEnterHandler()
line 24:     autocmd TabEnter * call <SID>TabEnterHandler()
line 25:     autocmd TabLeave * call <SID>TabLeaveHandler()
line 26:     " We enable nesting for this autocommand (see :h autocmd-nested) so that
line 27:     " exiting Vim when NERDTree is the last window triggers the VimLeave event.
line 28:     autocmd WinEnter * nested call <SID>WinEnterHandler()
line 29:     autocmd WinLeave * call <SID>WinLeaveHandler()
line 30:     autocmd BufWinEnter * call <SID>BufWinEnterHandler()
line 31:     autocmd BufRead * call <SID>BufReadHandler()
line 32:   augroup END
line 33: 
line 34:   let g:nerdtree_tabs_loaded = 1
function <SNR>32_LoadPlugin returning #0

continuing in /home/w/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim

finished sourcing /home/w/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim
continuing in function nerdtree#postSourceActions
Searching for "/home/w/.vim/bundle/vim-rtags/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vim81/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"
Searching for "/home/w/.vim/after/nerdtree_plugin/**/*.vim"
function nerdtree#postSourceActions returning #0

continuing in /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 248: 
line 249: "reset &cpo back to users setting
line 250: let &cpo = s:old_cpo
line 251: 
line 252: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/w/.vim/bundle/nerdtree/plugin/NERD_tree.vim
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/plugin/**/*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/plugin/**/*.vim"
chdir(/home/w/.vim/bundle/vim-rtags/plugin)
fchdir() to previous dir
sourcing "/home/w/.vim/bundle/vim-rtags/plugin/rtags.vim"
line 1: if has('nvim') || (has('job') && has('channel'))
line 2:     let s:rtagsAsync = 1
line 3:     let s:job_cid = 0
line 4:     let s:jobs = {}
line 5:     let s:result_stdout = {}
line 6:     let s:result_handlers = {}
line 7: else
line 8:     let s:rtagsAsync = 0
line 9: endif
line 10: 
line 11: if has('python')
line 12:     let g:rtagsPy = 'python'
line 13: elseif has('python3')
line 14:     let g:rtagsPy = 'python3'
line 15: else
line 16:     echohl ErrorMsg | echomsg "[vim-rtags] Vim is missing python support" | echohl None
line 16:  echomsg "[vim-rtags] Vim is missing python support" | echohl None
line 16:  echohl None
line 17:     finish
line 18: end
line 19: 
line 20: 
line 21: 
line 22: if !exists("g:rtagsRcCmd")
line 23:     let g:rtagsRcCmd = "rc"
line 24: endif
line 25: 
line 26: if !exists("g:rtagsRdmCmd")
line 27:     let g:rtagsRdmCmd = "rdm"
line 28: endif
line 29: 
line 30: if !exists("g:rtagsAutoLaunchRdm")
line 31:     let g:rtagsAutoLaunchRdm = 0
line 32: endif
line 33: 
line 34: if !exists("g:rtagsJumpStackMaxSize")
line 35:     let g:rtagsJumpStackMaxSize = 100
line 36: endif
line 37: 
line 38: if !exists("g:rtagsExcludeSysHeaders")
line 39:     let g:rtagsExcludeSysHeaders = 0
line 40: endif
line 41: 
line 42: let g:rtagsJumpStack = []
line 43: 
line 44: if !exists("g:rtagsUseLocationList")
line 45:     let g:rtagsUseLocationList = 1
line 46: endif
line 47: 
line 48: if !exists("g:rtagsUseDefaultMappings")
line 49:     let g:rtagsUseDefaultMappings = 1
line 50: endif
line 51: 
line 52: if !exists("g:rtagsMinCharsForCommandCompletion")
line 53:     let g:rtagsMinCharsForCommandCompletion = 4
line 54: endif
line 55: 
line 56: if !exists("g:rtagsMaxSearchResultWindowHeight")
line 57:     let g:rtagsMaxSearchResultWindowHeight = 10
line 58: endif
line 59: 
line 60: if g:rtagsAutoLaunchRdm
line 61:     call system(g:rtagsRcCmd." -w")
line 62:     if v:shell_error != 0 
line 63:         call system(g:rtagsRdmCmd." --daemon > /dev/null")
line 64:     end
line 65: end
line 66: 
line 67: let g:SAME_WINDOW = 'same_window'
line 68: let g:H_SPLIT = 'hsplit'
line 69: let g:V_SPLIT = 'vsplit'
line 70: let g:NEW_TAB = 'tab'
line 71: 
line 77: let s:LOC_OPEN_OPTS = { g:SAME_WINDOW : '', g:H_SPLIT : ' ', g:V_SPLIT : 'vert', g:NEW_TAB : 'tab' }
line 78: 
line 79: if g:rtagsUseDefaultMappings == 1
line 80:     noremap <Leader>ri :call rtags#SymbolInfo()<CR>
line 81:     noremap <Leader>rj :call rtags#JumpTo(g:SAME_WINDOW)<CR>
line 82:     noremap <Leader>rJ :call rtags#JumpTo(g:SAME_WINDOW, { '--declaration-only' : '' })<CR>
line 83:     noremap <Leader>rS :call rtags#JumpTo(g:H_SPLIT)<CR>
line 84:     noremap <Leader>rV :call rtags#JumpTo(g:V_SPLIT)<CR>
line 85:     noremap <Leader>rT :call rtags#JumpTo(g:NEW_TAB)<CR>
line 86:     noremap <Leader>rp :call rtags#JumpToParent()<CR>
line 87:     noremap <Leader>rf :call rtags#FindRefs()<CR>
line 88:     noremap <Leader>rF :call rtags#FindRefsCallTree()<CR>
line 89:     noremap <Leader>rn :call rtags#FindRefsByName(input("Pattern? ", "", "customlist,rtags#CompleteSymbols"))<CR>
line 90:     noremap <Leader>rs :call rtags#FindSymbols(input("Pattern? ", "", "customlist,rtags#CompleteSymbols"))<CR>
line 91:     noremap <Leader>rr :call rtags#ReindexFile()<CR>
line 92:     noremap <Leader>rl :call rtags#ProjectList()<CR>
line 93:     noremap <Leader>rw :call rtags#RenameSymbolUnderCursor()<CR>
line 94:     noremap <Leader>rv :call rtags#FindVirtuals()<CR>
line 95:     noremap <Leader>rb :call rtags#JumpBack()<CR>
line 96:     noremap <Leader>rh :call rtags#ShowHierarchy()<CR>
line 97:     noremap <Leader>rC :call rtags#FindSuperClasses()<CR>
line 98:     noremap <Leader>rc :call rtags#FindSubClasses()<CR>
line 99:     noremap <Leader>rd :call rtags#Diagnostics()<CR>
line 100: endif
line 101: 
line 102: let s:script_folder_path = escape( expand( '<sfile>:p:h' ), '\' )
line 103: 
line 104: function! rtags#InitPython()
line 113: 
line 114: call rtags#InitPython()
Searching for "autoload/rtags.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/autoload/rtags.vim"
Searching for "/home/w/.vim/bundle/nerdtree/autoload/rtags.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/autoload/rtags.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/autoload/rtags.vim"
Searching for "/usr/share/vim/vimfiles/autoload/rtags.vim"
Searching for "/usr/share/vim/vim81/autoload/rtags.vim"
Searching for "/usr/share/vim/vimfiles/after/autoload/rtags.vim"
Searching for "/home/w/.vim/after/autoload/rtags.vim"
not found in 'runtimepath': "autoload/rtags.vim"
calling function rtags#InitPython()

line 1:     let s:pyInitScript = " import vim; script_folder = vim.eval('s:script_folder_path'); sys.path.insert(0, script_folder); import vimrtags"
line 6: 
line 7:     exe g:rtagsPy." ".s:pyInitScript
line 7: python  import vim; script_folder = vim.eval('s:script_folder_path'); sys.path.insert(0, script_folder); import vimrtags
function rtags#InitPython returning #0

continuing in /home/w/.vim/bundle/vim-rtags/plugin/rtags.vim

line 115: 
line 116: """
line 117: " Logging routine
line 118: """
line 119: function! rtags#Log(message)
line 124: 
line 125: "
line 126: " Executes rc with given arguments and returns rc output
line 127: "
line 128: " param[in] args - dictionary of arguments
line 129: "-
line 130: " return output split by newline
line 131: function! rtags#ExecuteRC(args)
line 170: 
line 171: function! rtags#CreateProject()
line 174: 
line 175: "
line 176: " param[in] results - List of found locations by rc
line 177: " return locations - List of locations dict's recognizable by setloclist
line 178: "
line 179: function! rtags#ParseResults(results)
line 204: 
line 205: function! rtags#ExtractClassHierarchyLine(line)
line 208: 
line 209: "
line 210: " Converts a class hierarchy of 'rc --class-hierarchy' like:
line 211: "
line 212: " Superclasses:
line 213: "   class Foo src/Foo.h:56:7: class Foo : public Bar {
line 214: "     class Bar^Isrc/Bar.h:46:7:^Iclass Bar : public Bas {
line 215: "       class Bas src/Bas.h:47:7: class Bas {
line 216: " Subclasses:
line 217: "   class Foo src/Foo.h:56:7: class Foo : public Bar {
line 218: "     class Foo2 src/Foo2.h:56:7: class Foo2 : public Foo {
line 219: "     class Foo3 src/Foo3.h:56:7: class Foo3 : public Foo {
line 220: "
line 221: " into the super classes:
line 222: "
line 223: " src/Foo.h:56:7: class Foo : public Bar {
line 224: " src/Bar.h:46:7: class Bar : public Bas {
line 225: " src/Bas.h:47:7: class Bas {
line 226: "
line 227: function! rtags#ExtractSuperClasses(results)
line 243: 
line 244: "
line 245: " Converts a class hierarchy of 'rc --class-hierarchy' like:
line 246: "
line 247: " Superclasses:
line 248: "   class Foo src/Foo.h:56:7: class Foo : public Bar {
line 249: "     class Bar^Isrc/Bar.h:46:7:^Iclass Bar : public Bas {
line 250: "       class Bas src/Bas.h:47:7: class Bas {
line 251: " Subclasses:
line 252: "   class Foo src/Foo.h:56:7: class Foo : public Bar {
line 253: "     class Foo2 src/Foo2.h:56:7: class Foo2 : public Foo {
line 254: "     class Foo3 src/Foo3.h:56:7: class Foo3 : public Foo {
line 255: "
line 256: " into the sub classes:
line 257: "
line 258: " src/Foo.h:56:7: class Foo : public Bar {
line 259: " src/Foo2.h:56:7: class Foo2 : public Foo {
line 260: " src/Foo3.h:56:7: class Foo3 : public Foo {
line 261: "
line 262: function! rtags#ExtractSubClasses(results)
line 279: 
line 280: "
line 281: " param[in] locations - List of locations, one per line
line 282: "
line 283: function! rtags#DisplayLocations(locations)
line 297: 
line 298: "
line 299: " param[in] results - List of locations, one per line
line 300: "
line 301: " Format of each line: <path>,<line>\s<text>
line 302: function! rtags#DisplayResults(results)
line 306: 
line 307: "
line 308: " Creates a tree viewer for references to a symbol
line 309: "
line 310: " param[in] results - List of locations, one per line
line 311: "
line 312: " Format of each line: <path>,<line>\s<text>\sfunction: <caller path>
line 313: function! rtags#ViewReferences(results)
line 339: 
line 340: "
line 341: " Expands the callers of the reference on the current line.
line 342: "
line 343: function! s:ExpandReferences() " <<<
line 357: 
line 358: "
line 359: " Opens the reference for viewing in the window below.
line 360: "
line 361: function! s:OpenReference() " <<<
line 377: 
line 378: "
line 379: " Adds the list of references below the targeted item in the reference
line 380: " viewer window.
line 381: "
line 382: " param[in] results - List of locations, one per line
line 383: " param[in] rnum - The record number the references are calling or -1
line 384: "
line 385: " Format of each line: <path>,<line>\s<text>\sfunction: <caller path>
line 386: function! rtags#AddReferences(results, rnum)
line 432: 
line 433: " Creates a viewer for hierarachy results
line 434: "
line 435: " param[in] results - List of class hierarchy
line 436: "
line 437: " Hierarchy references have format: <type> <name> <file>:<line>:<col>: <text>
line 438: "
line 439: function! rtags#ViewHierarchy(results)
line 463: 
line 464: "
line 465: " Opens the location on the current line.
line 466: "
line 467: " Hierarchy references have format: <type> <name> <file>:<line>:<col>: <text>
line 468: "
line 469: function! s:OpenHierarchyLocation() " <<<
line 483: 
line 484: function! rtags#getRcCmd()
line 492: 
line 493: function! rtags#getCurrentLocation()
line 497: 
line 498: function! rtags#SymbolInfoHandler(output)
line 501: 
line 502: function! rtags#SymbolInfo()
line 505: 
line 506: function! rtags#cloneCurrentBuffer(type)
line 515: 
line 516: function! rtags#jumpToLocation(file, line, col)
line 520: 
line 521: function! rtags#jumpToLocationInternal(file, line, col)
line 535: 
line 536: function! rtags#JumpToHandler(results, args)
line 557: 
line 558: "
line 559: " JumpTo(open_type, ...)
line 560: "     open_type - Vim command used for opening desired location.
line 561: "     Allowed values:
line 562: "       * g:SAME_WINDOW
line 563: "       * g:H_SPLIT
line 564: "       * g:V_SPLIT
line 565: "       * g:NEW_TAB
line 566: "
line 567: "     a:1 - dictionary of additional arguments for 'rc'
line 568: "
line 569: function! rtags#JumpTo(open_opt, ...)
line 579: 
line 580: function! rtags#parseSourceLocation(string)
line 592: 
line 593: function! rtags#saveLocation()
line 597: 
line 598: function! rtags#pushToStack(location)
line 605: 
line 606: function! rtags#JumpBack()
line 614: 
line 615: function! rtags#JumpToParentHandler(results)
line 637: 
line 638: function! rtags#JumpToParent(...)
line 645: 
line 646: function! s:GetCharacterUnderCursor()
line 649: 
line 650: function! rtags#RenameSymbolUnderCursorHandler(output)
line 687: 
line 688: function! rtags#RenameSymbolUnderCursor()
line 696: 
line 697: function! rtags#TempFile(job_cid)
line 700: 
line 701: function! rtags#ExecuteRCAsync(args, handlers)
line 753: 
line 754: function! rtags#HandleResults(job_id, data, event)
line 776: 
line 777: function! rtags#ExecuteHandlers(output, handlers)
line 794: 
line 795: function! rtags#ExecuteThen(args, handlers)
line 803: 
line 804: function! rtags#FindRefs()
line 811: 
line 812: function! rtags#ShowHierarchy()
line 817: 
line 818: function! rtags#FindRefsCallTree()
line 825: 
line 826: function! rtags#FindSuperClasses()
line 830: 
line 831: function! rtags#FindSubClasses()
line 836: 
line 837: function! rtags#FindVirtuals()
line 844: 
line 845: function! rtags#FindRefsByName(name)
line 853: 
line 854: " case insensitive FindRefsByName
line 855: function! rtags#IFindRefsByName(name)
line 864: 
line 865: " Find all those references which has the name which is equal to the word
line 866: " under the cursor
line 867: function! rtags#FindRefsOfWordUnderCursor()
line 871: 
line 872: """ rc -HF <pattern>
line 873: function! rtags#FindSymbols(pattern)
line 880: 
line 881: " Method for tab-completion for vim's commands
line 882: function! rtags#CompleteSymbols(arg, line, pos)
line 888: 
line 889: " case insensitive FindSymbol
line 890: function! rtags#IFindSymbols(pattern)
line 898: 
line 899: function! rtags#ProjectListHandler(output)
line 911: 
line 912: function! rtags#ProjectList()
line 915: 
line 916: function! rtags#ProjectOpen(pattern)
line 919: 
line 920: function! rtags#LoadCompilationDb(pattern)
line 923: 
line 924: function! rtags#ProjectClose(pattern)
line 927: 
line 928: function! rtags#PreprocessFileHandler(result)
line 932: 
line 933: function! rtags#PreprocessFile()
line 936: 
line 937: function! rtags#ReindexFile()
line 940: 
line 941: function! rtags#FindSymbolsOfWordUnderCursor()
line 945: 
line 946: function! rtags#Diagnostics()
line 950: 
line 951: "
line 952: " This function assumes it is invoked from insert mode
line 953: "
line 954: function! rtags#CompleteAtCursor(wordStart, base)
line 995: 
line 996: function! s:Pyeval( eval_string )
line 1003:     
line 1004: function! s:RcExecuteJobCompletion()
line 1012: 
line 1013: "{{{ RcExecuteJobHandler
line 1014: "Handles stdout/stderr/exit events, and stores the stdout/stderr received from the shells.
line 1015: function! RcExecuteJobHandler(job_id, data, event)
line 1022: 
line 1023: function! rtags#SetJobStateFinish()
line 1026: 
line 1027: function! rtags#AddJobStandard(eventType, data)
line 1030: 
line 1031: function! rtags#SetJobStateReady()
line 1034: 
line 1035: function! rtags#IsJobStateReady()
line 1041: 
line 1042: function! rtags#IsJobStateBusy()
line 1048: 
line 1049: function! rtags#IsJobStateFinish()
line 1055: 
line 1056: 
line 1057: function! rtags#SetStartJobState()
line 1062: 
line 1063: function! rtags#GetJobStdOutput()
line 1066: 
line 1067: function! rtags#ExistsAndCreateRtagsState()
line 1072: 
line 1073: "{{{ s:RcExecute
line 1074: " Execute clang binary to generate completions and diagnostics.
line 1075: " Global variable:
line 1076: " Buffer vars:
line 1077: "     b:rtags_state => {
line 1078: "       'state' :  // updated to 'ready' in sync mode
line 1079: "       'stdout':  // updated in sync mode
line 1080: "       'stderr':  // updated in sync mode
line 1081: "     }
line 1082: "
line 1083: "     b:clang_execute_job_id  // used to stop previous job
line 1084: "
line 1085: " @root Clang root, project directory
line 1086: " @line Line to complete
line 1087: " @col Column to complete
line 1088: " @return [completion, diagnostics]
line 1089: function! s:RcJobExecute(offset, line, col)
line 1123: 
line 1124: """
line 1125: " Temporarily the way this function works is:
line 1126: "     - completeion invoked on
line 1127: "         object.meth*
line 1128: "       , where * is cursor position
line 1129: "     - find the position of a dot/arrow
line 1130: "     - invoke completion through rc
line 1131: "     - filter out options that start with meth (in this case).
line 1132: "     - show completion options
line 1133: " 
line 1134: "     Reason: rtags returns all options regardless of already type method name
line 1135: "     portion
line 1136: """
line 1137: 
line 1138: function! RtagsCompleteFunc(findstart, base)
line 1145: 
line 1146: function! s:RtagsCompleteFunc(findstart, base, async)
line 1162: 
line 1163: if &completefunc == ""
line 1164:     set completefunc=RtagsCompleteFunc
line 1165: endif
line 1166: 
line 1167: " Helpers to access script locals for unit testing {{{
line 1168: function! s:get_SID()
line 1171: let s:SID = s:get_SID()
calling function <SNR>33_get_SID()

line 1:     return matchstr(expand('<sfile>'), '<SNR>\d\+_')
function <SNR>33_get_SID returning '<SNR>33_'

continuing in /home/w/.vim/bundle/vim-rtags/plugin/rtags.vim

line 1172: delfunction s:get_SID
line 1173: 
line 1174: function! rtags#__context__()
line 1177: "}}}
line 1178: 
line 1179: command! -nargs=1 -complete=customlist,rtags#CompleteSymbols RtagsFindSymbols call rtags#FindSymbols(<q-args>)
line 1180: command! -nargs=1 -complete=customlist,rtags#CompleteSymbols RtagsFindRefsByName call rtags#FindRefsByName(<q-args>)
line 1181: 
line 1182: command! -nargs=1 -complete=customlist,rtags#CompleteSymbols RtagsIFindSymbols call rtags#IFindSymbols(<q-args>)
line 1183: command! -nargs=1 -complete=customlist,rtags#CompleteSymbols RtagsIFindRefsByName call rtags#IFindRefsByName(<q-args>)
line 1184: 
line 1185: command! -nargs=1 -complete=dir RtagsLoadCompilationDb call rtags#LoadCompilationDb(<q-args>)
line 1186: 
line 1187: " The most commonly used find operation
line 1188: command! -nargs=1 -complete=customlist,rtags#CompleteSymbols Rtag RtagsIFindSymbols <q-args>
line 1189: 
finished sourcing /home/w/.vim/bundle/vim-rtags/plugin/rtags.vim
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
Searching for "/usr/share/vim/vim81/plugin/**/*.vim"
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/share/vim/vim81/plugin/getscriptPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Oct 30
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 52: augroup END
finished sourcing /usr/share/vim/vim81/plugin/gzip.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
line 2: "   Author:  Charles E. Campbell
line 3: "   Date:    Apr 04, 2016
line 4: "   Version: 4
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: "   Usage: {{{1
line 17: "       :LogiPat ...
line 18: "
line 19: "         Boolean logic supported:
line 20: "            () grouping operators
line 21: "            !  not the following pattern
line 22: "            |  logical or
line 23: "            &  logical and
line 24: "            "..pattern.."
line 25: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
line 39: if &cp || exists("loaded_logiPat")
line 40:  finish
line 41: endif
line 42: let g:loaded_logiPat = "v4"
line 43: let s:keepcpo        = &cpo
line 44: set cpo&vim
line 45: "DechoRemOn
line 46: 
line 47: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 55: 
line 56: " =====================================================================
line 57: " Functions: {{{1
line 58: 
line 59: " ---------------------------------------------------------------------
line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 61: fun! LogiPat(pat,...)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:String: Vim6.4 doesn't have string() {{{2
line 149: func! s:String(str)
line 152: 
line 153: " ---------------------------------------------------------------------
line 154: " LP_PatPush: {{{2
line 155: fun! s:LP_PatPush(pat)
line 162: 
line 163: " ---------------------------------------------------------------------
line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 165: fun! s:LP_PatPop(lookup)
line 178: 
line 179: " ---------------------------------------------------------------------
line 180: " LP_OpPush: {{{2
line 181: fun! s:LP_OpPush(op)
line 232: 
line 233: " ---------------------------------------------------------------------
line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 235: fun! s:LP_Execute(preclvl)
line 265: 
line 266: " ---------------------------------------------------------------------
line 267: " LP_Not: writes a logical-not for a pattern {{{2
line 268: fun! s:LP_Not(pat)
line 279: 
line 280: " ---------------------------------------------------------------------
line 281: " LP_Or: writes a logical-or branch using two patterns {{{2
line 282: fun! s:LP_Or(pat1,pat2)
line 288: 
line 289: " ---------------------------------------------------------------------
line 290: " LP_And: writes a logical-and concat using two patterns {{{2
line 291: fun! s:LP_And(pat1,pat2)
line 297: 
line 298: " ---------------------------------------------------------------------
line 299: " StackLook: {{{2
line 300: fun! s:StackLook(description)
line 334: 
line 335: " ---------------------------------------------------------------------
line 336: "  Cleanup And Modeline: {{{1
line 337: let &cpo= s:keepcpo
line 338: unlet s:keepcpo
line 339: " vim: ts=4 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/logiPat.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2018 Feb 04
line 4: 
line 5: command! -nargs=0 MANPAGER call s:ManPager() | delcommand MANPAGER
line 6: 
line 7: function! s:ManPager()
finished sourcing /usr/share/vim/vim81/plugin/manpager.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2018 Jul 3
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: augroup matchparen
line 22:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: function! s:Highlight_Matching_Pair()
line 197: 
line 198: " Define commands that will disable and enable the plugin.
line 199: command! DoMatchParen call s:DoMatchParen()
line 200: command! NoMatchParen call s:NoMatchParen()
line 201: 
line 202: func! s:NoMatchParen()
line 209: 
line 210: func! s:DoMatchParen()
line 216: 
line 217: let &cpo = s:cpo_save
line 218: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/plugin/matchparen.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 08, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v156"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try                                                       
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
line 85:  endif
line 86:  if maparg('gx','v') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 148: 
line 149: " ---------------------------------------------------------------------
line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 152: "             them, which checks if they're directories and will create a directory
line 153: "             listing when appropriate.
line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 155: "             has already been called.
line 156: fun! s:VimEnter(dirname)
line 164: 
line 165: " ---------------------------------------------------------------------
line 166: " NetrwStatusLine: {{{1
line 167: fun! NetrwStatusLine()
line 178: 
line 179: " ------------------------------------------------------------------------
line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 184: fun! NetUserPass(...)
line 208: 
line 209: " ------------------------------------------------------------------------
line 210: " Modelines And Restoration: {{{1
line 211: let &cpo= s:keepcpo
line 212: unlet s:keepcpo
line 213: " vim:ts=8 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/netrwPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
finished sourcing /usr/share/vim/vim81/plugin/rrhelper.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
line 11: endif
line 12: let loaded_spellfile_plugin = 1
line 13: 
line 14: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/vim/vim81/plugin/spellfile.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47: augroup END
line 48: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 49: 
line 50: " ---------------------------------------------------------------------
line 51: " Restoration And Modelines: {{{1
line 52: " vim: fdm=marker
line 53: let &cpo= s:keepcpo
line 54: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/tarPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2018 Nov 11
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: if exists('g:loaded_2html_plugin')
line 9:   finish
line 10: endif
line 11: let g:loaded_2html_plugin = 'vim8.1_v1'
line 12: 
line 13: "
line 14: " Changelog: {{{
line 15: "   8.1_v1  (this version): Fix Bitbucket issue #6: Don't generate empty script
line 16: "                           tag.
line 17: "                           Fix Bitbucket issue #5: javascript should
line 18: "                           declare variables with "var".
line 19: "                           Fix Bitbucket issue #13: errors thrown sourcing
line 20: "                           2html.vim directly when plugins not loaded.
line 21: "                           Fix Bitbucket issue #16: support 'vartabstop'.
line 22: "
line 23: "   7.4 updates: {{{
line 24: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 25: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 26: "                           take a list so it is easier to specfiy fallback
line 27: "                           fonts in the generated CSS.
line 28: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 29: "^I^I^I    also for version-specific modelines like "vim>703:".
line 30: "}}}
line 31: "
line 32: "   7.3 updates: {{{
line 33: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 34: "^I^I^I    g:html_line_ids=0. Allow customizing
line 35: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 36: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 37: "^I^I^I    is started.
line 38: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 39: "^I^I^I    insert modeline to set it to manual.
line 40: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 41: "^I^I^I    duplicate of one buffer instead of including both.
line 42: "^I^I^I    Add anchors to each line so you can put '#L123'
line 43: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 44: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 45: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 46: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 47: "^I^I^I    Allow TOhtml to chain together with other commands
line 48: "^I^I^I    using |.
line 49: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 50: "^I^I^I    highlight groups make up the start-of-modeline text.
line 51: "^I^I^I    Improve render time of page with uncopyable regions
line 52: "^I^I^I    by not using one-input-per-char. Change name of
line 53: "^I^I^I    uncopyable option from html_unselectable to
line 54: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 55: "^I^I^I    default to inserting invalid markup for uncopyable
line 56: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 57: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 58: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 59: "^I^I^I    eliminate post-processing substitute commands in
line 60: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 61: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 62: "^I^I^I    speed improvements. Fix modeline mangling in
line 63: "^I^I^I    generated output so it works for text in the first
line 64: "^I^I^I    column. Fix missing line number and fold column in
line 65: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 66: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 67: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 68: "^I^I^I    the new default foldtext added in v11, as the patch
line 69: "^I^I^I    adding it has not yet been included in Vim.
line 70: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 71: "^I^I^I    Brabandt in
line 72: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 73: "^I^I^I    This patch has not yet been included in Vim, thus
line 74: "^I^I^I    these changes are removed in the next version.
line 75: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 76: "^I^I^I    multiple nested folds with dynamic folding on.
line 77: "^I^I^I    Also fix problem with foldtext in this situation.
line 78: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 79: "^I^I^I    and without html_no_pre, default value same as
line 80: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 81: "^I^I^I    'fileencoding' for converted document encoding if
line 82: "^I^I^I    'buftype' indicates a special buffer which isn't
line 83: "^I^I^I    written.
line 84: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 85: "^I^I^I    characters in generated output (Andy Spencer).
line 86: "^I^I^I    Escape text that looks like a modeline so Vim
line 87: "^I^I^I    doesn't use anything in the converted HTML as a
line 88: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 89: "^I^I^I    before the conversion range. Remove fold column when
line 90: "^I^I^I    there are no folds.
line 91: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 92: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 93: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 94: "^I^I^I    supported by all major browsers according to
line 95: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 96: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 97: "^I^I^I    HTML encoding to Vim encoding detection be
line 98: "^I^I^I    case-insensitive for built-in pairs.
line 99: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 100: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 101: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 102: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 103: "^I^I^I    file matches its indicated charset. Add charsets for
line 104: "^I^I^I    all of Vim's natively supported encodings.
line 105: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 106: "^I^I^I    user settings interfering with diff mode generation,
line 107: "^I^I^I    trailing whitespace (e.g. line number column) when
line 108: "^I^I^I    using html_no_pre, and bugs when using
line 109: "^I^I^I    html_hover_unfold.
line 110: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 111: "^I^I^I    folds in diff mode when first line was folded.
line 112: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 113: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 114: "^I^I^I    default to true when not set to anything. Use strict
line 115: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 116: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 117: "^I^I^I    when using this option. Add meta tag for settings.
line 118: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 119: "^I^I^I    diff colors and the normal syntax colors
line 120: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 121: "}}}
line 122: "}}}
line 123: 
line 124: " TODO: {{{
line 125: "   * Check the issue tracker:
line 126: "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
line 127: "   * Options for generating the CSS in external style sheets. New :TOcss
line 128: "     command to convert the current color scheme into a (mostly) generic CSS
line 129: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 130: "     by Erik Falor
line 131: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 132: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 133: "     term) to use for the styling. Suggestion by "nacitar".
line 134: "   * Add way to override or specify which RGB colors map to the color numbers
line 135: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 136: "   * Disable filetype detection until after all processing is done.
line 137: "   * Add option for not generating the hyperlink on stuff that looks like a
line 138: "     URL? Or just color the link to fit with the colorscheme (and only special
line 139: "     when hovering)?
line 140: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 141: "     regions is turned on. Possible solution: Add normal text line numbers with
line 142: "     display:none, set to display:inline for print style sheets, and hide
line 143: "     <input> elements for print, to allow Opera printing multiple pages (and
line 144: "     other uncopyable areas?). May need to make the new text invisible to IE
line 145: "     with conditional comments to prevent copying it, IE for some reason likes
line 146: "     to copy hidden text. Other browsers too?
line 147: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 148: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 149: "     on Windows). Perhaps it is font related?
line 150: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 151: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 152: "     on diff lines though.
line 153: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 154: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 155: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 156: "     accepted to modify it.
line 157: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 158: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 159: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 160: "     does not show the whole diff filler as it is supposed to?
line 161: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 162: "     invalid content. Can/should anything be done about this? Maybe a separate
line 163: "     plugin to correct 'isprint' based on encoding?
line 164: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 165: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 166: "   * Font auto-detection similar to
line 167: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 168: "     platforms.
line 169: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 170: "^I- listchars support
line 171: "^I- full-line background highlight
line 172: "^I- other?
line 173: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 174: "     free with full-line background highlight above).
line 175: "   * Restore open/closed folds and cursor position after processing each file
line 176: "     with option not to restore for speed increase.
line 177: "   * Add extra meta info (generation time, etc.)?
line 178: "   * Tidy up so we can use strict doctype in even more situations
line 179: "   * Implementation detail: add threshold for writing the lines to the html
line 180: "     buffer before we're done (5000 or so lines should do it)
line 181: "   * TODO comments for code cleanup scattered throughout
line 182: "}}}
line 183: 
line 184: " Define the :TOhtml command when:
line 185: " - 'compatible' is not set
line 186: " - this plugin or user override was not already loaded
line 187: " - user commands are available. {{{
line 188: if !&cp && !exists(":TOhtml") && has("user_commands")
line 189:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 190: endif "}}}
line 191: 
line 192: " Make sure any patches will probably use consistent indent
line 193: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/tohtml.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell
line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v37"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: augroup Vimball
line 30:  au!
line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 37: augroup END
line 38: 
line 39: " =====================================================================
line 40: " Restoration And Modelines: {{{1
line 41: " vim: fdm=marker
line 42: let &cpo= s:keepcpo
line 43: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/vimballPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^ISep 13, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v28"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/zipPlugin.vim
Searching for "pack/*/start/*" in "/home/w/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/w/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/home/w/.vim/after/plugin/**/*.vim"
not found in 'runtimepath': "plugin/**/*.vim"
Reading viminfo file "/home/w/.viminfo" info oldfiles
chdir(main)
fchdir() to previous dir
chdir(main)
fchdir() to previous dir
                        "main/kmain.cpp" 
"main/kmain.cpp" 83L, 1952C
Reading viminfo file "/home/w/.viminfo" marks
Executing BufRead Autocommands for "*"
autocommand if line("'\"") > 0 && line ("'\"") <= line("$") |   exe "normal! g'\"" | endif

line 0: if line("'\"") > 0 && line ("'\"") <= line("$") |   exe "normal! g'\"" | endif
line 0:    exe "normal! g'\"" | endif
line 0: normal! g'"
line 0:  endif
Executing BufRead Autocommands for "*.cpp"
autocommand if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif

line 0: if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 0: setf cynlib|else|setf cpp|endif
line 0: else|setf cpp|endif
line 0: setf cpp|endif
Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

line 0: call s:LoadFTPlugin()
calling function <SNR>6_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17: ^Iexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 17: runtime! ftplugin/cpp.vim ftplugin/cpp_*.vim ftplugin/cpp/*.vim
Searching for "ftplugin/cpp.vim ftplugin/cpp_*.vim ftplugin/cpp/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftplugin/cpp.vim"
Searching for "/home/w/.vim/ftplugin/cpp_*.vim"
Searching for "/home/w/.vim/ftplugin/cpp/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/cpp.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/cpp_*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/cpp/*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/cpp.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/cpp_*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/cpp/*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/cpp.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/cpp_*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/cpp/*.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/cpp.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/cpp_*.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/cpp/*.vim"
Searching for "/usr/share/vim/vim81/ftplugin/cpp.vim"
chdir(/usr/share/vim/vim81/ftplugin)
fchdir() to previous dir
line 17: sourcing "/usr/share/vim/vim81/ftplugin/cpp.vim"
line 1: " Vim filetype plugin file
line 2: " Language:^IC++
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2001 Jan 15
line 5: 
line 6: " Only do this when not done yet for this buffer
line 7: if exists("b:did_ftplugin")
line 8:   finish
line 9: endif
line 10: 
line 11: " Behaves just like C
line 12: runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
Searching for "ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftplugin/c.vim"
Searching for "/home/w/.vim/ftplugin/c_*.vim"
Searching for "/home/w/.vim/ftplugin/c/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/c.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/c_*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/c/*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/c.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/c_*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/c/*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/c.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/c_*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/c/*.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/c.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/c_*.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/c/*.vim"
Searching for "/usr/share/vim/vim81/ftplugin/c.vim"
chdir(/usr/share/vim/vim81/ftplugin)
fchdir() to previous dir
line 12: sourcing "/usr/share/vim/vim81/ftplugin/c.vim"
line 1: " Vim filetype plugin file
line 2: " Language:^IC
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2017 Sep 28
line 5: 
line 6: " Only do this when not done yet for this buffer
line 7: if exists("b:did_ftplugin")
line 8:   finish
line 9: endif
line 10: 
line 11: " Don't load another plugin for this buffer
line 12: let b:did_ftplugin = 1
line 13: 
line 14: " Using line continuation here.
line 15: let s:cpo_save = &cpo
line 16: set cpo-=C
line 17: 
line 18: let b:undo_ftplugin = "setl fo< com< ofu< | if has('vms') | setl isk< | endif"
line 19: 
line 20: " Set 'formatoptions' to break comment lines but not other lines,
line 21: " and insert the comment leader when hitting <CR> or using "o".
line 22: setlocal fo-=t fo+=croql
line 23: 
line 24: " Set completion with CTRL-X CTRL-O to autoloaded function.
line 25: if exists('&ofu')
line 26:   setlocal ofu=ccomplete#Complete
line 27: endif
line 28: 
line 29: " Set 'comments' to format dashed lists in comments.
line 30: setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
line 31: 
line 32: " In VMS C keywords contain '$' characters.
line 33: if has("vms")
line 34:   setlocal iskeyword+=$
line 35: endif
line 36: 
line 37: " When the matchit plugin is loaded, this makes the % command skip parens and
line 38: " braces in comments properly.
line 39: let b:match_words = '^\s*#\s*if\(\|def\|ndef\)\>:^\s*#\s*elif\>:^\s*#\s*else\>:^\s*#\s*endif\>'
line 40: let b:match_skip = 's:comment\|string\|character\|special'
line 41: 
line 42: " Win32 can filter files in the browse dialog
line 43: if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
line 44:   if &ft == "cpp"
line 48:     let b:browsefilter = "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" . "C Header Files (*.h)\t*.h\n" . "C Source Files (*.c)\t*.c\n" . "All Files (*.*)\t*.*\n"
line 49:   elseif &ft == "ch"
line 53:     let b:browsefilter = "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" . "C Header Files (*.h)\t*.h\n" . "C Source Files (*.c)\t*.c\n" . "All Files (*.*)\t*.*\n"
line 54:   else
line 59:     let b:browsefilter = "C Source Files (*.c)\t*.c\n" . "C Header Files (*.h)\t*.h\n" . "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" . "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" . "All Files (*.*)\t*.*\n"
line 60:   endif
line 61: endif
line 62: 
line 63: let &cpo = s:cpo_save
line 64: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/ftplugin/c.vim
continuing in /usr/share/vim/vim81/ftplugin/cpp.vim
Searching for "/usr/share/vim/vim81/ftplugin/c_*.vim"
Searching for "/usr/share/vim/vim81/ftplugin/c/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/c.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/c_*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/c/*.vim"
Searching for "/home/w/.vim/after/ftplugin/c.vim"
Searching for "/home/w/.vim/after/ftplugin/c_*.vim"
Searching for "/home/w/.vim/after/ftplugin/c/*.vim"
finished sourcing /usr/share/vim/vim81/ftplugin/cpp.vim
continuing in function <SNR>6_LoadFTPlugin
Searching for "/usr/share/vim/vim81/ftplugin/cpp_*.vim"
Searching for "/usr/share/vim/vim81/ftplugin/cpp/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/cpp.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/cpp_*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/cpp/*.vim"
Searching for "/home/w/.vim/after/ftplugin/cpp.vim"
Searching for "/home/w/.vim/after/ftplugin/cpp_*.vim"
Searching for "/home/w/.vim/after/ftplugin/cpp/*.vim"
line 18:       endfor
line 16:       for name in split(s, '\.')
line 17: ^Iexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 18:       endfor
line 19:     endif
function <SNR>6_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand exe "set syntax=" . expand("<amatch>")

line 0: exe "set syntax=" . expand("<amatch>")
line 0: set syntax=cpp
Executing Syntax Autocommands for "*"
autocommand call s:SynSet()

line 0: call s:SynSet()
calling function <SNR>3_SynSet()

line 1:   " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
line 2:   syn clear
line 3:   if exists("b:current_syntax")
line 4:     unlet b:current_syntax
line 5:   endif
line 6: 
line 7:   let s = expand("<amatch>")
line 8:   if s == "ON"
line 9:     " :set syntax=ON
line 10:     if &filetype == ""
line 11:       echohl ErrorMsg
line 12:       echo "filetype unknown"
line 13:       echohl None
line 14:     endif
line 15:     let s = &filetype
line 16:   elseif s == "OFF"
line 17:     let s = ""
line 18:   endif
line 19: 
line 20:   if s != ""
line 21:     " Load the syntax file(s).  When there are several, separated by dots,
line 22:     " load each in sequence.
line 23:     for name in split(s, '\.')
line 24:       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 24: runtime! syntax/cpp.vim syntax/cpp/*.vim
Searching for "syntax/cpp.vim syntax/cpp/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/syntax/cpp.vim"
Searching for "/home/w/.vim/syntax/cpp/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/syntax/cpp.vim"
Searching for "/home/w/.vim/bundle/nerdtree/syntax/cpp/*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/syntax/cpp.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/syntax/cpp/*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/syntax/cpp.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/syntax/cpp/*.vim"
Searching for "/usr/share/vim/vimfiles/syntax/cpp.vim"
Searching for "/usr/share/vim/vimfiles/syntax/cpp/*.vim"
Searching for "/usr/share/vim/vim81/syntax/cpp.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 24: sourcing "/usr/share/vim/vim81/syntax/cpp.vim"
line 1: " Vim syntax file
line 2: " Language:^IC++
line 3: " Current Maintainer:^Ivim-jp (https://github.com/vim-jp/vim-cpp)
line 4: " Previous Maintainer:^IKen Shan <ccshan@post.harvard.edu>
line 5: " Last Change:^I2017 Jun 05
line 6: 
line 7: " quit when a syntax file was already loaded
line 8: if exists("b:current_syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " Read the C syntax to start with
line 13: runtime! syntax/c.vim
Searching for "syntax/c.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/syntax/c.vim"
Searching for "/home/w/.vim/bundle/nerdtree/syntax/c.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/syntax/c.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/syntax/c.vim"
Searching for "/usr/share/vim/vimfiles/syntax/c.vim"
Searching for "/usr/share/vim/vim81/syntax/c.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim81/syntax/c.vim"
line 1: " Vim syntax file
line 2: " Language:^IC
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2019 Feb 11
line 5: 
line 6: " Quit when a (custom) syntax file was already loaded
line 7: if exists("b:current_syntax")
line 8:   finish
line 9: endif
line 10: 
line 11: let s:cpo_save = &cpo
line 12: set cpo&vim
line 13: 
line 14: let s:ft = matchstr(&ft, '^\([^.]\)\+')
line 15: 
line 16: " Optional embedded Autodoc parsing
line 17: " To enable it add: let g:c_autodoc = 1
line 18: " to your .vimrc
line 19: if exists("c_autodoc")
line 20:   syn include @cAutodoc <sfile>:p:h/autodoc.vim
line 21:   unlet b:current_syntax
line 22: endif
line 23: 
line 24: " A bunch of useful C keywords
line 25: syn keyword^IcStatement^Igoto break return continue asm
line 26: syn keyword^IcLabel^I^Icase default
line 27: syn keyword^IcConditional^Iif else switch
line 28: syn keyword^IcRepeat^I^Iwhile for do
line 29: 
line 30: syn keyword^IcTodo^I^Icontained TODO FIXME XXX
line 31: 
line 32: " It's easy to accidentally add a space after a backslash that was intended
line 33: " for line continuation.  Some compilers allow it, which makes it
line 34: " unpredictable and should be avoided.
line 35: syn match^IcBadContinuation contained "\\\s\+$"
line 36: 
line 37: " cCommentGroup allows adding matches for special things in comments
line 38: syn cluster^IcCommentGroup^Icontains=cTodo,cBadContinuation
line 39: 
line 40: " String and Character constants
line 41: " Highlight special characters (those which have a backslash) differently
line 42: syn match^IcSpecial^Idisplay contained "\\\(x\x\+\|\o\{1,3}\|.\|$\)"
line 43: if !exists("c_no_utf")
line 44:   syn match^IcSpecial^Idisplay contained "\\\(u\x\{4}\|U\x\{8}\)"
line 45: endif
line 46: 
line 47: if !exists("c_no_cformat")
line 48:   " Highlight % items in strings.
line 49:   if !exists("c_no_c99") " ISO C99
line 50:     syn match^IcFormat^I^Idisplay "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlLjzt]\|ll\|hh\)\=\([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
line 51:   else
line 52:     syn match^IcFormat^I^Idisplay "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
line 53:   endif
line 54:   syn match^IcFormat^I^Idisplay "%%" contained
line 55: endif
line 56: 
line 57: " cCppString: same as cString, but ends at end of line
line 58: if s:ft ==# "cpp" && !exists("cpp_no_cpp11") && !exists("c_no_cformat")
line 59:   " ISO C++11
line 60:   syn region^IcString^I^Istart=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
line 61:   syn region ^IcCppString^Istart=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
line 62: elseif s:ft ==# "c" && !exists("c_no_c11") && !exists("c_no_cformat")
line 63:   " ISO C99
line 64:   syn region^IcString^I^Istart=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
line 65:   syn region^IcCppString^Istart=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
line 66: else
line 67:   " older C or C++
line 68:   syn match^IcFormat^I^Idisplay "%%" contained
line 69:   syn region^IcString^I^Istart=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
line 70:   syn region^IcCppString^Istart=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
line 71: endif
line 72: 
line 73: syn region^IcCppSkip^Icontained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
line 74: 
line 75: syn cluster^IcStringGroup^Icontains=cCppString,cCppSkip
line 76: 
line 77: syn match^IcCharacter^I"L\='[^\\]'"
line 78: syn match^IcCharacter^I"L'[^']*'" contains=cSpecial
line 79: if exists("c_gnu")
line 80:   syn match^IcSpecialError^I"L\='\\[^'\"?\\abefnrtv]'"
line 81:   syn match^IcSpecialCharacter "L\='\\['\"?\\abefnrtv]'"
line 82: else
line 83:   syn match^IcSpecialError^I"L\='\\[^'\"?\\abfnrtv]'"
line 84:   syn match^IcSpecialCharacter "L\='\\['\"?\\abfnrtv]'"
line 85: endif
line 86: syn match^IcSpecialCharacter display "L\='\\\o\{1,3}'"
line 87: syn match^IcSpecialCharacter display "'\\x\x\{1,2}'"
line 88: syn match^IcSpecialCharacter display "L'\\x\x\+'"
line 89: 
line 90: if (s:ft ==# "c" && !exists("c_no_c11")) || (s:ft ==# "cpp" && !exists("cpp_no_cpp11"))
line 91:   " ISO C11 or ISO C++ 11
line 92:   if exists("c_no_cformat")
line 93:     syn region^IcString^I^Istart=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
line 94:   else
line 95:     syn region^IcString^I^Istart=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
line 96:   endif
line 97:   syn match^IcCharacter^I"[Uu]'[^\\]'"
line 98:   syn match^IcCharacter^I"[Uu]'[^']*'" contains=cSpecial
line 99:   if exists("c_gnu")
line 100:     syn match^IcSpecialError^I"[Uu]'\\[^'\"?\\abefnrtv]'"
line 101:     syn match^IcSpecialCharacter "[Uu]'\\['\"?\\abefnrtv]'"
line 102:   else
line 103:     syn match^IcSpecialError^I"[Uu]'\\[^'\"?\\abfnrtv]'"
line 104:     syn match^IcSpecialCharacter "[Uu]'\\['\"?\\abfnrtv]'"
line 105:   endif
line 106:   syn match^IcSpecialCharacter display "[Uu]'\\\o\{1,3}'"
line 107:   syn match^IcSpecialCharacter display "[Uu]'\\x\x\+'"
line 108: endif
line 109: 
line 110: "when wanted, highlight trailing white space
line 111: if exists("c_space_errors")
line 112:   if !exists("c_no_trail_space_error")
line 113:     syn match^IcSpaceError^Idisplay excludenl "\s\+$"
line 114:   endif
line 115:   if !exists("c_no_tab_space_error")
line 116:     syn match^IcSpaceError^Idisplay " \+\t"me=e-1
line 117:   endif
line 118: endif
line 119: 
line 120: " This should be before cErrInParen to avoid problems with #define ({ xxx })
line 121: if exists("c_curly_error")
line 122:   syn match cCurlyError "}"
line 123:   syn region^IcBlock^I^Istart="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell fold
line 124: else
line 125:   syn region^IcBlock^I^Istart="{" end="}" transparent fold
line 126: endif
line 127: 
line 128: " Catch errors caused by wrong parenthesis and brackets.
line 129: " Also accept <% for {, %> for }, <: for [ and :> for ] (C99)
line 130: " But avoid matching <::.
line 131: syn cluster^IcParenGroup^Icontains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
line 132: if exists("c_no_curly_error")
line 133:   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
line 134:     syn region^IcParen^I^Itransparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
line 135:     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
line 136:     syn region^IcCppParen^Itransparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
line 137:     syn match^IcParenError^Idisplay ")"
line 138:     syn match^IcErrInParen^Idisplay contained "^^<%\|^%>"
line 139:   else
line 140:     syn region^IcParen^I^Itransparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
line 141:     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
line 142:     syn region^IcCppParen^Itransparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
line 143:     syn match^IcParenError^Idisplay ")"
line 144:     syn match^IcErrInParen^Idisplay contained "^[{}]\|^<%\|^%>"
line 145:   endif
line 146: elseif exists("c_no_bracket_error")
line 147:   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
line 148:     syn region^IcParen^I^Itransparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
line 149:     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
line 150:     syn region^IcCppParen^Itransparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
line 151:     syn match^IcParenError^Idisplay ")"
line 152:     syn match^IcErrInParen^Idisplay contained "<%\|%>"
line 153:   else
line 154:     syn region^IcParen^I^Itransparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
line 155:     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
line 156:     syn region^IcCppParen^Itransparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
line 157:     syn match^IcParenError^Idisplay ")"
line 158:     syn match^IcErrInParen^Idisplay contained "[{}]\|<%\|%>"
line 159:   endif
line 160: else
line 161:   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
line 162:     syn region^IcParen^I^Itransparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
line 163:     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
line 164:     syn region^IcCppParen^Itransparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
line 165:     syn match^IcParenError^Idisplay "[\])]"
line 166:     syn match^IcErrInParen^Idisplay contained "<%\|%>"
line 167:     syn region^IcBracket^Itransparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
line 168:   else
line 169:     syn region^IcParen^I^Itransparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
line 170:     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
line 171:     syn region^IcCppParen^Itransparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
line 172:     syn match^IcParenError^Idisplay "[\])]"
line 173:     syn match^IcErrInParen^Idisplay contained "[\]{}]\|<%\|%>"
line 174:     syn region^IcBracket^Itransparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
line 175:   endif
line 176:   " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
line 177:   syn region^IcCppBracket^Itransparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
line 178:   syn match^IcErrInBracket^Idisplay contained "[);{}]\|<%\|%>"
line 179: endif
line 180: 
line 181: if s:ft ==# 'c' || exists("cpp_no_cpp11")
line 182:   syn region^IcBadBlock^Ikeepend start="{" end="}" contained containedin=cParen,cBracket,cBadBlock transparent fold
line 183: endif
line 184: 
line 185: "integer number, or floating point number without a dot and with "f".
line 186: syn case ignore
line 187: syn match^IcNumbers^Idisplay transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctalError,cOctal
line 188: " Same, but without octal error (for comments)
line 189: syn match^IcNumbersCom^Idisplay contained transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctal
line 190: syn match^IcNumber^I^Idisplay contained "\d\+\(u\=l\{0,2}\|ll\=u\)\>"
line 191: "hex number
line 192: syn match^IcNumber^I^Idisplay contained "0x\x\+\(u\=l\{0,2}\|ll\=u\)\>"
line 193: " Flag the first zero of an octal number as something special
line 194: syn match^IcOctal^I^Idisplay contained "0\o\+\(u\=l\{0,2}\|ll\=u\)\>" contains=cOctalZero
line 195: syn match^IcOctalZero^Idisplay contained "\<0"
line 196: syn match^IcFloat^I^Idisplay contained "\d\+f"
line 197: "floating point number, with dot, optional exponent
line 198: syn match^IcFloat^I^Idisplay contained "\d\+\.\d*\(e[-+]\=\d\+\)\=[fl]\="
line 199: "floating point number, starting with a dot, optional exponent
line 200: syn match^IcFloat^I^Idisplay contained "\.\d\+\(e[-+]\=\d\+\)\=[fl]\=\>"
line 201: "floating point number, without dot, with exponent
line 202: syn match^IcFloat^I^Idisplay contained "\d\+e[-+]\=\d\+[fl]\=\>"
line 203: if !exists("c_no_c99")
line 204:   "hexadecimal floating point number, optional leading digits, with dot, with exponent
line 205:   syn match^IcFloat^I^Idisplay contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
line 206:   "hexadecimal floating point number, with leading digits, optional dot, with exponent
line 207:   syn match^IcFloat^I^Idisplay contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"
line 208: endif
line 209: 
line 210: " flag an octal number with wrong digits
line 211: syn match^IcOctalError^Idisplay contained "0\o*[89]\d*"
line 212: syn case match
line 213: 
line 214: if exists("c_comment_strings")
line 215:   " A comment can contain cString, cCharacter and cNumber.
line 216:   " But a "*/" inside a cString in a cComment DOES end the comment!  So we
line 217:   " need to use a special type of cString: cCommentString, which also ends on
line 218:   " "*/", and sees a "*" at the start of the line as comment again.
line 219:   " Unfortunately this doesn't very well work for // type of comments :-(
line 220:   syn match^IcCommentSkip^Icontained "^\s*\*\($\|\s\+\)"
line 221:   syn region cCommentString^Icontained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=cSpecial,cCommentSkip
line 222:   syn region cComment2String^Icontained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=cSpecial
line 223:   syn region  cCommentL^Istart="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cComment2String,cCharacter,cNumbersCom,cSpaceError,cWrongComTail,@Spell
line 224:   if exists("c_no_comment_fold")
line 225:     " Use "extend" here to have preprocessor lines not terminate halfway a
line 226:     " comment.
line 227:     syn region cComment^Imatchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell extend
line 228:   else
line 229:     syn region cComment^Imatchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell fold extend
line 230:   endif
line 231: else
line 232:   syn region^IcCommentL^Istart="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cSpaceError,@Spell
line 233:   if exists("c_no_comment_fold")
line 234:     syn region^IcComment^Imatchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell extend
line 235:   else
line 236:     syn region^IcComment^Imatchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell fold extend
line 237:   endif
line 238: endif
line 239: " keep a // comment separately, it terminates a preproc. conditional
line 240: syn match^IcCommentError^Idisplay "\*/"
line 241: syn match^IcCommentStartError display "/\*"me=e-1 contained
line 242: syn match^IcWrongComTail^Idisplay "\*/"
line 243: 
line 244: syn keyword^IcOperator^Isizeof
line 245: if exists("c_gnu")
line 246:   syn keyword^IcStatement^I__asm__
line 247:   syn keyword^IcOperator^Itypeof __real__ __imag__
line 248: endif
line 249: syn keyword^IcType^I^Iint long short char void
line 250: syn keyword^IcType^I^Isigned unsigned float double
line 251: if !exists("c_no_ansi") || exists("c_ansi_typedefs")
line 252:   syn keyword   cType^I^Isize_t ssize_t off_t wchar_t ptrdiff_t sig_atomic_t fpos_t
line 253:   syn keyword   cType^I^Iclock_t time_t va_list jmp_buf FILE DIR div_t ldiv_t
line 254:   syn keyword   cType^I^Imbstate_t wctrans_t wint_t wctype_t
line 255: endif
line 256: if !exists("c_no_c99") " ISO C99
line 257:   syn keyword^IcType^I^I_Bool bool _Complex complex _Imaginary imaginary
line 258:   syn keyword^IcType^I^Iint8_t int16_t int32_t int64_t
line 259:   syn keyword^IcType^I^Iuint8_t uint16_t uint32_t uint64_t
line 260:   if !exists("c_no_bsd")
line 261:     " These are BSD specific.
line 262:     syn keyword^IcType^I^Iu_int8_t u_int16_t u_int32_t u_int64_t
line 263:   endif
line 264:   syn keyword^IcType^I^Iint_least8_t int_least16_t int_least32_t int_least64_t
line 265:   syn keyword^IcType^I^Iuint_least8_t uint_least16_t uint_least32_t uint_least64_t
line 266:   syn keyword^IcType^I^Iint_fast8_t int_fast16_t int_fast32_t int_fast64_t
line 267:   syn keyword^IcType^I^Iuint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
line 268:   syn keyword^IcType^I^Iintptr_t uintptr_t
line 269:   syn keyword^IcType^I^Iintmax_t uintmax_t
line 270: endif
line 271: if exists("c_gnu")
line 272:   syn keyword^IcType^I^I__label__ __complex__ __volatile__
line 273: endif
line 274: 
line 275: syn keyword^IcStructure^Istruct union enum typedef
line 276: syn keyword^IcStorageClass^Istatic register auto volatile extern const
line 277: if exists("c_gnu")
line 278:   syn keyword^IcStorageClass^Iinline __attribute__
line 279: endif
line 280: if !exists("c_no_c99") && s:ft !=# 'cpp'
line 281:   syn keyword^IcStorageClass^Iinline restrict
line 282: endif
line 283: if !exists("c_no_c11")
line 284:   syn keyword^IcStorageClass^I_Alignas alignas
line 285:   syn keyword^IcOperator^I_Alignof alignof
line 286:   syn keyword^IcStorageClass^I_Atomic
line 287:   syn keyword^IcOperator^I_Generic
line 288:   syn keyword^IcStorageClass^I_Noreturn noreturn
line 289:   syn keyword^IcOperator^I_Static_assert static_assert
line 290:   syn keyword^IcStorageClass^I_Thread_local thread_local
line 291:   syn keyword   cType^I^Ichar16_t char32_t
line 292: endif
line 293: 
line 294: if !exists("c_no_ansi") || exists("c_ansi_constants") || exists("c_gnu")
line 295:   if exists("c_gnu")
line 296:     syn keyword cConstant __GNUC__ __FUNCTION__ __PRETTY_FUNCTION__ __func__
line 297:   endif
line 298:   syn keyword cConstant __LINE__ __FILE__ __DATE__ __TIME__ __STDC__
line 299:   syn keyword cConstant __STDC_VERSION__
line 300:   syn keyword cConstant CHAR_BIT MB_LEN_MAX MB_CUR_MAX
line 301:   syn keyword cConstant UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
line 302:   syn keyword cConstant CHAR_MIN INT_MIN LONG_MIN SHRT_MIN
line 303:   syn keyword cConstant CHAR_MAX INT_MAX LONG_MAX SHRT_MAX
line 304:   syn keyword cConstant SCHAR_MIN SINT_MIN SLONG_MIN SSHRT_MIN
line 305:   syn keyword cConstant SCHAR_MAX SINT_MAX SLONG_MAX SSHRT_MAX
line 306:   if !exists("c_no_c99")
line 307:     syn keyword cConstant __func__ __VA_ARGS__
line 308:     syn keyword cConstant LLONG_MIN LLONG_MAX ULLONG_MAX
line 309:     syn keyword cConstant INT8_MIN INT16_MIN INT32_MIN INT64_MIN
line 310:     syn keyword cConstant INT8_MAX INT16_MAX INT32_MAX INT64_MAX
line 311:     syn keyword cConstant UINT8_MAX UINT16_MAX UINT32_MAX UINT64_MAX
line 312:     syn keyword cConstant INT_LEAST8_MIN INT_LEAST16_MIN INT_LEAST32_MIN INT_LEAST64_MIN
line 313:     syn keyword cConstant INT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST64_MAX
line 314:     syn keyword cConstant UINT_LEAST8_MAX UINT_LEAST16_MAX UINT_LEAST32_MAX UINT_LEAST64_MAX
line 315:     syn keyword cConstant INT_FAST8_MIN INT_FAST16_MIN INT_FAST32_MIN INT_FAST64_MIN
line 316:     syn keyword cConstant INT_FAST8_MAX INT_FAST16_MAX INT_FAST32_MAX INT_FAST64_MAX
line 317:     syn keyword cConstant UINT_FAST8_MAX UINT_FAST16_MAX UINT_FAST32_MAX UINT_FAST64_MAX
line 318:     syn keyword cConstant INTPTR_MIN INTPTR_MAX UINTPTR_MAX
line 319:     syn keyword cConstant INTMAX_MIN INTMAX_MAX UINTMAX_MAX
line 320:     syn keyword cConstant PTRDIFF_MIN PTRDIFF_MAX SIG_ATOMIC_MIN SIG_ATOMIC_MAX
line 321:     syn keyword cConstant SIZE_MAX WCHAR_MIN WCHAR_MAX WINT_MIN WINT_MAX
line 322:   endif
line 323:   syn keyword cConstant FLT_RADIX FLT_ROUNDS FLT_DIG FLT_MANT_DIG FLT_EPSILON DBL_DIG DBL_MANT_DIG DBL_EPSILON
line 324:   syn keyword cConstant LDBL_DIG LDBL_MANT_DIG LDBL_EPSILON FLT_MIN FLT_MAX FLT_MIN_EXP FLT_MAX_EXP FLT_MIN_10_EXP FLT_MAX_10_EXP
line 325:   syn keyword cConstant DBL_MIN DBL_MAX DBL_MIN_EXP DBL_MAX_EXP DBL_MIN_10_EXP DBL_MAX_10_EXP LDBL_MIN LDBL_MAX LDBL_MIN_EXP LDBL_MAX_EXP
line 326:   syn keyword cConstant LDBL_MIN_10_EXP LDBL_MAX_10_EXP HUGE_VAL CLOCKS_PER_SEC NULL LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY
line 327:   syn keyword cConstant LC_NUMERIC LC_TIME SIG_DFL SIG_ERR SIG_IGN SIGABRT SIGFPE SIGILL SIGHUP SIGINT SIGSEGV SIGTERM
line 328:   " Add POSIX signals as well...
line 329:   syn keyword cConstant SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
line 330:   syn keyword cConstant SIGSTOP SIGTERM SIGTRAP SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2
line 331:   syn keyword cConstant _IOFBF _IOLBF _IONBF BUFSIZ EOF WEOF FOPEN_MAX FILENAME_MAX L_tmpnam
line 332:   syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET TMP_MAX stderr stdin stdout EXIT_FAILURE EXIT_SUCCESS RAND_MAX
line 333:   " POSIX 2001
line 334:   syn keyword cConstant SIGBUS SIGPOLL SIGPROF SIGSYS SIGURG SIGVTALRM SIGXCPU SIGXFSZ
line 335:   " non-POSIX signals
line 336:   syn keyword cConstant SIGWINCH SIGINFO
line 337:   " Add POSIX errors as well.  List comes from:
line 338:   " http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
line 339:   syn keyword cConstant E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY EBADF
line 340:   syn keyword cConstant EBADMSG EBUSY ECANCELED ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
line 341:   syn keyword cConstant EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTUNREACH EIDRM EILSEQ
line 342:   syn keyword cConstant EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE
line 343:   syn keyword cConstant EMULTIHOP ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS ENODATA
line 344:   syn keyword cConstant ENODEV ENOENT ENOEXEC ENOLCK ENOLINK ENOMEM ENOMSG ENOPROTOOPT ENOSPC ENOSR
line 345:   syn keyword cConstant ENOSTR ENOSYS ENOTBLK ENOTCONN ENOTDIR ENOTEMPTY ENOTRECOVERABLE ENOTSOCK ENOTSUP
line 346:   syn keyword cConstant ENOTTY ENXIO EOPNOTSUPP EOVERFLOW EOWNERDEAD EPERM EPIPE EPROTO
line 347:   syn keyword cConstant EPROTONOSUPPORT EPROTOTYPE ERANGE EROFS ESPIPE ESRCH ESTALE ETIME ETIMEDOUT
line 348:   syn keyword cConstant ETXTBSY EWOULDBLOCK EXDEV
line 349:   " math.h
line 350:   syn keyword cConstant M_E M_LOG2E M_LOG10E M_LN2 M_LN10 M_PI M_PI_2 M_PI_4
line 351:   syn keyword cConstant M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2
line 352: endif
line 353: if !exists("c_no_c99") " ISO C99
line 354:   syn keyword cConstant true false
line 355: endif
line 356: 
line 357: " Accept %: for # (C99)
line 358: syn region^IcPreCondit^Istart="^\s*\zs\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" keepend contains=cComment,cCommentL,cCppString,cCharacter,cCppParen,cParenError,cNumbers,cCommentError,cSpaceError
line 359: syn match^IcPreConditMatch^Idisplay "^\s*\zs\(%:\|#\)\s*\(else\|endif\)\>"
line 360: if !exists("c_no_if0")
line 361:   syn cluster^IcCppOutInGroup^Icontains=cCppInIf,cCppInElse,cCppInElse2,cCppOutIf,cCppOutIf2,cCppOutElse,cCppInSkip,cCppOutSkip
line 362:   syn region^IcCppOutWrapper^Istart="^\s*\zs\(%:\|#\)\s*if\s\+0\+\s*\($\|//\|/\*\|&\)" end=".\@=\|$" contains=cCppOutIf,cCppOutElse,@NoSpell fold
line 363:   syn region^IcCppOutIf^Icontained start="0\+" matchgroup=cCppOutWrapper end="^\s*\(%:\|#\)\s*endif\>" contains=cCppOutIf2,cCppOutElse
line 364:   if !exists("c_no_if0_fold")
line 365:     syn region^IcCppOutIf2^Icontained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell fold
line 366:   else
line 367:     syn region^IcCppOutIf2^Icontained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
line 368:   endif
line 369:   syn region^IcCppOutElse^Icontained matchgroup=cCppOutWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=TOP,cPreCondit
line 370:   syn region^IcCppInWrapper^Istart="^\s*\zs\(%:\|#\)\s*if\s\+0*[1-9]\d*\s*\($\|//\|/\*\||\)" end=".\@=\|$" contains=cCppInIf,cCppInElse fold
line 371:   syn region^IcCppInIf^Icontained matchgroup=cCppInWrapper start="\d\+" end="^\s*\(%:\|#\)\s*endif\>" contains=TOP,cPreCondit
line 372:   if !exists("c_no_if0_fold")
line 373:     syn region^IcCppInElse^Icontained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2 fold
line 374:   else
line 375:     syn region^IcCppInElse^Icontained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2
line 376:   endif
line 377:   syn region^IcCppInElse2^Icontained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)\([^/]\|/[^/*]\)*" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
line 378:   syn region^IcCppOutSkip^Icontained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppOutSkip
line 379:   syn region^IcCppInSkip^Icontained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(if\s\+\(\d\+\s*\($\|//\|/\*\||\|&\)\)\@!\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" containedin=cCppOutElse,cCppInIf,cCppInSkip contains=TOP,cPreProc
line 380: endif
line 381: syn region^IcIncluded^Idisplay contained start=+"+ skip=+\\\\\|\\"+ end=+"+
line 382: syn match^IcIncluded^Idisplay contained "<[^>]*>"
line 383: syn match^IcInclude^Idisplay "^\s*\zs\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
line 384: "syn match cLineSkip^I"\\$"
line 385: syn cluster^IcPreProcGroup^Icontains=cPreCondit,cIncluded,cInclude,cDefine,cErrInParen,cErrInBracket,cUserLabel,cSpecial,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cString,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cParen,cBracket,cMulti,cBadBlock
line 386: syn region^IcDefine^I^Istart="^\s*\zs\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
line 387: syn region^IcPreProc^Istart="^\s*\zs\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
line 388: 
line 389: " Optional embedded Autodoc parsing
line 390: if exists("c_autodoc")
line 391:   syn match cAutodocReal display contained "\%(//\|[/ \t\v]\*\|^\*\)\@2<=!.*" contains=@cAutodoc containedin=cComment,cCommentL
line 392:   syn cluster cCommentGroup add=cAutodocReal
line 393:   syn cluster cPreProcGroup add=cAutodocReal
line 394: endif
line 395: 
line 396: " Highlight User Labels
line 397: syn cluster^IcMultiGroup^Icontains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
line 398: if s:ft ==# 'c' || exists("cpp_no_cpp11")
line 399:   syn region^IcMulti^I^Itransparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell,@cStringGroup
line 400: endif
line 401: " Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
line 402: syn cluster^IcLabelGroup^Icontains=cUserLabel
line 403: syn match^IcUserCont^Idisplay "^\s*\zs\I\i*\s*:$" contains=@cLabelGroup
line 404: syn match^IcUserCont^Idisplay ";\s*\zs\I\i*\s*:$" contains=@cLabelGroup
line 405: if s:ft ==# 'cpp'
line 406:   syn match^IcUserCont^Idisplay "^\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
line 407:   syn match^IcUserCont^Idisplay ";\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
line 408: else
line 409:   syn match^IcUserCont^Idisplay "^\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
line 410:   syn match^IcUserCont^Idisplay ";\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
line 411: endif
line 412: 
line 413: syn match^IcUserLabel^Idisplay "\I\i*" contained
line 414: 
line 415: " Avoid recognizing most bitfields as labels
line 416: syn match^IcBitField^Idisplay "^\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
line 417: syn match^IcBitField^Idisplay ";\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
line 418: 
line 419: if exists("c_minlines")
line 420:   let b:c_minlines = c_minlines
line 421: else
line 422:   if !exists("c_no_if0")
line 423:     let b:c_minlines = 50^I" #if 0 constructs can be long
line 424:   else
line 425:     let b:c_minlines = 15^I" mostly for () constructs
line 426:   endif
line 427: endif
line 428: if exists("c_curly_error")
line 429:   syn sync fromstart
line 430: else
line 431:   exec "syn sync ccomment cComment minlines=" . b:c_minlines
line 431: syn sync ccomment cComment minlines=50
line 432: endif
line 433: 
line 434: " Define the default highlighting.
line 435: " Only used when an item doesn't have highlighting yet
line 436: hi def link cFormat^I^IcSpecial
line 437: hi def link cCppString^I^IcString
line 438: hi def link cCommentL^I^IcComment
line 439: hi def link cCommentStart^IcComment
line 440: hi def link cLabel^I^ILabel
line 441: hi def link cUserLabel^I^ILabel
line 442: hi def link cConditional^IConditional
line 443: hi def link cRepeat^I^IRepeat
line 444: hi def link cCharacter^I^ICharacter
line 445: hi def link cSpecialCharacter^IcSpecial
line 446: hi def link cNumber^I^INumber
line 447: hi def link cOctal^I^INumber
line 448: hi def link cOctalZero^I^IPreProc^I " link this to Error if you want
line 449: hi def link cFloat^I^IFloat
line 450: hi def link cOctalError^I^IcError
line 451: hi def link cParenError^I^IcError
line 452: hi def link cErrInParen^I^IcError
line 453: hi def link cErrInBracket^IcError
line 454: hi def link cCommentError^IcError
line 455: hi def link cCommentStartError^IcError
line 456: hi def link cSpaceError^I^IcError
line 457: hi def link cWrongComTail^IcError
line 458: hi def link cSpecialError^IcError
line 459: hi def link cCurlyError^I^IcError
line 460: hi def link cOperator^I^IOperator
line 461: hi def link cStructure^I^IStructure
line 462: hi def link cStorageClass^IStorageClass
line 463: hi def link cInclude^I^IInclude
line 464: hi def link cPreProc^I^IPreProc
line 465: hi def link cDefine^I^IMacro
line 466: hi def link cIncluded^I^IcString
line 467: hi def link cError^I^IError
line 468: hi def link cStatement^I^IStatement
line 469: hi def link cCppInWrapper^IcCppOutWrapper
line 470: hi def link cCppOutWrapper^IcPreCondit
line 471: hi def link cPreConditMatch^IcPreCondit
line 472: hi def link cPreCondit^I^IPreCondit
line 473: hi def link cType^I^IType
line 474: hi def link cConstant^I^IConstant
line 475: hi def link cCommentString^IcString
line 476: hi def link cComment2String^IcString
line 477: hi def link cCommentSkip^IcComment
line 478: hi def link cString^I^IString
line 479: hi def link cComment^I^IComment
line 480: hi def link cSpecial^I^ISpecialChar
line 481: hi def link cTodo^I^ITodo
line 482: hi def link cBadContinuation^IError
line 483: hi def link cCppOutSkip^I^IcCppOutIf2
line 484: hi def link cCppInElse2^I^IcCppOutIf2
line 485: hi def link cCppOutIf2^I^IcCppOut
line 486: hi def link cCppOut^I^IComment
line 487: 
line 488: let b:current_syntax = "c"
line 489: 
line 490: unlet s:ft
line 491: 
line 492: let &cpo = s:cpo_save
line 493: unlet s:cpo_save
line 494: " vim: ts=8
finished sourcing /usr/share/vim/vim81/syntax/c.vim
continuing in /usr/share/vim/vim81/syntax/cpp.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/c.vim"
Searching for "/home/w/.vim/after/syntax/c.vim"
line 14: unlet b:current_syntax
line 15: 
line 16: " C++ extensions
line 17: syn keyword cppStatement^Inew delete this friend using
line 18: syn keyword cppAccess^I^Ipublic protected private
line 19: syn keyword cppModifier^I^Iinline virtual explicit export
line 20: syn keyword cppType^I^Ibool wchar_t
line 21: syn keyword cppExceptions^Ithrow try catch
line 22: syn keyword cppOperator^I^Ioperator typeid
line 23: syn keyword cppOperator^I^Iand bitor or xor compl bitand and_eq or_eq xor_eq not not_eq
line 24: syn match cppCast^I^I"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*<"me=e-1
line 25: syn match cppCast^I^I"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*$"
line 26: syn keyword cppStorageClass^Imutable
line 27: syn keyword cppStructure^Iclass typename template namespace
line 28: syn keyword cppBoolean^I^Itrue false
line 29: syn keyword cppConstant^I^I__cplusplus
line 30: 
line 31: " C++ 11 extensions
line 32: if !exists("cpp_no_cpp11")
line 33:   syn keyword cppModifier^Ioverride final
line 34:   syn keyword cppType^I^Inullptr_t auto
line 35:   syn keyword cppExceptions^Inoexcept
line 36:   syn keyword cppStorageClass^Iconstexpr decltype thread_local
line 37:   syn keyword cppConstant^Inullptr
line 38:   syn keyword cppConstant^IATOMIC_FLAG_INIT ATOMIC_VAR_INIT
line 39:   syn keyword cppConstant^IATOMIC_BOOL_LOCK_FREE ATOMIC_CHAR_LOCK_FREE
line 40:   syn keyword cppConstant^IATOMIC_CHAR16_T_LOCK_FREE ATOMIC_CHAR32_T_LOCK_FREE
line 41:   syn keyword cppConstant^IATOMIC_WCHAR_T_LOCK_FREE ATOMIC_SHORT_LOCK_FREE
line 42:   syn keyword cppConstant^IATOMIC_INT_LOCK_FREE ATOMIC_LONG_LOCK_FREE
line 43:   syn keyword cppConstant^IATOMIC_LLONG_LOCK_FREE ATOMIC_POINTER_LOCK_FREE
line 44:   syn region cppRawString^Imatchgroup=cppRawStringDelimiter start=+\%(u8\|[uLU]\)\=R"\z([[:alnum:]_{}[\]#<>%:;.?*\+\-/\^&|~!=,"']\{,16}\)(+ end=+)\z1"+ contains=@Spell
line 45: endif
line 46: 
line 47: " C++ 14 extensions
line 48: if !exists("cpp_no_cpp14")
line 49:   syn case ignore
line 50:   syn match cppNumber^I^Idisplay "\<0b[01]\('\=[01]\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
line 51:   syn match cppNumber^I^Idisplay "\<[1-9]\('\=\d\+\)*\(u\=l\{0,2}\|ll\=u\)\>" contains=cFloat
line 52:   syn match cppNumber^I^Idisplay "\<0x\x\('\=\x\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
line 53:   syn case match
line 54: endif
line 55: 
line 56: " The minimum and maximum operators in GNU C++
line 57: syn match cppMinMax "[<>]?"
line 58: 
line 59: " Default highlighting
line 60: hi def link cppAccess^I^IcppStatement
line 61: hi def link cppCast^I^IcppStatement
line 62: hi def link cppExceptions^I^IException
line 63: hi def link cppOperator^I^IOperator
line 64: hi def link cppStatement^I^IStatement
line 65: hi def link cppModifier^I^IType
line 66: hi def link cppType^I^IType
line 67: hi def link cppStorageClass^IStorageClass
line 68: hi def link cppStructure^I^IStructure
line 69: hi def link cppBoolean^I^IBoolean
line 70: hi def link cppConstant^I^IConstant
line 71: hi def link cppRawStringDelimiter^IDelimiter
line 72: hi def link cppRawString^I^IString
line 73: hi def link cppNumber^I^INumber
line 74: 
line 75: let b:current_syntax = "cpp"
line 76: 
line 77: " vim: ts=8
finished sourcing /usr/share/vim/vim81/syntax/cpp.vim
continuing in function <SNR>3_SynSet
Searching for "/usr/share/vim/vim81/syntax/cpp/*.vim"
Searching for "/usr/share/vim/vimfiles/after/syntax/cpp.vim"
Searching for "/usr/share/vim/vimfiles/after/syntax/cpp/*.vim"
Searching for "/home/w/.vim/after/syntax/cpp.vim"
Searching for "/home/w/.vim/after/syntax/cpp/*.vim"
line 25:     endfor
line 23:     for name in split(s, '\.')
line 24:       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 25:     endfor
line 26:   endif
function <SNR>3_SynSet returning #0

continuing in Syntax Autocommands for "*"

Executing Syntax Autocommands for "cpp"
autocommand if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif

line 0: if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 0:  runtime! syntax/doxygen.vim | endif
line 0:  endif
Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

line 0: call s:LoadIndent()
calling function <SNR>11_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14: ^Iexe 'runtime! indent/' . name . '.vim'
line 14: runtime! indent/cpp.vim
Searching for "indent/cpp.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/indent/cpp.vim"
Searching for "/home/w/.vim/bundle/nerdtree/indent/cpp.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/indent/cpp.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/indent/cpp.vim"
Searching for "/usr/share/vim/vimfiles/indent/cpp.vim"
Searching for "/usr/share/vim/vim81/indent/cpp.vim"
chdir(/usr/share/vim/vim81/indent)
fchdir() to previous dir
line 14: sourcing "/usr/share/vim/vim81/indent/cpp.vim"
line 1: " Vim indent file
line 2: " Language:^IC++
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Nov 29
line 5: 
line 6: " Only load this indent file when no other was loaded.
line 7: if exists("b:did_indent")
line 8:    finish
line 9: endif
line 10: let b:did_indent = 1
line 11: 
line 12: " C++ indenting is built-in, thus this is very simple
line 13: setlocal cindent
line 14: 
line 15: let b:undo_indent = "setl cin<"
finished sourcing /usr/share/vim/vim81/indent/cpp.vim
continuing in function <SNR>11_LoadIndent
Searching for "/usr/share/vim/vimfiles/after/indent/cpp.vim"
Searching for "/home/w/.vim/after/indent/cpp.vim"
line 15:       endfor
line 13:       for name in split(s, '\.')
line 14: ^Iexe 'runtime! indent/' . name . '.vim'
line 15:       endfor
line 16:     endif
function <SNR>11_LoadIndent returning #0

continuing in FileType Autocommands for "*"

line 0: endif
Executing BufRead Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 0:  runtime! scripts.vim | endif
line 0:  endif
Executing BufRead Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 0:    setf FALLBACK conf | endif
line 0:  endif
Executing BufRead Autocommands for "*"
autocommand call <SID>BufReadHandler()

line 0: call <SID>BufReadHandler()
calling function <SNR>32_BufReadHandler()

line 1:   " Refresh NERDTree to show currently opened file
line 2:   if g:nerdtree_tabs_autofind
line 3:     call s:NERDTreeFindFile()
line 4:     call s:NERDTreeUnfocus()
line 5:   endif
function <SNR>32_BufReadHandler returning #0

continuing in BufRead Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand call <SID>BufWinEnterHandler()

line 0: call <SID>BufWinEnterHandler()
calling function <SNR>32_BufWinEnterHandler()

line 1:   if s:NewTabCreated
line 2:     " Turn off the 'NewTabCreated' flag
line 3:     let s:NewTabCreated = 0
line 4: 
line 5:     " Restore focus to NERDTree if necessary
line 6:     if !g:nerdtree_tabs_focus_on_files
line 7:       call s:NERDTreeRestoreFocus()
line 8:     endif
line 9:   endif
function <SNR>32_BufWinEnterHandler returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('/home/w/repo/inz/kernel/main/kmain.cpp')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

line 0: sil call s:LocalBrowse(expand("<amatch>"))
calling function <SNR>39_LocalBrowse('/home/w/repo/inz/kernel/main/kmain.cpp')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4:   
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
function <SNR>39_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand silent! autocmd! FileExplorer

line 0: silent! autocmd! FileExplorer
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('/home/w/repo/inz/kernel/main/kmain.cpp')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand call <SID>VimEnterHandler()

line 0: call <SID>VimEnterHandler()
calling function <SNR>32_VimEnterHandler()

line 1:   let l:open_nerd_tree_on_startup = (g:nerdtree_tabs_open_on_console_startup == 1 && !has('gui_running')) || (g:nerdtree_tabs_open_on_gui_startup == 1 && has('gui_running'))
line 3: 
line 4:   let l:open_directory_on_startup = isdirectory(argv(0)) && ((g:nerdtree_tabs_open_on_console_startup == 2 && !has('gui_running')) || (g:nerdtree_tabs_open_on_gui_startup == 2 && has('gui_running')))
line 7: 
line 8:   if g:nerdtree_tabs_no_startup_for_diff && &diff
line 9:       let l:open_nerd_tree_on_startup = 0
line 10:   endif
line 11: 
line 12:   " this makes sure that globally_active is true when using 'gvim .'
line 13:   let s:nerdtree_globally_active = l:open_nerd_tree_on_startup
line 14: 
line 15:   " if the argument to vim is a directory, cd into it
line 16:   if l:open_directory_on_startup || g:nerdtree_tabs_startup_cd && isdirectory(argv(0))
line 17:     exe 'cd ' . escape(argv(0), '\ ')
line 18:   endif
line 19: 
line 20: 
line 21:   if l:open_nerd_tree_on_startup || l:open_directory_on_startup
line 22:     let l:focus_file = !s:IfFocusOnStartup()
line 23:     let l:main_bufnr = bufnr('%')
line 24: 
line 25:     if !s:IsNERDTreePresentInCurrentTab()
line 26:       call s:NERDTreeOpenAllTabs()
line 27:     endif
line 28: 
line 29:     if (l:focus_file && g:nerdtree_tabs_smart_startup_focus == 1) || g:nerdtree_tabs_smart_startup_focus == 2 || l:open_directory_on_startup
line 32:       exe bufwinnr(l:main_bufnr) . "wincmd w"
line 33:     endif
line 34: 
line 35:     if l:open_directory_on_startup
line 36:       " close buffer not connected to NERDTree and open connected one
line 37:       new
line 38:       exe bufwinnr(l:main_bufnr) . "wincmd w"
line 39:       quit
line 40: 
line 41:       if g:nerdtree_tabs_smart_startup_focus != 2
line 42:         NERDTreeFocus
line 43:       endif
line 44:     endif
line 45:     if g:nerdtree_tabs_autofind
line 46:       call s:NERDTreeFindFile()
line 47:       call s:NERDTreeUnfocus()
line 48:     endif
line 49:   endif
function <SNR>32_VimEnterHandler returning #0

continuing in VimEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
line 37:     endif
line 38:   endif
line 39: 
line 40:   " Figure out the arguments for searchpairpos().
line 41:   if i % 2 == 0
line 42:     let s_flags = 'nW'
line 43:     let c2 = plist[i + 1]
line 44:   else
line 45:     let s_flags = 'nbW'
line 46:     let c2 = c
line 47:     let c = plist[i - 1]
line 48:   endif
line 49:   if c == '['
line 50:     let c = '\['
line 51:     let c2 = '\]'
line 52:   endif
line 53: 
line 54:   " Find the match.  When it was just before the cursor move it there for a
line 55:   " moment.
line 56:   if before > 0
line 57:     let has_getcurpos = exists("*getcurpos")
line 58:     if has_getcurpos
line 59:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 60:       let save_cursor = getcurpos()
line 61:     else
line 62:       let save_cursor = winsaveview()
line 63:     endif
line 64:     call cursor(c_lnum, c_col - before)
line 65:   endif
line 66: 
line 67:   if !has("syntax") || !exists("g:syntax_on")
line 68:     let s_skip = "0"
line 69:   else
line 70:     " Build an expression that detects whether the current cursor position is
line 71:     " in certain syntax types (string, comment, etc.), for use as
line 72:     " searchpairpos()'s skip argument.
line 73:     " We match "escape" for special items, such as lispEscapeSpecial.
line 74:     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
line 76:     " If executing the expression determines that the cursor is currently in
line 77:     " one of the syntax types, then we want searchpairpos() to find the pair
line 78:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 79:     " outside of the syntax types and s_skip should keep its value so we skip
line 80:     " any matching pair inside the syntax types.
line 81:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 82:     try
line 83:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 83: if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"')) | let s_skip = "0" | endif
line 83:  let s_skip = "0" | endif
line 83:  endif
line 84:     catch /^Vim\%((\a\+)\)\=:E363/
line 85:       " We won't find anything, so skip searching, should keep Vim responsive.
line 86:       return
line 87:     endtry
line 88:   endif
line 89: 
line 90:   " Limit the search to lines visible in the window.
line 91:   let stoplinebottom = line('w$')
line 92:   let stoplinetop = line('w0')
line 93:   if i % 2 == 0
line 94:     let stopline = stoplinebottom
line 95:   else
line 96:     let stopline = stoplinetop
line 97:   endif
line 98: 
line 99:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 100:   " This fails when a timeout is not supported.
line 101:   if mode() == 'i' || mode() == 'R'
line 102:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 103:   else
line 104:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 105:   endif
line 106:   try
line 107:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 108:   catch /E118/
line 109:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 110:     " a long time on closed folds and long lines.
line 111:     " The "viewable" variables give a range in which we can scroll while
line 112:     " keeping the cursor at the same position.
line 113:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 114:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 115:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 116:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 117:     " one of these stoplines will be adjusted below, but the current values are
line 118:     " minimal boundaries within the current window
line 119:     if i % 2 == 0
line 120:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 121: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 122: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 123:       else
line 124: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 125:       endif
line 126:       let stoplinebottom = stopline
line 127:     else
line 128:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 129: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 130: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 131:       else
line 132: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 133:       endif
line 134:       let stoplinetop = stopline
line 135:     endif
line 136:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 137:   endtry
line 138: 
line 139:   if before > 0
line 140:     if has_getcurpos
line 141:       call setpos('.', save_cursor)
line 142:     else
line 143:       call winrestview(save_cursor)
line 144:     endif
line 145:   endif
line 146: 
line 147:   " If a match is found setup match highlighting.
line 148:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 149:     if exists('*matchaddpos')
line 150:       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
line 151:     else
line 152:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 154:     endif
line 155:     let w:paren_hl_on = 1
line 156:   endif
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
line 37:     endif
line 38:   endif
line 39: 
line 40:   " Figure out the arguments for searchpairpos().
line 41:   if i % 2 == 0
line 42:     let s_flags = 'nW'
line 43:     let c2 = plist[i + 1]
line 44:   else
line 45:     let s_flags = 'nbW'
line 46:     let c2 = c
line 47:     let c = plist[i - 1]
line 48:   endif
line 49:   if c == '['
line 50:     let c = '\['
line 51:     let c2 = '\]'
line 52:   endif
line 53: 
line 54:   " Find the match.  When it was just before the cursor move it there for a
line 55:   " moment.
line 56:   if before > 0
line 57:     let has_getcurpos = exists("*getcurpos")
line 58:     if has_getcurpos
line 59:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 60:       let save_cursor = getcurpos()
line 61:     else
line 62:       let save_cursor = winsaveview()
line 63:     endif
line 64:     call cursor(c_lnum, c_col - before)
line 65:   endif
line 66: 
line 67:   if !has("syntax") || !exists("g:syntax_on")
line 68:     let s_skip = "0"
line 69:   else
line 70:     " Build an expression that detects whether the current cursor position is
line 71:     " in certain syntax types (string, comment, etc.), for use as
line 72:     " searchpairpos()'s skip argument.
line 73:     " We match "escape" for special items, such as lispEscapeSpecial.
line 74:     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
line 76:     " If executing the expression determines that the cursor is currently in
line 77:     " one of the syntax types, then we want searchpairpos() to find the pair
line 78:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 79:     " outside of the syntax types and s_skip should keep its value so we skip
line 80:     " any matching pair inside the syntax types.
line 81:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 82:     try
line 83:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 83: if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"')) | let s_skip = "0" | endif
line 83:  let s_skip = "0" | endif
line 83:  endif
line 84:     catch /^Vim\%((\a\+)\)\=:E363/
line 85:       " We won't find anything, so skip searching, should keep Vim responsive.
line 86:       return
line 87:     endtry
line 88:   endif
line 89: 
line 90:   " Limit the search to lines visible in the window.
line 91:   let stoplinebottom = line('w$')
line 92:   let stoplinetop = line('w0')
line 93:   if i % 2 == 0
line 94:     let stopline = stoplinebottom
line 95:   else
line 96:     let stopline = stoplinetop
line 97:   endif
line 98: 
line 99:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 100:   " This fails when a timeout is not supported.
line 101:   if mode() == 'i' || mode() == 'R'
line 102:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 103:   else
line 104:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 105:   endif
line 106:   try
line 107:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 108:   catch /E118/
line 109:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 110:     " a long time on closed folds and long lines.
line 111:     " The "viewable" variables give a range in which we can scroll while
line 112:     " keeping the cursor at the same position.
line 113:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 114:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 115:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 116:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 117:     " one of these stoplines will be adjusted below, but the current values are
line 118:     " minimal boundaries within the current window
line 119:     if i % 2 == 0
line 120:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 121: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 122: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 123:       else
line 124: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 125:       endif
line 126:       let stoplinebottom = stopline
line 127:     else
line 128:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 129: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 130: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 131:       else
line 132: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 133:       endif
line 134:       let stoplinetop = stopline
line 135:     endif
line 136:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 137:   endtry
line 138: 
line 139:   if before > 0
line 140:     if has_getcurpos
line 141:       call setpos('.', save_cursor)
line 142:     else
line 143:       call winrestview(save_cursor)
line 144:     endif
line 145:   endif
line 146: 
line 147:   " If a match is found setup match highlighting.
line 148:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 149:     if exists('*matchaddpos')
line 150:       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
line 151:     else
line 152:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 154:     endif
line 155:     let w:paren_hl_on = 1
line 156:   endif
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"


calling function <SNR>32_NERDTreeToggleAllTabs()

line 1:   let l:nerdtree_open = s:IsNERDTreeOpenInCurrentTab()
calling function <SNR>32_NERDTreeToggleAllTabs[1]..<SNR>32_IsNERDTreeOpenInCurrentTab()

line 1:   return exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1
function <SNR>32_NERDTreeToggleAllTabs[1]..<SNR>32_IsNERDTreeOpenInCurrentTab returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs

line 2:   let s:disable_handlers_for_tabdo = 1
line 3: 
line 4:   if l:nerdtree_open
line 5:     call s:NERDTreeCloseAllTabs()
line 6:   else
line 7:     call s:NERDTreeOpenAllTabs()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs()

line 1:   let s:nerdtree_globally_active = 1
line 2: 
line 3:   " tabdo doesn't preserve current tab - save it and restore it afterwards
line 4:   let l:current_tab = tabpagenr()
line 5:   tabdo call s:NERDTreeMirrorOrCreate()
line 5: call s:NERDTreeMirrorOrCreate()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate()

line 1:   let l:nerdtree_open = s:IsNERDTreeOpenInCurrentTab()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[1]..<SNR>32_IsNERDTreeOpenInCurrentTab()

line 1:   return exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[1]..<SNR>32_IsNERDTreeOpenInCurrentTab returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate

line 2: 
line 3:   " if NERDTree is not active in the current tab, try to mirror it
line 4:   if !l:nerdtree_open
line 5:     let l:previous_winnr = winnr("$")
line 6: 
line 7:     silent NERDTreeMirror
line 7: call g:NERDTreeCreator.CreateMirror()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194()

line 1:     let creator = s:Creator.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[1]..198()

line 1:     let newCreator = copy(self)
line 2:     return newCreator
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[1]..198 returning {'_createNERDTree': function('193'), '...00'), '_bindMappings': function('186')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194

line 2:     call creator.createMirror()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195()

line 1:     "get the names off all the nerd tree buffers
line 2:     let treeBufNames = []
line 3:     for i in range(1, tabpagenr("$"))
line 4:         let nextName = self._tabpagevar(i, 'NERDTreeBufName')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195[4]..205(1, 'NERDTreeBufName')

line 1:     let currentTab = tabpagenr()
line 2:     let old_ei = &ei
line 3:     set ei=all
line 4: 
line 5:     exec "tabnext " . a:tabnr
line 5: tabnext 1
line 6:     let v = -1
line 7:     if exists('t:' . a:var)
line 8:         exec 'let v = t:' . a:var
line 9:     endif
line 10:     exec "tabnext " . currentTab
line 10: tabnext 1
line 11: 
line 12:     let &ei = old_ei
line 13: 
line 14:     return v
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195[4]..205 returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195

line 5:         if nextName != -1 && (!exists("t:NERDTreeBufName") || nextName != t:NERDTreeBufName)
line 6:             call add(treeBufNames, nextName)
line 7:         endif
line 8:     endfor
line 3:     for i in range(1, tabpagenr("$"))
line 4:         let nextName = self._tabpagevar(i, 'NERDTreeBufName')
line 5:         if nextName != -1 && (!exists("t:NERDTreeBufName") || nextName != t:NERDTreeBufName)
line 6:             call add(treeBufNames, nextName)
line 7:         endif
line 8:     endfor
line 9:     let treeBufNames = self._uniq(treeBufNames)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195[9]..208([])

line 1:   let uniqlist = []
line 2:   for elem in a:list
line 3:     if index(uniqlist, elem) ==# -1
line 4:       let uniqlist += [elem]
line 5:     endif
line 6:   endfor
line 7:   return uniqlist
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195[9]..208 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195

line 10: 
line 11:     "map the option names (that the user will be prompted with) to the nerd
line 12:     "tree buffer names
line 13:     let options = {}
line 14:     let i = 0
line 15:     while i < len(treeBufNames)
line 16:         let bufName = treeBufNames[i]
line 17:         let treeRoot = getbufvar(bufName, "NERDTree").root
line 18:         let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
line 19:         let i = i + 1
line 20:     endwhile
line 21: 
line 22:     "work out which tree to mirror, if there is more than 1 then ask the user
line 23:     let bufferName = ''
line 24:     if len(keys(options)) > 1
line 25:         let choices = ["Choose a tree to mirror"]
line 26:         let choices = extend(choices, sort(keys(options)))
line 27:         let choice = inputlist(choices)
line 28:         if choice < 1 || choice > len(options) || choice ==# ''
line 29:             return
line 30:         endif
line 31: 
line 32:         let bufferName = options[sort(keys(options))[choice-1]]
line 33:     elseif len(keys(options)) ==# 1
line 34:         let bufferName = values(options)[0]
line 35:     else
line 36:         call nerdtree#echo("No trees to mirror")
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195[36]..nerdtree#echo('No trees to mirror')

line 1:     redraw
line 2:     echomsg empty(a:msg) ? "" : ("NERDTree: " . a:msg)
NERDTree: No trees to mirror
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195[36]..nerdtree#echo returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195

line 37:         return
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194[2]..195 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[7]..194 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate

line 8: 
line 9:     " if the window count of current tab didn't increase after NERDTreeMirror,
line 10:     " it means NERDTreeMirror was unsuccessful and a new NERDTree has to be created
line 11:     if l:previous_winnr == winnr("$")
line 12:       silent NERDTreeToggle
line 12: :call g:NERDTreeCreator.ToggleTabTree('')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206('')

line 1:     let creator = s:Creator.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[1]..198()

line 1:     let newCreator = copy(self)
line 2:     return newCreator
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[1]..198 returning {'_createNERDTree': function('193'), '...00'), '_bindMappings': function('186')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206

line 2:     call creator.toggleTabTree(a:dir)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207('')

line 1:     if g:NERDTree.ExistsForTab()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[1]..222()

line 1:     if !exists("t:NERDTreeBufName")
line 2:         return
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[1]..222 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207

line 2:         if !g:NERDTree.IsOpen()
line 3:             call self._createTreeWin()
line 4:             if !&hidden
line 5:                 call b:NERDTree.render()
line 6:             endif
line 7:             call b:NERDTree.ui.restoreScreenState()
line 8:         else
line 9:             call g:NERDTree.Close()
line 10:         endif
line 11:     else
line 12:         call self.createTabTree(a:dir)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190('')

line 1:     let l:path = self._pathForString(a:name)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201('')

line 1:     let path = {}
line 2:     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84('')

line 1:     try
line 2:         call s:Bookmark.BookmarkFor(a:name)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84[2]..85('')

line 1:     let l:result = {}
line 2:     for l:bookmark in s:Bookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84[2]..85[2]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84[2]..85[2]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84[2]..85

line 3:         if l:bookmark.name ==# a:name
line 4:             let l:result = l:bookmark
line 5:             break
line 6:         endif
line 7:     endfor
line 8:     if empty(l:result)
line 9:         throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
Exception thrown: NERDTree.BookmarkNotFoundError: "" not found

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84[2]..85 aborted

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84

line 3:         return 1
line 4:     catch /^NERDTree.BookmarkNotFoundError/
Exception caught: NERDTree.BookmarkNotFoundError: "" not found

line 5:         return 0
Exception finished: NERDTree.BookmarkNotFoundError: "" not found

:return 0 made pending

line 6:     endtry
:return 0 resumed

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[2]..84 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201

line 3:         let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
line 4:     else
line 5:         let dir = a:str ==# '' ? getcwd() : a:str
line 6: 
line 7:         "hack to get an absolute path if a relative path is given
line 8:         if dir =~# '^\.'
line 9:             let dir = getcwd() . g:NERDTreePath.Slash() . dir
line 10:         endif
line 11:         let dir = g:NERDTreePath.Resolve(dir)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[11]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[11]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201

line 12: 
line 13:         try
line 14:             let path = g:NERDTreePath.New(dir)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33('/home/w/repo/inz/kernel')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..1('/home/w/repo/inz/kernel')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..1 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36('/home/w/repo/inz/kernel')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[1]..15('/home/w/repo/inz/kernel')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[3]..48('/home/w/repo/inz/kernel')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[27]..20 returning 'kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[30]..46 returning '/home/w/repo/inz'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[30]..35('/home/w/repo/inz')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[30]..35 returning '/home/w/repo/inz'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[33]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201[14]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201

line 15:         catch /^NERDTree.InvalidArgumentsError/
line 16:             call nerdtree#echo("No bookmark or directory found for: " . a:str)
line 17:             return {}
line 18:         endtry
line 19:     endif
line 20:     if !path.isDirectory
line 21:         let path = path.getParent()
line 22:     endif
line 23: 
line 24:     return path
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[1]..201 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190

line 2: 
line 3:     " Abort if an exception was thrown (i.e., if the bookmark or directory
line 4:     " does not exist).
line 5:     if empty(l:path)
line 6:         return
line 7:     endif
line 8: 
line 9:     " Obey the user's preferences for changing the working directory.
line 10:     if g:NERDTreeChDirMode != 0
line 11:         call l:path.changeToDir()
line 12:     endif
line 13: 
line 14:     if g:NERDTree.ExistsForTab()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[14]..222()

line 1:     if !exists("t:NERDTreeBufName")
line 2:         return
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[14]..222 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190

line 15:         call g:NERDTree.Close()
line 16:         call self._removeTreeBufForTab()
line 17:     endif
line 18: 
line 19:     call self._createTreeWin()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196()

line 1:     let l:splitLocation = g:NERDTreeWinPos ==# 'left' ? 'topleft ' : 'botright '
line 2:     let l:splitSize = g:NERDTreeWinSize
line 3: 
line 4:     if !g:NERDTree.ExistsForTab()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[4]..222()

line 1:     if !exists("t:NERDTreeBufName")
line 2:         return
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[4]..222 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196

line 5:         let t:NERDTreeBufName = self._nextBufferName()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199()

line 1:     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199[1]..188()

line 1:     return 'NERD_tree_'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199[1]..188 returning 'NERD_tree_'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199[1]..200()

line 1:     if !exists("s:Creator._NextBufNum")
line 2:         let s:Creator._NextBufNum = 1
line 3:     else
line 4:         let s:Creator._NextBufNum += 1
line 5:     endif
line 6: 
line 7:     return s:Creator._NextBufNum
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199[1]..200 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199

line 2:     return name
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[5]..199 returning 'NERD_tree_1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196

line 6:         silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' new'
line 6: topleft vertical 31 new
Executing WinLeave Autocommands for "*"
autocommand call <SID>WinLeaveHandler()

line 0: call <SID>WinLeaveHandler()
calling function <SNR>32_WinLeaveHandler()

line 1:   if s:disable_handlers_for_tabdo
line 2:     return
function <SNR>32_WinLeaveHandler returning #0

continuing in WinLeave Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call <SID>WinEnterHandler()

line 0: call <SID>WinEnterHandler()
calling function <SNR>32_WinEnterHandler()

line 1:   if s:disable_handlers_for_tabdo
line 2:     return
function <SNR>32_WinEnterHandler returning #0

continuing in WinEnter Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in WinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand call <SID>BufWinEnterHandler()

line 0: call <SID>BufWinEnterHandler()
calling function <SNR>32_BufWinEnterHandler()

line 1:   if s:NewTabCreated
line 2:     " Turn off the 'NewTabCreated' flag
line 3:     let s:NewTabCreated = 0
line 4: 
line 5:     " Restore focus to NERDTree if necessary
line 6:     if !g:nerdtree_tabs_focus_on_files
line 7:       call s:NERDTreeRestoreFocus()
line 8:     endif
line 9:   endif
function <SNR>32_BufWinEnterHandler returning #0

continuing in BufWinEnter Autocommands for "*"

line 6: unlet! b:keymap_name
line 7:         silent! execute 'edit ' . t:NERDTreeBufName
line 7: edit NERD_tree_1
chdir(/home/w/repo/inz/kernel)
fchdir() to previous dir
Reading viminfo file "/home/w/.viminfo" marks
Executing BufNewFile Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 0:  runtime! scripts.vim | endif
Searching for "scripts.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/scripts.vim"
Searching for "/home/w/.vim/bundle/nerdtree/scripts.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/scripts.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/scripts.vim"
Searching for "/usr/share/vim/vimfiles/scripts.vim"
Searching for "/usr/share/vim/vim81/scripts.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 0: sourcing "/usr/share/vim/vim81/scripts.vim"
line 1: " Vim support file to detect file types in scripts
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2018 Feb 03
line 5: 
line 6: " This file is called by an autocommand for every file that has just been
line 7: " loaded into a buffer.  It checks if the type of file can be recognized by
line 8: " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
line 9: "
line 10: " Note that the pattern matches are done with =~# to avoid the value of the
line 11: " 'ignorecase' option making a difference.  Where case is to be ignored use
line 12: " =~? instead.  Do not use =~ anywhere.
line 13: 
line 14: 
line 15: " Only do the rest when the FileType autocommand has not been triggered yet.
line 16: if did_filetype()
line 17:   finish
line 18: endif
line 19: 
line 20: " Load the user defined scripts file first
line 21: " Only do this when the FileType autocommand has not been triggered yet
line 22: if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
line 23:   execute "source " . myscriptsfile
line 24:   if did_filetype()
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Line continuation is used here, remove 'C' from 'cpoptions'
line 30: let s:cpo_save = &cpo
line 31: set cpo&vim
line 32: 
line 33: let s:line1 = getline(1)
line 34: 
line 35: if s:line1 =~# "^#!"
line 36:   " A script that starts with "#!".
line 37: 
line 38:   " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
line 39:   " "#!/usr/bin/bash" to make matching easier.
line 40:   if s:line1 =~# '^#!\s*\S*\<env\s'
line 41:     let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
line 42:     let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
line 43:   endif
line 44: 
line 45:   " Get the program name.
line 46:   " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
line 47:   " If the word env is used, use the first word after the space:
line 48:   " "#!/usr/bin/env perl [path/args]"
line 49:   " If there is no path use the first word: "#!perl [path/args]".
line 50:   " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
line 51:   if s:line1 =~# '^#!\s*\a:[/\\]'
line 52:     let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
line 53:   elseif s:line1 =~# '^#!.*\<env\>'
line 54:     let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
line 55:   elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
line 56:     let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
line 57:   else
line 58:     let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
line 59:   endif
line 60: 
line 61:   " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
line 62:   " third line.  Suggested by Steven Atkinson.
line 63:   if getline(3) =~# '^exec wish'
line 64:     let s:name = 'wish'
line 65:   endif
line 66: 
line 67:   " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
line 68:   if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
line 69:     call dist#ft#SetFileTypeSH(s:line1)^I" defined in filetype.vim
line 70: 
line 71:     " csh scripts
line 72:   elseif s:name =~# '^csh\>'
line 73:     if exists("g:filetype_csh")
line 74:       call dist#ft#SetFileTypeShell(g:filetype_csh)
line 75:     else
line 76:       call dist#ft#SetFileTypeShell("csh")
line 77:     endif
line 78: 
line 79:     " tcsh scripts
line 80:   elseif s:name =~# '^tcsh\>'
line 81:     call dist#ft#SetFileTypeShell("tcsh")
line 82: 
line 83:     " Z shell scripts
line 84:   elseif s:name =~# '^zsh\>'
line 85:     set ft=zsh
line 86: 
line 87:     " TCL scripts
line 88:   elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
line 89:     set ft=tcl
line 90: 
line 91:     " Expect scripts
line 92:   elseif s:name =~# '^expect\>'
line 93:     set ft=expect
line 94: 
line 95:     " Gnuplot scripts
line 96:   elseif s:name =~# '^gnuplot\>'
line 97:     set ft=gnuplot
line 98: 
line 99:     " Makefiles
line 100:   elseif s:name =~# 'make\>'
line 101:     set ft=make
line 102: 
line 103:     " Pike
line 104:   elseif s:name =~# '^pike\%(\>\|[0-9]\)'
line 105:     set ft=pike
line 106: 
line 107:     " Lua
line 108:   elseif s:name =~# 'lua'
line 109:     set ft=lua
line 110: 
line 111:     " Perl 6
line 112:   elseif s:name =~# 'perl6'
line 113:     set ft=perl6
line 114: 
line 115:     " Perl
line 116:   elseif s:name =~# 'perl'
line 117:     set ft=perl
line 118: 
line 119:     " PHP
line 120:   elseif s:name =~# 'php'
line 121:     set ft=php
line 122: 
line 123:     " Python
line 124:   elseif s:name =~# 'python'
line 125:     set ft=python
line 126: 
line 127:     " Groovy
line 128:   elseif s:name =~# '^groovy\>'
line 129:     set ft=groovy
line 130: 
line 131:     " Ruby
line 132:   elseif s:name =~# 'ruby'
line 133:     set ft=ruby
line 134: 
line 135:     " JavaScript
line 136:   elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
line 137:     set ft=javascript
line 138: 
line 139:     " BC calculator
line 140:   elseif s:name =~# '^bc\>'
line 141:     set ft=bc
line 142: 
line 143:     " sed
line 144:   elseif s:name =~# 'sed\>'
line 145:     set ft=sed
line 146: 
line 147:     " OCaml-scripts
line 148:   elseif s:name =~# 'ocaml'
line 149:     set ft=ocaml
line 150: 
line 151:     " Awk scripts
line 152:   elseif s:name =~# 'awk\>'
line 153:     set ft=awk
line 154: 
line 155:     " Website MetaLanguage
line 156:   elseif s:name =~# 'wml'
line 157:     set ft=wml
line 158: 
line 159:     " Scheme scripts
line 160:   elseif s:name =~# 'scheme'
line 161:     set ft=scheme
line 162: 
line 163:     " CFEngine scripts
line 164:   elseif s:name =~# 'cfengine'
line 165:     set ft=cfengine
line 166: 
line 167:     " Erlang scripts
line 168:   elseif s:name =~# 'escript'
line 169:     set ft=erlang
line 170: 
line 171:     " Haskell
line 172:   elseif s:name =~# 'haskell'
line 173:     set ft=haskell
line 174: 
line 175:     " Scala
line 176:   elseif s:name =~# 'scala\>'
line 177:     set ft=scala
line 178: 
line 179:     " Clojure
line 180:   elseif s:name =~# 'clojure'
line 181:     set ft=clojure
line 182: 
line 183:   endif
line 184:   unlet s:name
line 185: 
line 186: else
line 187:   " File does not start with "#!".
line 188: 
line 189:   let s:line2 = getline(2)
line 190:   let s:line3 = getline(3)
line 191:   let s:line4 = getline(4)
line 192:   let s:line5 = getline(5)
line 193: 
line 194:   " Bourne-like shell scripts: sh ksh bash bash2
line 195:   if s:line1 =~# '^:$'
line 196:     call dist#ft#SetFileTypeSH(s:line1)^I" defined in filetype.vim
line 197: 
line 198:     " Z shell scripts
line 200:   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' || "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
line 201:     set ft=zsh
line 202: 
line 203:   " ELM Mail files
line 204:   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
line 205:     set ft=mail
line 206: 
line 207:     " Mason
line 208:   elseif s:line1 =~# '^<[%&].*>'
line 209:     set ft=mason
line 210: 
line 211:     " Vim scripts (must have '" vim' as the first line to trigger this)
line 212:   elseif s:line1 =~# '^" *[vV]im$'
line 213:     set ft=vim
line 214: 
line 215:     " MOO
line 216:   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
line 217:     set ft=moo
line 218: 
line 219:     " Diff file:
line 220:     " - "diff" in first line (context diff)
line 221:     " - "Only in " in first line
line 222:     " - "--- " in first line and "+++ " in second line (unified diff).
line 223:     " - "*** " in first line and "--- " in second line (context diff).
line 224:     " - "# It was generated by makepatch " in the second line (makepatch diff).
line 225:     " - "Index: <filename>" in the first line (CVS file)
line 226:     " - "=== ", line of "=", "---", "+++ " (SVK diff)
line 227:     " - "=== ", "--- ", "+++ " (bzr diff, common case)
line 228:     " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
line 229:     " - "# HG changeset patch" in first line (Mercurial export format)
line 235:   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)' || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ') || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ') || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ') || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ '))) || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
line 236:     set ft=diff
line 237: 
line 238:     " PostScript Files (must have %!PS as the first line, like a2ps output)
line 239:   elseif s:line1 =~# '^%![ \t]*PS'
line 240:     set ft=postscr
line 241: 
line 242:     " M4 scripts: Guess there is a line that starts with "dnl".
line 247:   elseif s:line1 =~# '^\s*dnl\>' || s:line2 =~# '^\s*dnl\>' || s:line3 =~# '^\s*dnl\>' || s:line4 =~# '^\s*dnl\>' || s:line5 =~# '^\s*dnl\>'
line 248:     set ft=m4
line 249: 
line 250:     " AmigaDos scripts
line 252:   elseif $TERM == "amiga" && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
line 253:     set ft=amiga
line 254: 
line 255:     " SiCAD scripts (must have procn or procd as the first line to trigger this)
line 256:   elseif s:line1 =~? '^ *proc[nd] *$'
line 257:     set ft=sicad
line 258: 
line 259:     " Purify log files start with "****  Purify"
line 260:   elseif s:line1 =~# '^\*\*\*\*  Purify'
line 261:     set ft=purifylog
line 262: 
line 263:     " XML
line 264:   elseif s:line1 =~# '<?\s*xml.*?>'
line 265:     set ft=xml
line 266: 
line 267:     " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
line 268:   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
line 269:     set ft=xhtml
line 270: 
line 271:     " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
line 272:     " Avoid "doctype html", used by slim.
line 273:   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
line 274:     set ft=html
line 275: 
line 276:     " PDF
line 277:   elseif s:line1 =~# '^%PDF-'
line 278:     set ft=pdf
line 279: 
line 280:     " XXD output
line 281:   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
line 282:     set ft=xxd
line 283: 
line 284:     " RCS/CVS log output
line 285:   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
line 286:     set ft=rcslog
line 287: 
line 288:     " CVS commit
line 289:   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
line 290:     set ft=cvs
line 291: 
line 292:     " Prescribe
line 293:   elseif s:line1 =~# '^!R!'
line 294:     set ft=prescribe
line 295: 
line 296:     " Send-pr
line 297:   elseif s:line1 =~# '^SEND-PR:'
line 298:     set ft=sendpr
line 299: 
line 300:     " SNNS files
line 301:   elseif s:line1 =~# '^SNNS network definition file'
line 302:     set ft=snnsnet
line 303:   elseif s:line1 =~# '^SNNS pattern definition file'
line 304:     set ft=snnspat
line 305:   elseif s:line1 =~# '^SNNS result file'
line 306:     set ft=snnsres
line 307: 
line 308:     " Virata
line 313:   elseif s:line1 =~# '^%.\{-}[Vv]irata' || s:line2 =~# '^%.\{-}[Vv]irata' || s:line3 =~# '^%.\{-}[Vv]irata' || s:line4 =~# '^%.\{-}[Vv]irata' || s:line5 =~# '^%.\{-}[Vv]irata'
line 314:     set ft=virata
line 315: 
line 316:     " Strace
line 317:   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
line 318:     set ft=strace
line 319: 
line 320:     " VSE JCL
line 321:   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
line 322:     set ft=vsejcl
line 323: 
line 324:     " TAK and SINDA
line 325:   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
line 326:     set ft=takout
line 327:   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
line 328:     set ft=sindaout
line 329:   elseif getline(6) =~# 'Run Date: '
line 330:     set ft=takcmp
line 331:   elseif getline(9) =~# 'Node    File  1'
line 332:     set ft=sindacmp
line 333: 
line 334:     " DNS zone files
line 335:   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
line 336:     set ft=bindzone
line 337: 
line 338:     " BAAN
line 340:   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC ' || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
line 341:     set ft=baan
line 342: 
line 343:   " Valgrind
line 344:   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
line 345:     set ft=valgrind
line 346: 
line 347:   " Go docs
line 348:   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
line 349:     set ft=godoc
line 350: 
line 351:   " Renderman Interface Bytestream
line 352:   elseif s:line1 =~# '^##RenderMan'
line 353:     set ft=rib
line 354: 
line 355:   " Scheme scripts
line 356:   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
line 357:     set ft=scheme
line 358: 
line 359:   " Git output
line 360:   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
line 361:     set ft=git
line 362: 
line 363:    " Gprof (gnu profiler)
line 366:    elseif s:line1 == 'Flat profile:' && s:line2 == '' && s:line3 =~# '^Each sample counts as .* seconds.$'
line 367:      set ft=gprof
line 368: 
line 369:   " Erlang terms
line 370:   " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
line 371:   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
line 372:     set ft=erlang
line 373: 
line 374:   " CVS diff
line 375:   else
line 376:     let s:lnum = 1
line 377:     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
line 378:       let s:lnum += 1
line 379:     endwhile
line 380:     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
line 381:       set ft=diff
line 382: 
line 383:       " locale input files: Formal Definitions of Cultural Conventions
line 384:       " filename must be like en_US, fr_FR@euro or en_US.UTF-8
line 385:     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
line 386:       let s:lnum = 1
line 387:       while s:lnum < 100 && s:lnum < line("$")
line 388: ^Iif getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
line 389: ^I  setf fdcc
line 390: ^I  break
line 391: ^Iendif
line 392: ^Ilet s:lnum += 1
line 393:       endwhile
line 394:     endif
line 395:     unlet s:lnum
line 396: 
line 397:   endif
line 398: 
line 399:   unlet s:line2 s:line3 s:line4 s:line5
line 400: 
line 401: endif
line 402: 
line 403: " Restore 'cpoptions'
line 404: let &cpo = s:cpo_save
line 405: 
line 406: unlet s:cpo_save s:line1
finished sourcing /usr/share/vim/vim81/scripts.vim
continuing in BufNewFile Autocommands for "*"
Searching for "/usr/share/vim/vimfiles/after/scripts.vim"
Searching for "/home/w/.vim/after/scripts.vim"
line 0:  endif
Executing BufNewFile Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 0:    setf FALLBACK conf | endif
line 0:  endif
Executing BufEnter Autocommands for "NERD_tree_*"
autocommand stopinsert

line 0: stopinsert
Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('/home/w/repo/inz/kernel/NERD_tree_1')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand call <SID>BufWinEnterHandler()

line 0: call <SID>BufWinEnterHandler()
calling function <SNR>32_BufWinEnterHandler()

line 1:   if s:NewTabCreated
line 2:     " Turn off the 'NewTabCreated' flag
line 3:     let s:NewTabCreated = 0
line 4: 
line 5:     " Restore focus to NERDTree if necessary
line 6:     if !g:nerdtree_tabs_focus_on_files
line 7:       call s:NERDTreeRestoreFocus()
line 8:     endif
line 9:   endif
function <SNR>32_BufWinEnterHandler returning #0

continuing in BufWinEnter Autocommands for "*"

line 7: unlet! b:keymap_name
line 8:         silent! execute 'vertical resize '. l:splitSize
line 8: vertical resize 31
line 9:     else
line 10:         silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' split'
line 11:         silent! execute 'buffer ' . t:NERDTreeBufName
line 12:     endif
line 13: 
line 14:     setlocal winfixwidth
line 15: 
line 16:     call self._setCommonBufOptions()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203()

line 1: 
line 2:     " Options for a non-file/control buffer.
line 3:     setlocal bufhidden=hide
line 4:     setlocal buftype=nofile
line 5:     setlocal noswapfile
line 6: 
line 7:     " Options for controlling buffer/window appearance.
line 8:     setlocal foldcolumn=0
line 9:     setlocal foldmethod=manual
line 10:     setlocal nobuflisted
line 11:     setlocal nofoldenable
line 12:     setlocal nolist
line 13:     setlocal nospell
line 14:     setlocal nowrap
line 15: 
line 16:     if g:NERDTreeShowLineNumbers
line 17:         setlocal nu
line 18:     else
line 19:         setlocal nonu
line 20:         if v:version >= 703
line 21:             setlocal nornu
line 22:         endif
line 23:     endif
line 24: 
line 25:     iabc <buffer>
line 26: 
line 27:     if g:NERDTreeHighlightCursorline
line 28:         setlocal cursorline
line 29:     endif
line 30: 
line 31:     call self._setupStatusline()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[31]..204()

line 1:     if g:NERDTreeStatusline != -1
line 2:         let &l:statusline = g:NERDTreeStatusline
line 3:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[31]..204 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203

line 32:     call self._bindMappings()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186()

line 1:     call g:NERDTreeKeyMap.BindAll()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74()

line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> u :call nerdtree#ui_glue#invokeKeyMap("u")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <CR> :call nerdtree#ui_glue#invokeKeyMap("<lt>CR>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> I :call nerdtree#ui_glue#invokeKeyMap("I")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <LeftRelease> <LeftRelease>:call nerdtree#ui_glue#invokeKeyMap("<lt>LeftRelease>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> CD :call nerdtree#ui_glue#invokeKeyMap("CD")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> s :call nerdtree#ui_glue#invokeKeyMap("s")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <C-j> :call nerdtree#ui_glue#invokeKeyMap("<lt>C-j>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> gi :call nerdtree#ui_glue#invokeKeyMap("gi")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <CR> :call nerdtree#ui_glue#invokeKeyMap("<lt>CR>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> r :call nerdtree#ui_glue#invokeKeyMap("r")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <CR> :call nerdtree#ui_glue#invokeKeyMap("<lt>CR>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> A :call nerdtree#ui_glue#invokeKeyMap("A")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <C-k> :call nerdtree#ui_glue#invokeKeyMap("<lt>C-k>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> F :call nerdtree#ui_glue#invokeKeyMap("F")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> p :call nerdtree#ui_glue#invokeKeyMap("p")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> cd :call nerdtree#ui_glue#invokeKeyMap("cd")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> P :call nerdtree#ui_glue#invokeKeyMap("P")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> O :call nerdtree#ui_glue#invokeKeyMap("O")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> K :call nerdtree#ui_glue#invokeKeyMap("K")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> U :call nerdtree#ui_glue#invokeKeyMap("U")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> m :call nerdtree#ui_glue#invokeKeyMap("m")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> J :call nerdtree#ui_glue#invokeKeyMap("J")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> e :call nerdtree#ui_glue#invokeKeyMap("e")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> gs :call nerdtree#ui_glue#invokeKeyMap("gs")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> R :call nerdtree#ui_glue#invokeKeyMap("R")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> q :call nerdtree#ui_glue#invokeKeyMap("q")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> X :call nerdtree#ui_glue#invokeKeyMap("X")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> D :call nerdtree#ui_glue#invokeKeyMap("D")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> i :call nerdtree#ui_glue#invokeKeyMap("i")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> go :call nerdtree#ui_glue#invokeKeyMap("go")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> T :call nerdtree#ui_glue#invokeKeyMap("T")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> go :call nerdtree#ui_glue#invokeKeyMap("go")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> B :call nerdtree#ui_glue#invokeKeyMap("B")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <CR> :call nerdtree#ui_glue#invokeKeyMap("<lt>CR>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> x :call nerdtree#ui_glue#invokeKeyMap("x")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <2-LeftMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>2-LeftMouse>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> t :call nerdtree#ui_glue#invokeKeyMap("t")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> f :call nerdtree#ui_glue#invokeKeyMap("f")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> <MiddleMouse> :call nerdtree#ui_glue#invokeKeyMap("<lt>MiddleMouse>")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> C :call nerdtree#ui_glue#invokeKeyMap("C")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> T :call nerdtree#ui_glue#invokeKeyMap("T")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> t :call nerdtree#ui_glue#invokeKeyMap("t")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> ? :call nerdtree#ui_glue#invokeKeyMap("?")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> e :call nerdtree#ui_glue#invokeKeyMap("e")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75()

line 1:     " If the key sequence we're trying to map contains any '<>' notation, we
line 2:     " must replace each of the '<' characters with '<lt>' to ensure the string
line 3:     " is not translated into its corresponding keycode during the later part
line 4:     " of the map command below
line 5:     " :he <>
line 6:     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
line 7:     if self.key =~# specialNotationRegex
line 8:         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
line 9:     else
line 10:         let keymapInvokeString = self.key
line 11:     endif
line 12:     let keymapInvokeString = escape(keymapInvokeString, '\')
line 13: 
line 14:     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
line 15: 
line 16:     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
line 16: nnoremap <buffer> <silent> o :call nerdtree#ui_glue#invokeKeyMap("o")<cr>
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74[2]..75 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74

line 3:     endfor
line 1:     for i in values(s:keyMaps)
line 2:         call i.bind()
line 3:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186[1]..74 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186

line 2: 
line 3:     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
line 4:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
line 5:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
line 6:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
line 7:     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
line 8:     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
line 9:     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
line 10:     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
line 11:     command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203[32]..186 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203

line 33: 
line 34:     setlocal filetype=nerdtree
Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

line 0: call s:LoadFTPlugin()
calling function <SNR>6_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17: ^Iexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 17: runtime! ftplugin/nerdtree.vim ftplugin/nerdtree_*.vim ftplugin/nerdtree/*.vim
Searching for "ftplugin/nerdtree.vim ftplugin/nerdtree_*.vim ftplugin/nerdtree/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/ftplugin/nerdtree.vim"
Searching for "/home/w/.vim/ftplugin/nerdtree_*.vim"
Searching for "/home/w/.vim/ftplugin/nerdtree/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/nerdtree.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/nerdtree_*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/ftplugin/nerdtree/*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/nerdtree.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/nerdtree_*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/ftplugin/nerdtree/*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/nerdtree.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/nerdtree_*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/ftplugin/nerdtree/*.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/nerdtree.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/nerdtree_*.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin/nerdtree/*.vim"
Searching for "/usr/share/vim/vim81/ftplugin/nerdtree.vim"
Searching for "/usr/share/vim/vim81/ftplugin/nerdtree_*.vim"
Searching for "/usr/share/vim/vim81/ftplugin/nerdtree/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/nerdtree.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/nerdtree_*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftplugin/nerdtree/*.vim"
Searching for "/home/w/.vim/after/ftplugin/nerdtree.vim"
Searching for "/home/w/.vim/after/ftplugin/nerdtree_*.vim"
Searching for "/home/w/.vim/after/ftplugin/nerdtree/*.vim"
not found in 'runtimepath': "ftplugin/nerdtree.vim ftplugin/nerdtree_*.vim ftplugin/nerdtree/*.vim"
line 18:       endfor
line 16:       for name in split(s, '\.')
line 17: ^Iexe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
line 18:       endfor
line 19:     endif
function <SNR>6_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand exe "set syntax=" . expand("<amatch>")

line 0: exe "set syntax=" . expand("<amatch>")
line 0: set syntax=nerdtree
Executing Syntax Autocommands for "*"
autocommand call s:SynSet()

line 0: call s:SynSet()
calling function <SNR>3_SynSet()

line 1:   " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
line 2:   syn clear
line 3:   if exists("b:current_syntax")
line 4:     unlet b:current_syntax
line 5:   endif
line 6: 
line 7:   let s = expand("<amatch>")
line 8:   if s == "ON"
line 9:     " :set syntax=ON
line 10:     if &filetype == ""
line 11:       echohl ErrorMsg
line 12:       echo "filetype unknown"
line 13:       echohl None
line 14:     endif
line 15:     let s = &filetype
line 16:   elseif s == "OFF"
line 17:     let s = ""
line 18:   endif
line 19: 
line 20:   if s != ""
line 21:     " Load the syntax file(s).  When there are several, separated by dots,
line 22:     " load each in sequence.
line 23:     for name in split(s, '\.')
line 24:       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 24: runtime! syntax/nerdtree.vim syntax/nerdtree/*.vim
Searching for "syntax/nerdtree.vim syntax/nerdtree/*.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/syntax/nerdtree.vim"
Searching for "/home/w/.vim/syntax/nerdtree/*.vim"
Searching for "/home/w/.vim/bundle/nerdtree/syntax/nerdtree.vim"
chdir(/home/w/.vim/bundle/nerdtree/syntax)
fchdir() to previous dir
line 24: sourcing "/home/w/.vim/bundle/nerdtree/syntax/nerdtree.vim"
line 1: let s:tree_up_dir_line = '.. (up a dir)'
line 2: syn match NERDTreeIgnore #\~#
line 3: exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
line 3: syn match NERDTreeIgnore #\[RO\]#
line 4: 
line 5: "highlighting for the .. (up dir) line at the top of the tree
line 6: execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
line 6: syn match NERDTreeUp #\V.. (up a dir)#
line 7: 
line 8: "quickhelp syntax elements
line 9: syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
line 10: syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
line 11: syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
line 12: syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
line 13: syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
line 14: syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
line 15: syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
line 16: 
line 17: "highlighting for sym links
line 18: syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
line 19: syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
line 20: syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
line 21: 
line 22: "highlighing for directory nodes and file nodes
line 23: syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
line 24: 
line 25: exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
line 25: syn match NERDTreeClosable #\ze .*/# containedin=NERDTreeDir,NERDTreeFile
line 26: exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
line 26: syn match NERDTreeOpenable #\ze .*/# containedin=NERDTreeDir,NERDTreeFile
line 27: 
line 28: let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
line 29: exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
line 29: syn match NERDTreeDir #[^ ].*/#
line 30: syn match NERDTreeExecFile  #^ .*\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark
line 31: exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
line 31: syn match NERDTreeFile  #^[^"\.] *[^]*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile
line 32: 
line 33: "highlighting for readonly files
line 34: exec 'syn match NERDTreeRO # *\zs.*\ze \['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
line 34: syn match NERDTreeRO # *\zs.*\ze \[RO\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile
line 35: 
line 36: syn match NERDTreeFlags #^ *\zs\[[^\]]*\]# containedin=NERDTreeFile,NERDTreeExecFile
line 37: syn match NERDTreeFlags #\[[^\]]*\]# containedin=NERDTreeDir
line 38: 
line 39: "highlighing to conceal the delimiter around the file/dir name
line 40: if has("conceal")
line 41:     exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# conceal containedin=ALL'
line 41: syn match NERDTreeNodeDelimiters #\%d7# conceal containedin=ALL
line 42:     setlocal conceallevel=3 concealcursor=nvic
line 43: else
line 44:     exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# containedin=ALL'
line 45:     hi! link NERDTreeNodeDelimiters Ignore
line 46: endif
line 47: 
line 48: syn match NERDTreeCWD #^[</].*$#
line 49: 
line 50: "highlighting for bookmarks
line 51: syn match NERDTreeBookmark # {.*}#hs=s+1
line 52: 
line 53: "highlighting for the bookmarks table
line 54: syn match NERDTreeBookmarksLeader #^>#
line 55: syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
line 56: syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
line 57: syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
line 58: 
line 59: hi def link NERDTreePart Special
line 60: hi def link NERDTreePartFile Type
line 61: hi def link NERDTreeExecFile Title
line 62: hi def link NERDTreeDirSlash Identifier
line 63: 
line 64: hi def link NERDTreeBookmarksHeader statement
line 65: hi def link NERDTreeBookmarksLeader ignore
line 66: hi def link NERDTreeBookmarkName Identifier
line 67: hi def link NERDTreeBookmark normal
line 68: 
line 69: hi def link NERDTreeHelp String
line 70: hi def link NERDTreeHelpKey Identifier
line 71: hi def link NERDTreeHelpCommand Identifier
line 72: hi def link NERDTreeHelpTitle Macro
line 73: hi def link NERDTreeToggleOn Question
line 74: hi def link NERDTreeToggleOff WarningMsg
line 75: 
line 76: hi def link NERDTreeLinkTarget Type
line 77: hi def link NERDTreeLinkFile Macro
line 78: hi def link NERDTreeLinkDir Macro
line 79: 
line 80: hi def link NERDTreeDir Directory
line 81: hi def link NERDTreeUp Directory
line 82: hi def link NERDTreeFile Normal
line 83: hi def link NERDTreeCWD Statement
line 84: hi def link NERDTreeOpenable Directory
line 85: hi def link NERDTreeClosable Directory
line 86: hi def link NERDTreeIgnore ignore
line 87: hi def link NERDTreeRO WarningMsg
line 88: hi def link NERDTreeBookmark Statement
line 89: hi def link NERDTreeFlags Number
line 90: 
line 91: hi def link NERDTreeCurrentNode Search
finished sourcing /home/w/.vim/bundle/nerdtree/syntax/nerdtree.vim
continuing in function <SNR>3_SynSet
Searching for "/home/w/.vim/bundle/nerdtree/syntax/nerdtree/*.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/syntax/nerdtree.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/syntax/nerdtree/*.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/syntax/nerdtree.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/syntax/nerdtree/*.vim"
Searching for "/usr/share/vim/vimfiles/syntax/nerdtree.vim"
Searching for "/usr/share/vim/vimfiles/syntax/nerdtree/*.vim"
Searching for "/usr/share/vim/vim81/syntax/nerdtree.vim"
Searching for "/usr/share/vim/vim81/syntax/nerdtree/*.vim"
Searching for "/usr/share/vim/vimfiles/after/syntax/nerdtree.vim"
Searching for "/usr/share/vim/vimfiles/after/syntax/nerdtree/*.vim"
Searching for "/home/w/.vim/after/syntax/nerdtree.vim"
Searching for "/home/w/.vim/after/syntax/nerdtree/*.vim"
line 25:     endfor
line 23:     for name in split(s, '\.')
line 24:       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
line 25:     endfor
line 26:   endif
function <SNR>3_SynSet returning #0

continuing in Syntax Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

line 0: call s:LoadIndent()
calling function <SNR>11_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14: ^Iexe 'runtime! indent/' . name . '.vim'
line 14: runtime! indent/nerdtree.vim
Searching for "indent/nerdtree.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/indent/nerdtree.vim"
Searching for "/home/w/.vim/bundle/nerdtree/indent/nerdtree.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/indent/nerdtree.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/indent/nerdtree.vim"
Searching for "/usr/share/vim/vimfiles/indent/nerdtree.vim"
Searching for "/usr/share/vim/vim81/indent/nerdtree.vim"
Searching for "/usr/share/vim/vimfiles/after/indent/nerdtree.vim"
Searching for "/home/w/.vim/after/indent/nerdtree.vim"
not found in 'runtimepath': "indent/nerdtree.vim"
line 15:       endfor
line 13:       for name in split(s, '\.')
line 14: ^Iexe 'runtime! indent/' . name . '.vim'
line 15:       endfor
line 16:     endif
function <SNR>11_LoadIndent returning #0

continuing in FileType Autocommands for "*"

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196[16]..203 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196

line 17: 
line 18:     if has('patch-7.4.1925')
line 19:         clearjumps
line 20:     endif
line 21: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[19]..196 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190

line 20:     call self._createNERDTree(l:path, 'tab')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'tab')

line 1:     let b:NERDTree = g:NERDTree.New(a:path, a:type)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[1]..231({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'tab')

line 1:     let newObj = copy(self)
line 2:     let newObj.ui = g:NERDTreeUI.New(newObj)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[1]..231[2]..238({'ForCurrentTab': function('224'), 'Ge...n('230'), 'isWinTree': function('229')})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj._showHelp = 0
line 4:     let newObj._ignoreEnabled = 1
line 5:     let newObj._showFiles = g:NERDTreeShowFiles
line 6:     let newObj._showHidden = g:NERDTreeShowHidden
line 7:     let newObj._showBookmarks = g:NERDTreeShowBookmarks
line 8: 
line 9:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[1]..231[2]..238 returning {'_showHidden': '0', 'restoreScreenSta...'), 'toggleShowFiles': function('261')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[1]..231

line 3:     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[1]..231[3]..156({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory != 1
line 2:         throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
line 3:     endif
line 4: 
line 5:     let newTreeNode = copy(self)
line 6:     let newTreeNode.path = a:path
line 7: 
line 8:     let newTreeNode.isOpen = 0
line 9:     let newTreeNode.children = []
line 10: 
line 11:     let newTreeNode.parent = {}
line 12:     let newTreeNode._nerdtree = a:nerdtree
line 13: 
line 14:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[1]..231

line 4:     let newObj._type = a:type
line 5:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193

line 2: 
line 3:     " TODO: This assignment is kept for compatibility reasons.  Many other
line 4:     " plugins use "b:NERDTreeRoot" instead of "b:NERDTree.root".  Remove this
line 5:     " assignment in the future.
line 6:     let b:NERDTreeRoot = b:NERDTree.root
line 7: 
line 8:     call b:NERDTree.root.open()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157()

line 1:     let l:options = a:0 ? a:1 : {}
line 2: 
line 3:     " If special options were specified, process them and return.
line 4:     if has_key(l:options, 'where') && !empty(l:options['where'])
line 5:         let l:opener = g:NERDTreeOpener.New(self.path, l:options)
line 6:         call l:opener.open(self)
line 7:         return 0
line 8:     endif
line 9: 
line 10:     " Open any ancestors of this node that render within the same cascade.
line 11:     let l:parent = self.parent
line 12:     while !empty(l:parent) && !l:parent.isRoot()
line 13:         if index(l:parent.getCascade(), self) >= 0
line 14:             let l:parent.isOpen = 1
line 15:             let l:parent = l:parent.parent
line 16:         else
line 17:             break
line 18:         endif
line 19:     endwhile
line 20: 
line 21:     let self.isOpen = 1
line 22: 
line 23:     let l:numChildrenCached = 0
line 24:     if empty(self.children)
line 25:         let l:numChildrenCached = self._initChildren(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155(0)

line 1:     "remove all the current child nodes
line 2:     let self.children = []
line 3: 
line 4:     let files = self._glob('*', 1) + self._glob('.*', 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149('*', 1)

line 1: 
line 2:     " Construct a path specification such that "globpath()" will return
line 3:     " relative pathnames, if possible.
line 4:     if self.path.str() == getcwd()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40()

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45()

line 1:     let l:separator = s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45

line 2:     let l:leader = l:separator
line 3: 
line 4:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[4]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[4]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45

line 5:         let l:leader = self.drive . l:separator
line 6:     endif
line 7: 
line 8:     return l:leader . join(self.pathSegments, l:separator)
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40

line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[15]..nerdtree#has_opt({}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[15]..nerdtree#has_opt returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149

line 5:         let l:pathSpec = ','
line 6:     else
line 7:         let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
line 8: 
line 9:         " On Windows, the drive letter may be removed by "fnamemodify()".
line 10:         if nerdtree#runningWindows() && l:pathSpec[0] == g:NERDTreePath.Slash()
line 11:             let l:pathSpec = self.path.drive . l:pathSpec
line 12:         endif
line 13:     endif
line 14: 
line 15:     let l:globList = []
line 16: 
line 17:     " See ":h version7.txt" and ":h version8.txt" for details on the
line 18:     " development of the "glob()" and "globpath()" functions.
line 19:     if v:version > 704 || (v:version == 704 && has('patch654'))
line 20:         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
line 21:     elseif v:version == 704 && has('patch279')
line 22:         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
line 23:     elseif v:version > 702 || (v:version == 702 && has('patch051'))
line 24:         let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
line 25:         let l:globList = split(l:globString, "\n")
line 26:     else
line 27:         let l:globString = globpath(l:pathSpec, a:pattern)
line 28:         let l:globList = split(l:globString, "\n")
line 29:     endif
line 30: 
line 31:     " If "a:all" is false, filter "." and ".." from the output.
line 32:     if !a:all
line 33:         let l:toRemove = []
line 34: 
line 35:         for l:file in l:globList
line 36:             let l:tail = fnamemodify(l:file, ':t')
line 37: 
line 38:             " If l:file has a trailing slash, then its :tail will be ''. Use
line 39:             " :h to drop the slash and the empty string after it; then use :t
line 40:             " to get the directory name.
line 41:             if l:tail == ''
line 42:                 let l:tail = fnamemodify(l:file, ':h:t')
line 43:             endif
line 44: 
line 45:             if l:tail == '.' || l:tail == '..'
line 46:                 call add(l:toRemove, l:file)
line 47:                 if len(l:toRemove) == 2
line 48:                     break
line 49:                 endif
line 50:             endif
line 51:         endfor
line 52: 
line 53:         for l:file in l:toRemove
line 54:             call remove(l:globList, index(l:globList, l:file))
line 55:         endfor
line 56:     endif
line 57: 
line 58:     return l:globList
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149 returning ['Makefile', 'MakefileKern.inc', 'io',...k', 'main', 'thirdparty', 'vimlog.log']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149('.*', 0)

line 1: 
line 2:     " Construct a path specification such that "globpath()" will return
line 3:     " relative pathnames, if possible.
line 4:     if self.path.str() == getcwd()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40()

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45()

line 1:     let l:separator = s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[1]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45

line 2:     let l:leader = l:separator
line 3: 
line 4:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[4]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45[4]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45

line 5:         let l:leader = self.drive . l:separator
line 6:     endif
line 7: 
line 8:     return l:leader . join(self.pathSegments, l:separator)
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[12]..45 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40

line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[15]..nerdtree#has_opt({}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40[15]..nerdtree#has_opt returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149[4]..40 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149

line 5:         let l:pathSpec = ','
line 6:     else
line 7:         let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
line 8: 
line 9:         " On Windows, the drive letter may be removed by "fnamemodify()".
line 10:         if nerdtree#runningWindows() && l:pathSpec[0] == g:NERDTreePath.Slash()
line 11:             let l:pathSpec = self.path.drive . l:pathSpec
line 12:         endif
line 13:     endif
line 14: 
line 15:     let l:globList = []
line 16: 
line 17:     " See ":h version7.txt" and ":h version8.txt" for details on the
line 18:     " development of the "glob()" and "globpath()" functions.
line 19:     if v:version > 704 || (v:version == 704 && has('patch654'))
line 20:         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
line 21:     elseif v:version == 704 && has('patch279')
line 22:         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
line 23:     elseif v:version > 702 || (v:version == 702 && has('patch051'))
line 24:         let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
line 25:         let l:globList = split(l:globString, "\n")
line 26:     else
line 27:         let l:globString = globpath(l:pathSpec, a:pattern)
line 28:         let l:globList = split(l:globString, "\n")
line 29:     endif
line 30: 
line 31:     " If "a:all" is false, filter "." and ".." from the output.
line 32:     if !a:all
line 33:         let l:toRemove = []
line 34: 
line 35:         for l:file in l:globList
line 36:             let l:tail = fnamemodify(l:file, ':t')
line 37: 
line 38:             " If l:file has a trailing slash, then its :tail will be ''. Use
line 39:             " :h to drop the slash and the empty string after it; then use :t
line 40:             " to get the directory name.
line 41:             if l:tail == ''
line 42:                 let l:tail = fnamemodify(l:file, ':h:t')
line 43:             endif
line 44: 
line 45:             if l:tail == '.' || l:tail == '..'
line 46:                 call add(l:toRemove, l:file)
line 47:                 if len(l:toRemove) == 2
line 48:                     break
line 49:                 endif
line 50:             endif
line 51:         endfor
line 35:         for l:file in l:globList
line 36:             let l:tail = fnamemodify(l:file, ':t')
line 37: 
line 38:             " If l:file has a trailing slash, then its :tail will be ''. Use
line 39:             " :h to drop the slash and the empty string after it; then use :t
line 40:             " to get the directory name.
line 41:             if l:tail == ''
line 42:                 let l:tail = fnamemodify(l:file, ':h:t')
line 43:             endif
line 44: 
line 45:             if l:tail == '.' || l:tail == '..'
line 46:                 call add(l:toRemove, l:file)
line 47:                 if len(l:toRemove) == 2
line 48:                     break
line 49:                 endif
line 50:             endif
line 51:         endfor
line 52: 
line 53:         for l:file in l:toRemove
line 54:             call remove(l:globList, index(l:globList, l:file))
line 55:         endfor
line 53:         for l:file in l:toRemove
line 54:             call remove(l:globList, index(l:globList, l:file))
line 55:         endfor
line 53:         for l:file in l:toRemove
line 54:             call remove(l:globList, index(l:globList, l:file))
line 55:         endfor
line 56:     endif
line 57: 
line 58:     return l:globList
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[4]..149 returning ['.gdb_history']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 5: 
line 6:     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
line 7:         call nerdtree#echo("Please wait, caching a large dir ...")
line 8:     endif
line 9: 
line 10:     let invalidFilesFound = 0
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('Makefile')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('Makefile')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/Makefile')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/Makefile')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/Makefile')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/Makefile')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
line 3:     else
line 4:         let newTreeNode = copy(self)
line 5:         let newTreeNode.path = a:path
line 6:         let newTreeNode.parent = {}
line 7:         let newTreeNode._nerdtree = a:nerdtree
line 8:         return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('MakefileKern.inc')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('MakefileKern.inc')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/MakefileKern.inc')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/MakefileKern.inc')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/MakefileKern.inc')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/MakefileKern.inc')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
line 3:     else
line 4:         let newTreeNode = copy(self)
line 5:         let newTreeNode.path = a:path
line 6:         let newTreeNode.parent = {}
line 7:         let newTreeNode._nerdtree = a:nerdtree
line 8:         return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('io')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('io')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/io')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/io')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/io')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning 'io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/io')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122[2]..156({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory != 1
line 2:         throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
line 3:     endif
line 4: 
line 5:     let newTreeNode = copy(self)
line 6:     let newTreeNode.path = a:path
line 7: 
line 8:     let newTreeNode.isOpen = 0
line 9:     let newTreeNode.children = []
line 10: 
line 11:     let newTreeNode.parent = {}
line 12:     let newTreeNode._nerdtree = a:nerdtree
line 13: 
line 14:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122


continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('libk')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('libk')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/libk')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/libk')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/libk')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning 'libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/libk')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122[2]..156({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory != 1
line 2:         throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
line 3:     endif
line 4: 
line 5:     let newTreeNode = copy(self)
line 6:     let newTreeNode.path = a:path
line 7: 
line 8:     let newTreeNode.isOpen = 0
line 9:     let newTreeNode.children = []
line 10: 
line 11:     let newTreeNode.parent = {}
line 12:     let newTreeNode._nerdtree = a:nerdtree
line 13: 
line 14:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122


continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('main')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('main')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/main')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/main')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/main')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning 'main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/main')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122[2]..156({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory != 1
line 2:         throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
line 3:     endif
line 4: 
line 5:     let newTreeNode = copy(self)
line 6:     let newTreeNode.path = a:path
line 7: 
line 8:     let newTreeNode.isOpen = 0
line 9:     let newTreeNode.children = []
line 10: 
line 11:     let newTreeNode.parent = {}
line 12:     let newTreeNode._nerdtree = a:nerdtree
line 13: 
line 14:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122


continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('thirdparty')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('thirdparty')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/thirdparty')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/thirdparty')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/thirdparty')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning 'thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/thirdparty')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122[2]..156({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory != 1
line 2:         throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
line 3:     endif
line 4: 
line 5:     let newTreeNode = copy(self)
line 6:     let newTreeNode.path = a:path
line 7: 
line 8:     let newTreeNode.isOpen = 0
line 9:     let newTreeNode.children = []
line 10: 
line 11:     let newTreeNode.parent = {}
line 12:     let newTreeNode._nerdtree = a:nerdtree
line 13: 
line 14:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122


continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('vimlog.log')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('vimlog.log')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/vimlog.log')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/vimlog.log')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/vimlog.log')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/vimlog.log')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
line 3:     else
line 4:         let newTreeNode = copy(self)
line 5:         let newTreeNode.path = a:path
line 6:         let newTreeNode.parent = {}
line 7:         let newTreeNode._nerdtree = a:nerdtree
line 8:         return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33('.gdb_history')

line 1:     let l:newPath = copy(self)
line 2: 
line 3:     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1('.gdb_history')

line 1:     let l:prependWorkingDir = 0
line 2: 
line 3:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[3]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 4:         let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
line 5:     else
line 6:         let l:prependWorkingDir = a:pathStr !~# '^/'
line 7:     endif
line 8: 
line 9:     let l:result = a:pathStr
line 10: 
line 11:     if l:prependWorkingDir
line 12:         let l:result = getcwd()
line 13: 
line 14:         if l:result[-1:] == s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[14]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 15:             let l:result = l:result . a:pathStr
line 16:         else
line 17:             let l:result = l:result . s:Path.Slash() . a:pathStr
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1[17]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1

line 18:         endif
line 19:     endif
line 20: 
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..1 returning '/home/w/repo/inz/kernel/.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36('/home/w/repo/inz/kernel/.gdb_history')

line 1:     call self.extractDriveLetter(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15('/home/w/repo/inz/kernel/.gdb_history')

line 1:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15

line 2:         if a:fullpath =~ '^\(\\\\\|\/\/\)'
line 3:             "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
line 4:             let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
line 5:             let self.drive = substitute(self.drive, '/', '\', "g")
line 6:         else
line 7:             let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
line 8:         endif
line 9:     else
line 10:         let self.drive = ''
line 11:     endif
line 12: 
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[1]..15 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 2: 
line 3:     let fullpath = s:Path.WinToUnixPath(a:fullpath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48('/home/w/repo/inz/kernel/.gdb_history')

line 1:     if !nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48[1]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48

line 2:         return a:pathstr
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[3]..48 returning '/home/w/repo/inz/kernel/.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 4: 
line 5:     if getftype(fullpath) ==# "fifo"
line 6:         throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
line 7:     endif
line 8: 
line 9:     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
line 10: 
line 11:     let self.isReadOnly = 0
line 12:     if isdirectory(a:fullpath)
line 13:         let self.isDirectory = 1
line 14:     elseif filereadable(a:fullpath)
line 15:         let self.isDirectory = 0
line 16:         let self.isReadOnly = filewritable(a:fullpath) ==# 0
line 17:     else
line 18:         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
line 19:     endif
line 20: 
line 21:     let self.isExecutable = 0
line 22:     if !self.isDirectory
line 23:         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
line 24:     endif
line 25: 
line 26:     "grab the last part of the path (minus the trailing slash)
line 27:     let lastPathComponent = self.getLastPathComponent(0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[27]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 28: 
line 29:     "get the path to the new node with the parent dir fully resolved
line 30:     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46()

line 1:     return self.drive . '/' . join(self.pathSegments[0:-2], '/')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..46 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35('/home/w/repo/inz/kernel')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[30]..35 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 31: 
line 32:     "if  the last part of the path is a symlink then flag it as such
line 33:     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35('/home/w/repo/inz/kernel/.gdb_history')

line 1:     let tmp = resolve(a:path)
line 2:     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36[33]..35 returning '/home/w/repo/inz/kernel/.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36

line 34:     if self.isSymLink
line 35:         let self.symLinkDest = s:Path.Resolve(fullpath)
line 36: 
line 37:         "if the link is a dir then slap a / on the end of its dest
line 38:         if isdirectory(self.symLinkDest)
line 39: 
line 40:             "we always wanna treat MS windows shortcuts as files for
line 41:             "simplicity
line 42:             if hardPath !~# '\.lnk$'
line 43: 
line 44:                 let self.symLinkDest = self.symLinkDest . '/'
line 45:             endif
line 46:         endif
line 47:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[3]..36 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 4: 
line 5:     let l:newPath.cachedDisplayString = ''
line 6:     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212()

line 1:     let newObj = copy(self)
line 2:     let newObj._flags = {}
line 3:     return newObj
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33[6]..212 returning {'clearFlags': function('210'), '_flag..., '_flags': {}, 'New': function('212')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33

line 7: 
line 8:     return l:newPath
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[13]..33 returning {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 14:             call self.createChild(path, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 0)

line 1:     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[1]..122({'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, )

line 1:     if a:path.isDirectory
line 2:         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
line 3:     else
line 4:         let newTreeNode = copy(self)
line 5:         let newTreeNode.path = a:path
line 6:         let newTreeNode.parent = {}
line 7:         let newTreeNode._nerdtree = a:nerdtree
line 8:         return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 2:     call self.addChild(newTreeNode, a:inOrder)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136(, 0)

line 1:     call add(self.children, a:treenode)
line 2:     let a:treenode.parent = self
line 3: 
line 4:     if a:inOrder
line 5:         call self.sortChildren()
line 6:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139[2]..136 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[14]..139

line 3:     return newTreeNode

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267('init', {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, , {})

line 1:     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[1]..265(, {'copyingWillOverwrite': function('10'...('48'), 'refreshFlags': function('38')}, 'init', {})

line 1:     let newObj = copy(self)
line 2:     let newObj.nerdtree = a:nerdtree
line 3:     let newObj.subject = a:subject
line 4:     let newObj.action = a:action
line 5:     let newObj.params = a:params
line 6:     return newObj

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 2: 
line 3:     for listener in s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269[1]..268 returning {}

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269

line 2:     return get(listenersMap, a:name, [])
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267[3]..269 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267

line 4:         call {listener}(event)
line 5:     endfor
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[15]..267 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 11:     for i in files
line 12:         try
line 13:             let path = g:NERDTreePath.New(i)
line 14:             call self.createChild(path, 0)
line 15:             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
line 16:         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
line 17:             let invalidFilesFound += 1
line 18:         endtry
line 19:     endfor
line 20: 
line 21:     call self.sortChildren()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168()

line 1:     if count(g:NERDTreeSortOrder, '*') < 1
line 2:         call add(g:NERDTreeSortOrder, '*')
line 3:     endif
line 4:     let CompareFunc = function("nerdtree#compareNodesBySortKey")
line 5:     call sort(self.children, CompareFunc)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, 'makefilekern.inc']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, 'makefilekern.inc']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'io/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'io/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [0, 'io/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'libk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'libk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'libk/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'io/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'io/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'io/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'libk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'libk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'libk/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [0, 'main/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'thirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'thirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'thirdparty/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'vimlog.log']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, '.gdb_history']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [0, 'main/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, '.gdb_history']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'thirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'thirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [0, 'thirdparty/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, '.gdb_history']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'io/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'io/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [0, 'io/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'main/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'libk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'libk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [0, 'libk/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'main/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'main/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'thirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'thirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [0, 'thirdparty/']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, '.gdb_history']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefile']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, 'vimlog.log']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey(, )

line 1:     let sortKey1 = a:n1.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21[3]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23[23]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[1]..23 returning [1, 'makefilekern.inc']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 2:     let sortKey2 = a:n2.path.getSortKey()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23()

line 1:     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
line 2:         " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
line 3:         let metadata = []
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 4:         for tag in g:NERDTreeSortOrder
line 5:             if tag =~? '\[\[-\?timestamp\]\]'
line 6:                 let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~ '-' ? -1 : 1)]
line 7:             elseif tag =~? '\[\[-\?size\]\]'
line 8:                 let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~ '-' ? -1 : 1)]
line 9:             elseif tag =~? '\[\[extension\]\]'
line 10:                 let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
line 11:                 let metadata += [self.isDirectory ? '' : (extension == '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
line 12:             endif
line 13:         endfor
line 14: 
line 15:         if g:NERDTreeSortOrder[0] =~ '\[\[.*\]\]'
line 16:             " Apply tags' sorting first if specified first.
line 17:             let self._sortKey = metadata + [self.getSortOrderIndex()]
line 18:         else
line 19:             " Otherwise, do regex grouping first.
line 20:             let self._sortKey = [self.getSortOrderIndex()] + metadata
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21()

line 1:     let i = 0
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21[3]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21

line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 2:     while i < len(g:NERDTreeSortOrder)
line 3:         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
line 5:             return i
line 6:         endif
line 7:         let i = i + 1
line 8:     endwhile
line 9: 
line 10:     return index(g:NERDTreeSortOrder, '*')
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[20]..21 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 21:         endif
line 22: 
line 23:         let path = self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23[23]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23

line 24:         if !g:NERDTreeSortHiddenFirst
line 25:             let path = substitute(path, '^[._]', '', '')
line 26:         endif
line 27:         if !g:NERDTreeCaseSensitiveSort
line 28:             let path = tolower(path)
line 29:         endif
line 30: 
line 31:         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
line 32:     endif
line 33:     return self._sortKey
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey[2]..23 returning [1, 'vimlog.log']

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey

line 3:     let i = 0
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
line 11:             elseif sortKey1[i] ># sortKey2[i]
line 12:                 return 1
line 13:             endif
line 14:         elseif type(sortKey1[i]) == v:t_number
line 15:             return -1
line 16:         elseif type(sortKey2[i]) == v:t_number
line 17:             return 1
line 18:         endif
line 19:         let i = i + 1
line 20:     endwhile
line 4:     while i < min([len(sortKey1), len(sortKey2)])
line 5:         " Compare chunks upto common length.
line 6:         " If chunks have different type, the one which has
line 7:         " integer type is the lesser.
line 8:         if type(sortKey1[i]) == type(sortKey2[i])
line 9:             if sortKey1[i] <# sortKey2[i]
line 10:                 return - 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168[5]..nerdtree#compareNodesBySortKey returning #-1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168

line 6:     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[21]..168 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 22: 
line 23:     call nerdtree#echo("")
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo('')

line 1:     redraw
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40()

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45()

line 1:     let l:separator = s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45[1]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45[1]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45[1]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45[1]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45[1]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45

line 2:     let l:leader = l:separator
line 3: 
line 4:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45[4]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45[4]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45

line 5:         let l:leader = self.drive . l:separator
line 6:     endif
line 7: 
line 8:     return l:leader . join(self.pathSegments, l:separator)
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[12]..45 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40

line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[15]..nerdtree#has_opt({}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40[15]..nerdtree#has_opt returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo[1]..40 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo

line 2:     echomsg empty(a:msg) ? "" : ("NERDTree: " . a:msg)

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[23]..nerdtree#echo returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

line 24: 
line 25:     if invalidFilesFound
line 26:         call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
line 27:     endif
line 28:     return self.getChildCount()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[28]..144()

line 1:     return len(self.children)
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155[28]..144 returning #8

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157[25]..155 returning #8

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157

line 26:     endif
line 27: 
line 28:     return l:numChildrenCached
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193[8]..157 returning #8

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[20]..193 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190

line 21:     call b:NERDTree.render()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235()

line 1:     call self.ui.render()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256()

line 1:     setlocal noreadonly modifiable
line 2: 
line 3:     " remember the top line of the buffer and the current line so we can
line 4:     " restore the view exactly how it was
line 5:     let curLine = line(".")
line 6:     let curCol = col(".")
line 7:     let topLine = line("w0")
line 8: 
line 9:     " delete all lines in the buffer (being careful not to clobber a register)
line 10:     silent 1,$delete _
line 11: 
line 12:     call self._dumpHelp()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237()

line 1:     if self.getShowHelp()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237[1]..244()

line 1:     return self._showHelp
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237[1]..244 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237

line 2:         let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
line 3:         let help .= "\" ============================\n"
line 4:         let help .= "\" File node mappings~\n"
line 5:         let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
line 6:         if self.nerdtree.isTabTree()
line 7:             let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
line 8:         else
line 9:             let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
line 10:         endif
line 11:         if self.nerdtree.isTabTree()
line 12:             let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
line 13:         endif
line 14:         let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
line 15:         let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
line 16:         let help .= "\" middle-click,\n"
line 17:         let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
line 18:         let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
line 19:         let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
line 20:         let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
line 21:         let help .= "\" ". g:NERDTreeMapCustomOpen .": custom open\n"
line 22: 
line 23:         let help .= "\"\n\" ----------------------------\n"
line 24:         let help .= "\" Directory node mappings~\n"
line 25:         let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
line 26:         let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
line 27:         let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
line 28:         let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
line 29:         let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
line 30:         let help .= "\" ". g:NERDTreeMapCustomOpen .": custom open\n"
line 31:         let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
line 32:         let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
line 33:         let help .= "\"    current node recursively\n"
line 34:         let help .= "\" middle-click,\n"
line 35:         let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
line 36: 
line 37:         let help .= "\"\n\" ----------------------------\n"
line 38:         let help .= "\" Bookmark table mappings~\n"
line 39:         let help .= "\" double-click,\n"
line 40:         let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
line 41:         let help .= "\" ". g:NERDTreeMapPreview .": preview file\n"
line 42:         let help .= "\" ". g:NERDTreeMapPreview .": find dir in tree\n"
line 43:         let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
line 44:         let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
line 45:         let help .= "\" ". g:NERDTreeMapCustomOpen .": custom open\n"
line 46:         let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
line 47: 
line 48:         let help .= "\"\n\" ----------------------------\n"
line 49:         let help .= "\" Tree navigation mappings~\n"
line 50:         let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
line 51:         let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
line 52:         let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
line 53:         let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
line 54:         let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
line 55:         let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
line 56: 
line 57:         let help .= "\"\n\" ----------------------------\n"
line 58:         let help .= "\" Filesystem mappings~\n"
line 59:         let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
line 60:         let help .= "\"    selected dir\n"
line 61:         let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
line 62:         let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
line 63:         let help .= "\"    but leave old root open\n"
line 64:         let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
line 65:         let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
line 66:         let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
line 67:         let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
line 68:         let help .= "\"    selected dir\n"
line 69:         let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
line 70: 
line 71:         let help .= "\"\n\" ----------------------------\n"
line 72:         let help .= "\" Tree filtering mappings~\n"
line 73:         let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
line 74:         let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
line 75:         let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
line 76:         let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
line 77: 
line 78:         " add quickhelp entries for each custom key map
line 79:         let help .= "\"\n\" ----------------------------\n"
line 80:         let help .= "\" Custom mappings~\n"
line 81:         for i in g:NERDTreeKeyMap.All()
line 82:             if !empty(i.quickhelpText)
line 83:                 let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
line 84:             endif
line 85:         endfor
line 86: 
line 87:         let help .= "\"\n\" ----------------------------\n"
line 88:         let help .= "\" Other mappings~\n"
line 89:         let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
line 90:         let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
line 91:         let help .= "\"    the NERDTree window\n"
line 92:         let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
line 93:         let help .= "\"\n\" ----------------------------\n"
line 94:         let help .= "\" Bookmark commands~\n"
line 95:         let help .= "\" :Bookmark [<name>]\n"
line 96:         let help .= "\" :BookmarkToRoot <name>\n"
line 97:         let help .= "\" :RevealBookmark <name>\n"
line 98:         let help .= "\" :OpenBookmark <name>\n"
line 99:         let help .= "\" :ClearBookmarks [<names>]\n"
line 100:         let help .= "\" :ClearAllBookmarks\n"
line 101:         let help .= "\" :ReadBookmarks\n"
line 102:         let help .= "\" :WriteBookmarks\n"
line 103:         let help .= "\" :EditBookmarks\n"
line 104:         silent! put =help
line 105:     elseif !self.isMinimal()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237[105]..249()

line 1:     return g:NERDTreeMinimalUI
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237[105]..249 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237

line 106:         let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
line 107:         silent! put =help
line 108:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[12]..237 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256

line 13: 
line 14:     " delete the blank line before the help and add one after it
line 15:     if !self.isMinimal()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[15]..249()

line 1:     return g:NERDTreeMinimalUI
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[15]..249 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256

line 16:         call setline(line(".")+1, "")
line 17:         call cursor(line(".")+1, col("."))
line 18:     endif
line 19: 
line 20:     if self.getShowBookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[20]..242()

line 1:     return self._showBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[20]..242 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256

line 21:         call self._renderBookmarks()
line 22:     endif
line 23: 
line 24:     " add the 'up a dir' line
line 25:     if !self.isMinimal()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[25]..249()

line 1:     return g:NERDTreeMinimalUI
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[25]..249 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256

line 26:         call setline(line(".")+1, s:UI.UpDirLine())
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[26]..264()

line 1:     return '.. (up a dir)'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[26]..264 returning '.. (up a dir)'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256

line 27:         call cursor(line(".")+1, col("."))
line 28:     endif
line 29: 
line 30:     " draw the header line
line 31:     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40({'format': 'UI', 'truncateTo': 31})

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 7: let toReturn = self._strForUI()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40[7]..41()

line 1:     let toReturn = '/' . join(self.pathSegments, '/')
line 2:     if self.isDirectory && toReturn != '/'
line 3:         let toReturn  = toReturn . '/'
line 4:     endif
line 5:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40[7]..41 returning '/home/w/repo/inz/kernel/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40

line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40[15]..nerdtree#has_opt({'format': 'UI', 'truncateTo': 31}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40[15]..nerdtree#has_opt returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[31]..40 returning '/home/w/repo/inz/kernel/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256

line 32:     call setline(line(".")+1, header)
line 33:     call cursor(line(".")+1, col("."))
line 34: 
line 35:     " draw the tree
line 36:     silent put =self.nerdtree.root.renderToString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132()

line 1:     return self._renderToString(0, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133(0, 0)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152()

line 1:     let toReturn = []
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning 'io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning 'io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning 'libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning 'libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning 'main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning 'main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning 'thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning 'thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28[14]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25[1]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[18]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 7:     return toReturn

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 19: 
line 20:         if self.isCascadable() && a:depth > 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154()

line 1:     if g:NERDTreeCascadeSingleChildDir == 0
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if self.path.isSymLink
line 6:         return 0
line 7:     endif
line 8: 
line 9:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[9]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[9]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154

line 10:         if i.path.equals(self.path)
line 11:             return 0
line 12:         endif
line 13:     endfor
line 14: 
line 15:     let c = self.getVisibleChildren()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152()

line 1:     let toReturn = []
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning 'io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning 'io'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning 'libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning 'libk'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning 'main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning 'main'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning 'thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning 'thirdparty'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning '.gdb_history'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27()

line 1:     "filter out the user specified paths to ignore
line 2:     if a:nerdtree.ui.isIgnoreFilterEnabled()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248()

line 1:     return self._ignoreEnabled == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[2]..248 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28('\~$')

line 1:     let pat = a:pattern
line 2:     if strpart(pat,len(pat)-7) == '[[dir]]'
line 3:         if !self.isDirectory
line 4:             return 0
line 5:         endif
line 6:         let pat = strpart(pat,0, len(pat)-7)
line 7:     elseif strpart(pat,len(pat)-8) == '[[file]]'
line 8:         if self.isDirectory
line 9:             return 0
line 10:         endif
line 11:         let pat = strpart(pat,0, len(pat)-8)
line 12:     endif
line 13: 
line 14:     return self.getLastPathComponent(0) =~# pat
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28[14]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[4]..28 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 5:                 return 1
line 6:             endif
line 7:         endfor
line 3:         for i in g:NERDTreeIgnore
line 4:             if self._ignorePatternMatches(i)
line 5:                 return 1
line 6:             endif
line 7:         endfor
line 8: 
line 9:         for callback in g:NERDTree.PathFilters()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232()

line 1:     if !exists('s:NERDTree._PathFilters')
line 2:         let s:NERDTree._PathFilters = []
line 3:     endif
line 4:     return s:NERDTree._PathFilters
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[9]..232 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 10:             if {callback}({'path': self, 'nerdtree': a:nerdtree})
line 11:                 return 1
line 12:             endif
line 13:         endfor
line 14:     endif
line 15: 
line 16:     "dont show hidden files unless instructed to
line 17:     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245()

line 1:     return self._showHidden
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..245 returning '0'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25()

line 1:     return self.getLastPathComponent(0) =~# '^\.'
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20(0)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25[1]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[17]..25 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 18:         return 1
line 19:     endif
line 20: 
line 21:     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243()

line 1:     return self._showFiles
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27[21]..243 returning '1'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27

line 22:         return 1
line 23:     endif
line 24: 
line 25:     return 0
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152[3]..27 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154[15]..152

line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 7:     return toReturn

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154

line 16:     return len(c) == 1 && c[0].path.isDirectory
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[20]..154 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133(1, 1)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140()

line 1:     let l:result = ''
line 2: 
line 3:     " Build a label that identifies this TreeDirNode.
line 4:     let l:label = ''
line 5:     let l:cascade = self.getCascade()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142()

line 1:     if !self.isCascadable()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154()

line 1:     if g:NERDTreeCascadeSingleChildDir == 0
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if self.path.isSymLink
line 6:         return 0
line 7:     endif
line 8: 
line 9:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 10:         if i.path.equals(self.path)
line 11:             return 0
line 12:         endif
line 13:     endfor
line 14: 
line 15:     let c = self.getVisibleChildren()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152()

line 1:     let toReturn = []
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 7:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 16:     return len(c) == 1 && c[0].path.isDirectory
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142

line 2:         return [self]

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13()

line 1:     if self.cachedDisplayString ==# ""
line 2:         call self.cacheDisplayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3()

line 1:     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20 returning 'io/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 2: 
line 3:     if self.isExecutable
line 4:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
line 5:     endif
line 6: 
line 7:     let self._bookmarkNames = []
line 8:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 9:         if i.path.equals(self)
line 10:             call add(self._bookmarkNames, i.name)
line 11:         endif
line 12:     endfor
line 13:     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
line 14:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
line 15:     endif
line 16: 
line 17:     if self.isSymLink
line 18:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
line 19:     endif
line 20: 
line 21:     if self.isReadOnly
line 22:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
line 23:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13

line 3:     endif
line 4: 
line 5:     return self.cachedDisplayString
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13 returning '^Gio/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 10: 
line 11:     " Select the appropriate open/closed status indicator symbol.
line 12:     if l:cascade[-1].isOpen
line 13:         let l:symbol = g:NERDTreeDirArrowCollapsible
line 14:     else
line 15:         let l:symbol = g:NERDTreeDirArrowExpandable
line 16:     endif
line 17: 
line 18:     let l:flags = l:cascade[-1].path.flagSet.renderToString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214()

line 1:     let flagstring = ""
line 2:     for i in values(self._flags)
line 3:         let flagstring .= join(i)
line 4:     endfor
line 5: 
line 6:     if len(flagstring) == 0
line 7:         return ""
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214 returning ''

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 19: 
line 20:     let l:result = l:symbol . ' ' . l:flags . l:label
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140 returning ' ^Gio/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133

line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
line 19: 
line 20:         if self.isCascadable() && a:depth > 0
line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133 returning ' ^Gio/^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 27:             endfor
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133(1, 1)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140()

line 1:     let l:result = ''
line 2: 
line 3:     " Build a label that identifies this TreeDirNode.
line 4:     let l:label = ''
line 5:     let l:cascade = self.getCascade()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142()

line 1:     if !self.isCascadable()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154()

line 1:     if g:NERDTreeCascadeSingleChildDir == 0
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if self.path.isSymLink
line 6:         return 0
line 7:     endif
line 8: 
line 9:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 10:         if i.path.equals(self.path)
line 11:             return 0
line 12:         endif
line 13:     endfor
line 14: 
line 15:     let c = self.getVisibleChildren()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152()

line 1:     let toReturn = []
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 7:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 16:     return len(c) == 1 && c[0].path.isDirectory
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142

line 2:         return [self]

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13()

line 1:     if self.cachedDisplayString ==# ""
line 2:         call self.cacheDisplayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3()

line 1:     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20 returning 'libk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 2: 
line 3:     if self.isExecutable
line 4:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
line 5:     endif
line 6: 
line 7:     let self._bookmarkNames = []
line 8:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 9:         if i.path.equals(self)
line 10:             call add(self._bookmarkNames, i.name)
line 11:         endif
line 12:     endfor
line 13:     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
line 14:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
line 15:     endif
line 16: 
line 17:     if self.isSymLink
line 18:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
line 19:     endif
line 20: 
line 21:     if self.isReadOnly
line 22:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
line 23:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13

line 3:     endif
line 4: 
line 5:     return self.cachedDisplayString
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13 returning '^Glibk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 10: 
line 11:     " Select the appropriate open/closed status indicator symbol.
line 12:     if l:cascade[-1].isOpen
line 13:         let l:symbol = g:NERDTreeDirArrowCollapsible
line 14:     else
line 15:         let l:symbol = g:NERDTreeDirArrowExpandable
line 16:     endif
line 17: 
line 18:     let l:flags = l:cascade[-1].path.flagSet.renderToString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214()

line 1:     let flagstring = ""
line 2:     for i in values(self._flags)
line 3:         let flagstring .= join(i)
line 4:     endfor
line 5: 
line 6:     if len(flagstring) == 0
line 7:         return ""
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214 returning ''

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 19: 
line 20:     let l:result = l:symbol . ' ' . l:flags . l:label
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140 returning ' ^Glibk/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133

line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
line 19: 
line 20:         if self.isCascadable() && a:depth > 0
line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133 returning ' ^Glibk/^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 27:             endfor
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133(1, 1)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140()

line 1:     let l:result = ''
line 2: 
line 3:     " Build a label that identifies this TreeDirNode.
line 4:     let l:label = ''
line 5:     let l:cascade = self.getCascade()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142()

line 1:     if !self.isCascadable()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154()

line 1:     if g:NERDTreeCascadeSingleChildDir == 0
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if self.path.isSymLink
line 6:         return 0
line 7:     endif
line 8: 
line 9:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 10:         if i.path.equals(self.path)
line 11:             return 0
line 12:         endif
line 13:     endfor
line 14: 
line 15:     let c = self.getVisibleChildren()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152()

line 1:     let toReturn = []
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 7:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 16:     return len(c) == 1 && c[0].path.isDirectory
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142

line 2:         return [self]

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13()

line 1:     if self.cachedDisplayString ==# ""
line 2:         call self.cacheDisplayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3()

line 1:     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20 returning 'main/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 2: 
line 3:     if self.isExecutable
line 4:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
line 5:     endif
line 6: 
line 7:     let self._bookmarkNames = []
line 8:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 9:         if i.path.equals(self)
line 10:             call add(self._bookmarkNames, i.name)
line 11:         endif
line 12:     endfor
line 13:     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
line 14:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
line 15:     endif
line 16: 
line 17:     if self.isSymLink
line 18:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
line 19:     endif
line 20: 
line 21:     if self.isReadOnly
line 22:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
line 23:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13

line 3:     endif
line 4: 
line 5:     return self.cachedDisplayString
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13 returning '^Gmain/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 10: 
line 11:     " Select the appropriate open/closed status indicator symbol.
line 12:     if l:cascade[-1].isOpen
line 13:         let l:symbol = g:NERDTreeDirArrowCollapsible
line 14:     else
line 15:         let l:symbol = g:NERDTreeDirArrowExpandable
line 16:     endif
line 17: 
line 18:     let l:flags = l:cascade[-1].path.flagSet.renderToString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214()

line 1:     let flagstring = ""
line 2:     for i in values(self._flags)
line 3:         let flagstring .= join(i)
line 4:     endfor
line 5: 
line 6:     if len(flagstring) == 0
line 7:         return ""
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214 returning ''

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 19: 
line 20:     let l:result = l:symbol . ' ' . l:flags . l:label
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140 returning ' ^Gmain/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133

line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
line 19: 
line 20:         if self.isCascadable() && a:depth > 0
line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133 returning ' ^Gmain/^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 27:             endfor
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133(1, 1)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140()

line 1:     let l:result = ''
line 2: 
line 3:     " Build a label that identifies this TreeDirNode.
line 4:     let l:label = ''
line 5:     let l:cascade = self.getCascade()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142()

line 1:     if !self.isCascadable()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154()

line 1:     if g:NERDTreeCascadeSingleChildDir == 0
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if self.path.isSymLink
line 6:         return 0
line 7:     endif
line 8: 
line 9:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[9]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 10:         if i.path.equals(self.path)
line 11:             return 0
line 12:         endif
line 13:     endfor
line 14: 
line 15:     let c = self.getVisibleChildren()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152()

line 1:     let toReturn = []
line 2:     for i in self.children
line 3:         if i.path.ignore(self.getNerdtree()) ==# 0
line 4:             call add(toReturn, i)
line 5:         endif
line 6:     endfor
line 7:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154[15]..152 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154

line 16:     return len(c) == 1 && c[0].path.isDirectory
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142[1]..154 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[5]..142

line 2:         return [self]

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13()

line 1:     if self.cachedDisplayString ==# ""
line 2:         call self.cacheDisplayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3()

line 1:     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[1]..20 returning 'thirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 2: 
line 3:     if self.isExecutable
line 4:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
line 5:     endif
line 6: 
line 7:     let self._bookmarkNames = []
line 8:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3[8]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3

line 9:         if i.path.equals(self)
line 10:             call add(self._bookmarkNames, i.name)
line 11:         endif
line 12:     endfor
line 13:     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
line 14:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
line 15:     endif
line 16: 
line 17:     if self.isSymLink
line 18:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
line 19:     endif
line 20: 
line 21:     if self.isReadOnly
line 22:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
line 23:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13[2]..3 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13

line 3:     endif
line 4: 
line 5:     return self.cachedDisplayString
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[7]..13 returning '^Gthirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 6:     for l:dirNode in l:cascade
line 7:         let l:next = l:dirNode.path.displayString()
line 8:         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
line 9:     endfor
line 10: 
line 11:     " Select the appropriate open/closed status indicator symbol.
line 12:     if l:cascade[-1].isOpen
line 13:         let l:symbol = g:NERDTreeDirArrowCollapsible
line 14:     else
line 15:         let l:symbol = g:NERDTreeDirArrowExpandable
line 16:     endif
line 17: 
line 18:     let l:flags = l:cascade[-1].path.flagSet.renderToString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214()

line 1:     let flagstring = ""
line 2:     for i in values(self._flags)
line 3:         let flagstring .= join(i)
line 4:     endfor
line 5: 
line 6:     if len(flagstring) == 0
line 7:         return ""
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140[18]..214 returning ''

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140

line 19: 
line 20:     let l:result = l:symbol . ' ' . l:flags . l:label
line 21:     return l:result
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..140 returning ' ^Gthirdparty/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133

line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
line 19: 
line 20:         if self.isCascadable() && a:depth > 0
line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133 returning ' ^Gthirdparty/^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 27:             endfor
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133(1, 1)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113()

line 1:     return self.path.flagSet.renderToString() . self.path.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..214()

line 1:     let flagstring = ""
line 2:     for i in values(self._flags)
line 3:         let flagstring .= join(i)
line 4:     endfor
line 5: 
line 6:     if len(flagstring) == 0
line 7:         return ""
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..214 returning ''

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13()

line 1:     if self.cachedDisplayString ==# ""
line 2:         call self.cacheDisplayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3()

line 1:     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[1]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[1]..20 returning 'Makefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3

line 2: 
line 3:     if self.isExecutable
line 4:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
line 5:     endif
line 6: 
line 7:     let self._bookmarkNames = []
line 8:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[8]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[8]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3

line 9:         if i.path.equals(self)
line 10:             call add(self._bookmarkNames, i.name)
line 11:         endif
line 12:     endfor
line 13:     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
line 14:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
line 15:     endif
line 16: 
line 17:     if self.isSymLink
line 18:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
line 19:     endif
line 20: 
line 21:     if self.isReadOnly
line 22:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
line 23:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13

line 3:     endif
line 4: 
line 5:     return self.cachedDisplayString
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13 returning '^GMakefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113 returning '^GMakefile'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133

line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
line 19: 
line 20:         if self.isCascadable() && a:depth > 0
line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133 returning '  ^GMakefile^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 27:             endfor
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133(1, 1)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113()

line 1:     return self.path.flagSet.renderToString() . self.path.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..214()

line 1:     let flagstring = ""
line 2:     for i in values(self._flags)
line 3:         let flagstring .= join(i)
line 4:     endfor
line 5: 
line 6:     if len(flagstring) == 0
line 7:         return ""
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..214 returning ''

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13()

line 1:     if self.cachedDisplayString ==# ""
line 2:         call self.cacheDisplayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3()

line 1:     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[1]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[1]..20 returning 'MakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3

line 2: 
line 3:     if self.isExecutable
line 4:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
line 5:     endif
line 6: 
line 7:     let self._bookmarkNames = []
line 8:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[8]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[8]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3

line 9:         if i.path.equals(self)
line 10:             call add(self._bookmarkNames, i.name)
line 11:         endif
line 12:     endfor
line 13:     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
line 14:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
line 15:     endif
line 16: 
line 17:     if self.isSymLink
line 18:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
line 19:     endif
line 20: 
line 21:     if self.isReadOnly
line 22:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
line 23:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13

line 3:     endif
line 4: 
line 5:     return self.cachedDisplayString
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13 returning '^GMakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113 returning '^GMakefileKern.inc'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133

line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
line 19: 
line 20:         if self.isCascadable() && a:depth > 0
line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133 returning '  ^GMakefileKern.inc^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 27:             endfor
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133(1, 1)

line 1:     let output = ""
line 2:     if a:drawText ==# 1
line 3: 
line 4:         let treeParts = repeat('  ', a:depth - 1)
line 5: 
line 6:         if !self.path.isDirectory
line 7:             let treeParts = treeParts . '  '
line 8:         endif
line 9: 
line 10:         let line = treeParts . self.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113()

line 1:     return self.path.flagSet.renderToString() . self.path.displayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..214()

line 1:     let flagstring = ""
line 2:     for i in values(self._flags)
line 3:         let flagstring .= join(i)
line 4:     endfor
line 5: 
line 6:     if len(flagstring) == 0
line 7:         return ""
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..214 returning ''

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13()

line 1:     if self.cachedDisplayString ==# ""
line 2:         call self.cacheDisplayString()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3()

line 1:     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[1]..20(1)

line 1:     if empty(self.pathSegments)
line 2:         return ''
line 3:     endif
line 4:     let toReturn = self.pathSegments[-1]
line 5:     if a:dirSlash && self.isDirectory
line 6:         let toReturn = toReturn . '/'
line 7:     endif
line 8:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[1]..20 returning 'vimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3

line 2: 
line 3:     if self.isExecutable
line 4:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
line 5:     endif
line 6: 
line 7:     let self._bookmarkNames = []
line 8:     for i in g:NERDTreeBookmark.Bookmarks()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[8]..83()

line 1:     if !exists("g:NERDTreeBookmarks")
line 2:         let g:NERDTreeBookmarks = []
line 3:     endif
line 4:     return g:NERDTreeBookmarks
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3[8]..83 returning []

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3

line 9:         if i.path.equals(self)
line 10:             call add(self._bookmarkNames, i.name)
line 11:         endif
line 12:     endfor
line 13:     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
line 14:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
line 15:     endif
line 16: 
line 17:     if self.isSymLink
line 18:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
line 19:     endif
line 20: 
line 21:     if self.isReadOnly
line 22:         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
line 23:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13[2]..3 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13

line 3:     endif
line 4: 
line 5:     return self.cachedDisplayString
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113[1]..13 returning '^Gvimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133[10]..113 returning '^Gvimlog.log'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133

line 11: 
line 12:         let output = output . line . "\n"
line 13:     endif
line 14: 
line 15:     " if the node is an open dir, draw its children
line 16:     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
line 17: 
line 18:         let childNodesToDraw = self.getVisibleChildren()
line 19: 
line 20:         if self.isCascadable() && a:depth > 0
line 21: 
line 22:             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
line 23: 
line 24:         elseif len(childNodesToDraw) > 0
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133[26]..133 returning '  ^Gvimlog.log^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133

line 27:             endfor
line 25:             for i in childNodesToDraw
line 26:                 let output = output . i._renderToString(a:depth + 1, 1)
line 27:             endfor
line 28:         endif
line 29:     endif
line 30: 
line 31:     return output
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132[1]..133 returning ' ^Gio/^@ ^Glibk/^@ ^Gmain/^@ ^Gth...  ^GMakefileKern.inc^@  ^Gvimlog.log^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256[36]..132 returning ' ^Gio/^@ ^Glibk/^@ ^Gmain/^@ ^Gth...  ^GMakefileKern.inc^@  ^Gvimlog.log^@'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256

7 more lines
line 37: 
line 38:     " delete the blank line at the top of the buffer
line 39:     silent 1,1delete _
line 40: 
line 41:     " restore the view
line 42:     let old_scrolloff=&scrolloff
line 43:     let &scrolloff=0
line 44:     call cursor(topLine, 1)
line 45:     normal! zt
line 46:     call cursor(curLine, curCol)
line 47:     let &scrolloff = old_scrolloff
line 48: 
line 49:     setlocal readonly nomodifiable
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235[1]..256 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[21]..235 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190

line 22:     call b:NERDTree.root.putCursorHere(0, 0)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128(0, 0)

line 1:     let ln = self.getNerdtree().ui.getLineNum(self)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240()

line 1: 
line 2:     if a:node.isRoot()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121()

line 1:     if !g:NERDTree.ExistsForBuf()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[1]..221()

line 1:     return exists("b:NERDTree")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[1]..221 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121

line 2:         throw "NERDTree.NoTreeError: No tree exists for the current buffer"
line 3:     endif
line 4: 
line 5:     return self.equals(self.getNerdtree().root)
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..117()

line 1:     return self._nerdtree

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114()

line 1:     return self.path.str() ==# a:treenode.path.str()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40()

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45()

line 1:     let l:separator = s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45

line 2:     let l:leader = l:separator
line 3: 
line 4:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[4]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[4]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45

line 5:         let l:leader = self.drive . l:separator
line 6:     endif
line 7: 
line 8:     return l:leader . join(self.pathSegments, l:separator)
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40

line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[15]..nerdtree#has_opt({}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[15]..nerdtree#has_opt returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114

calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40()

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45()

line 1:     let l:separator = s:Path.Slash()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34[2]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[1]..34 returning '/'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45

line 2:     let l:leader = l:separator
line 3: 
line 4:     if nerdtree#runningWindows()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[4]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45[4]..nerdtree#runningWindows returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45

line 5:         let l:leader = self.drive . l:separator
line 6:     endif
line 7: 
line 8:     return l:leader . join(self.pathSegments, l:separator)
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[12]..45 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40

line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[15]..nerdtree#has_opt({}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40[15]..nerdtree#has_opt returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114[1]..40 returning '/home/w/repo/inz/kernel'

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121[5]..114 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[2]..121 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240

line 3:         return self.getRootLineNum()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[3]..241()

line 1:     let rootLine = 1
line 2:     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
line 3:         let rootLine = rootLine + 1
line 4:     endwhile
line 2:     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
line 3:         let rootLine = rootLine + 1
line 4:     endwhile
line 2:     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
line 3:         let rootLine = rootLine + 1
line 4:     endwhile
line 2:     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
line 3:         let rootLine = rootLine + 1
line 4:     endwhile
line 5:     return rootLine
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240[3]..241 returning #4

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128[1]..240 returning #4

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128

line 2:     if ln != -1
line 3:         if a:isJump
line 4:             mark '
line 5:         endif
line 6:         call cursor(ln, col("."))
line 7:     else
line 8:         if a:recurseUpward
line 9:             let node = self
line 10:             while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
line 11:                 let node = node.parent
line 12:                 call node.open()
line 13:             endwhile
line 14:             call self._nerdtree.render()
line 15:             call node.putCursorHere(a:isJump, 0)
line 16:         endif
line 17:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[22]..128 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190

line 23: 
line 24:     call self._broadcastInitEvent()
calling function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[24]..187()

line 1:     silent doautocmd User NERDTreeInit
No matching autocommands
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190[24]..187 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207[12]..190 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207

line 13:     endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206[2]..207 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206

function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate[12]..206 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate

line 13:     endif
line 14:   endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs[5]..<SNR>32_NERDTreeMirrorOrCreate returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs

line 6:   exe 'tabn ' . l:current_tab
line 6: tabn 1
line 7:   if g:nerdtree_tabs_autofind
line 8:     call s:NERDTreeUnfocus()
line 9:     call s:NERDTreeFindFile()
line 10:   endif
function <SNR>32_NERDTreeToggleAllTabs[7]..<SNR>32_NERDTreeOpenAllTabs returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs

line 8:     " force focus to NERDTree in current tab
line 9:     if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1
line 10:       exe bufwinnr(t:NERDTreeBufName) . "wincmd w"
line 10: 1wincmd w
line 11:     endif
line 12:   endif
line 13: 
line 14:   let s:disable_handlers_for_tabdo = 0
function <SNR>32_NERDTreeToggleAllTabs returning #0

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

calling function 40()

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
calling function 40[12]..45()

line 1:     let l:separator = s:Path.Slash()
calling function 40[12]..45[1]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function 40[12]..45[1]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function 40[12]..45[1]..34[2]..nerdtree#runningWindows returning #0

continuing in function 40[12]..45[1]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function 40[12]..45[1]..34 returning '/'

continuing in function 40[12]..45

line 2:     let l:leader = l:separator
line 3: 
line 4:     if nerdtree#runningWindows()
calling function 40[12]..45[4]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function 40[12]..45[4]..nerdtree#runningWindows returning #0

continuing in function 40[12]..45

line 5:         let l:leader = self.drive . l:separator
line 6:     endif
line 7: 
line 8:     return l:leader . join(self.pathSegments, l:separator)
function 40[12]..45 returning '/home/w/repo/inz/kernel'

continuing in function 40

line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function 40[15]..nerdtree#has_opt({}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function 40[15]..nerdtree#has_opt returning #0

continuing in function 40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function 40 returning '/home/w/repo/inz/kernel'

calling function 40()

line 1:     let options = a:0 ? a:1 : {}
line 2:     let toReturn = ""
line 3: 
line 4:     if has_key(options, 'format')
line 5:         let format = options['format']
line 6:         if has_key(self, '_strFor' . format)
line 7:             exec 'let toReturn = self._strFor' . format . '()'
line 8:         else
line 9:             throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
line 10:         endif
line 11:     else
line 12:         let toReturn = self._str()
calling function 40[12]..45()

line 1:     let l:separator = s:Path.Slash()
calling function 40[12]..45[1]..34()

line 1: 
line 2:     if nerdtree#runningWindows()
calling function 40[12]..45[1]..34[2]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function 40[12]..45[1]..34[2]..nerdtree#runningWindows returning #0

continuing in function 40[12]..45[1]..34

line 3:         if exists('+shellslash') && &shellslash
line 4:             return '/'
line 5:         endif
line 6: 
line 7:         return '\'
line 8:     endif
line 9: 
line 10:     return '/'
function 40[12]..45[1]..34 returning '/'

continuing in function 40[12]..45

line 2:     let l:leader = l:separator
line 3: 
line 4:     if nerdtree#runningWindows()
calling function 40[12]..45[4]..nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function 40[12]..45[4]..nerdtree#runningWindows returning #0

continuing in function 40[12]..45

line 5:         let l:leader = self.drive . l:separator
line 6:     endif
line 7: 
line 8:     return l:leader . join(self.pathSegments, l:separator)
function 40[12]..45 returning '/home/w/repo/inz/kernel'

continuing in function 40

line 13:     endif
line 14: 
line 15:     if nerdtree#has_opt(options, 'escape')
calling function 40[15]..nerdtree#has_opt({}, 'escape')

line 1:     return has_key(a:options, a:name) && a:options[a:name] == 1
function 40[15]..nerdtree#has_opt returning #0

continuing in function 40

line 16:         let toReturn = shellescape(toReturn)
line 17:     endif
line 18: 
line 19:     if has_key(options, 'truncateTo')
line 20:         let limit = options['truncateTo']
line 21:         if strdisplaywidth(toReturn) > limit-1
line 22:             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
line 23:                 let toReturn = substitute(toReturn, '^.', '', '')
line 24:             endwhile
line 25:             if len(split(toReturn, '/')) > 1
line 26:                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
line 27:             else
line 28:                 let toReturn = '<' . toReturn
line 29:             endif
line 30:         endif
line 31:     endif
line 32: 
line 33:     return toReturn
function 40 returning '/home/w/repo/inz/kernel'


calling function <SNR>32_NERDTreeToggleAllTabs()

line 1:   let l:nerdtree_open = s:IsNERDTreeOpenInCurrentTab()
calling function <SNR>32_NERDTreeToggleAllTabs[1]..<SNR>32_IsNERDTreeOpenInCurrentTab()

line 1:   return exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1
function <SNR>32_NERDTreeToggleAllTabs[1]..<SNR>32_IsNERDTreeOpenInCurrentTab returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs

line 2:   let s:disable_handlers_for_tabdo = 1
line 3: 
line 4:   if l:nerdtree_open
line 5:     call s:NERDTreeCloseAllTabs()
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs()

line 1:   let s:nerdtree_globally_active = 0
line 2: 
line 3:   " tabdo doesn't preserve current tab - save it and restore it afterwards
line 4:   let l:current_tab = tabpagenr()
line 5:   tabdo silent NERDTreeClose
line 5: silent NERDTreeClose
line 5: :call g:NERDTree.Close()
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217()

line 1:     if !s:NERDTree.IsOpen()
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[1]..227()

line 1:     return s:NERDTree.GetWinNum() != -1 || bufname('%') =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[1]..227[1]..226()

line 1:     if exists("t:NERDTreeBufName")
line 2:         return bufwinnr(t:NERDTreeBufName)
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[1]..227[1]..226 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[1]..227

function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[1]..227 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

line 2:         return
line 3:     endif
line 4: 
line 5:     if winnr("$") != 1
line 6:         " Use the window ID to identify the currently active window or fall
line 7:         " back on the buffer ID if win_getid/win_gotoid are not available, in
line 8:         " which case we'll focus an arbitrary window showing the buffer.
line 9:         let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
line 10: 
line 11:         if winnr() == s:NERDTree.GetWinNum()
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[11]..226()

line 1:     if exists("t:NERDTreeBufName")
line 2:         return bufwinnr(t:NERDTreeBufName)
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[11]..226 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

line 12:             call nerdtree#exec("wincmd p", 1)
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[12]..nerdtree#exec('wincmd p', 1)

line 1:     let old_ei = &ei
line 2:     if a:ignoreAll
line 3:         set ei=all
line 4:     endif
line 5:     exec a:cmd
line 5: wincmd p
line 6:     let &ei = old_ei
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[12]..nerdtree#exec returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

line 13:             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr("")
line 14:             call nerdtree#exec("wincmd p", 1)
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[14]..nerdtree#exec('wincmd p', 1)

line 1:     let old_ei = &ei
line 2:     if a:ignoreAll
line 3:         set ei=all
line 4:     endif
line 5:     exec a:cmd
line 5: wincmd p
line 6:     let &ei = old_ei
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[14]..nerdtree#exec returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

line 15:         else
line 16:             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr("")
line 17:         endif
line 18: 
line 19:         call nerdtree#exec(s:NERDTree.GetWinNum() . " wincmd w", 1)
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[19]..226()

line 1:     if exists("t:NERDTreeBufName")
line 2:         return bufwinnr(t:NERDTreeBufName)
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[19]..226 returning #1

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[19]..nerdtree#exec('1 wincmd w', 1)

line 1:     let old_ei = &ei
line 2:     if a:ignoreAll
line 3:         set ei=all
line 4:     endif
line 5:     exec a:cmd
line 5: 1 wincmd w
line 6:     let &ei = old_ei
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[19]..nerdtree#exec returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

line 20:         call nerdtree#exec("close", 0)
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[20]..nerdtree#exec('close', 0)

line 1:     let old_ei = &ei
line 2:     if a:ignoreAll
line 3:         set ei=all
line 4:     endif
line 5:     exec a:cmd
line 5: close
Executing BufLeave Autocommands for "NERD_tree_*"
autocommand if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif

line 0: if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif
calling function 227()

line 1:     return s:NERDTree.GetWinNum() != -1 || bufname('%') =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
calling function 227[1]..226()

line 1:     if exists("t:NERDTreeBufName")
line 2:         return bufwinnr(t:NERDTreeBufName)
function 227[1]..226 returning #1

continuing in function 227

function 227 returning #1

continuing in BufLeave Autocommands for "NERD_tree_*"

line 0:  call b:NERDTree.ui.saveScreenState() | endif
calling function 253()

line 1:     let win = winnr()
line 2:     call g:NERDTree.CursorToTreeWin()
calling function 253[2]..220()

line 1:     call g:NERDTree.MustBeOpen()
calling function 253[2]..220[1]..230()

line 1:     if !s:NERDTree.IsOpen()
calling function 253[2]..220[1]..230[1]..227()

line 1:     return s:NERDTree.GetWinNum() != -1 || bufname('%') =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
calling function 253[2]..220[1]..230[1]..227[1]..226()

line 1:     if exists("t:NERDTreeBufName")
line 2:         return bufwinnr(t:NERDTreeBufName)
function 253[2]..220[1]..230[1]..227[1]..226 returning #1

continuing in function 253[2]..220[1]..230[1]..227

function 253[2]..220[1]..230[1]..227 returning #1

continuing in function 253[2]..220[1]..230

line 2:         throw "NERDTree.TreeNotOpen"
line 3:     endif
function 253[2]..220[1]..230 returning #0

continuing in function 253[2]..220

line 2:     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w", 1)
calling function 253[2]..220[2]..226()

line 1:     if exists("t:NERDTreeBufName")
line 2:         return bufwinnr(t:NERDTreeBufName)
function 253[2]..220[2]..226 returning #1

continuing in function 253[2]..220

calling function 253[2]..220[2]..nerdtree#exec('1wincmd w', 1)

line 1:     let old_ei = &ei
line 2:     if a:ignoreAll
line 3:         set ei=all
line 4:     endif
line 5:     exec a:cmd
line 5: 1wincmd w
line 6:     let &ei = old_ei
function 253[2]..220[2]..nerdtree#exec returning #0

continuing in function 253[2]..220

function 253[2]..220 returning #0

continuing in function 253

line 3:     let self._screenState = {}
line 4:     let self._screenState['oldPos'] = getpos(".")
line 5:     let self._screenState['oldTopLine'] = line("w0")
line 6:     let self._screenState['oldWindowSize']= winwidth("")
line 7:     call nerdtree#exec(win . "wincmd w", 1)
calling function 253[7]..nerdtree#exec('1wincmd w', 1)

line 1:     let old_ei = &ei
line 2:     if a:ignoreAll
line 3:         set ei=all
line 4:     endif
line 5:     exec a:cmd
line 5: 1wincmd w
line 6:     let &ei = old_ei
function 253[7]..nerdtree#exec returning #0

continuing in function 253

function 253 returning #0

continuing in BufLeave Autocommands for "NERD_tree_*"

line 0:  endif
Executing WinLeave Autocommands for "*"
autocommand call <SID>WinLeaveHandler()

line 0: call <SID>WinLeaveHandler()
calling function <SNR>32_WinLeaveHandler()

line 1:   if s:disable_handlers_for_tabdo
line 2:     return
function <SNR>32_WinLeaveHandler returning #0

continuing in WinLeave Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call <SID>WinEnterHandler()

line 0: call <SID>WinEnterHandler()
calling function <SNR>32_WinEnterHandler()

line 1:   if s:disable_handlers_for_tabdo
line 2:     return
function <SNR>32_WinEnterHandler returning #0

continuing in WinEnter Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in WinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('/home/w/repo/inz/kernel/main/kmain.cpp')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

line 6:     let &ei = old_ei
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[20]..nerdtree#exec returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

line 21:         if l:useWinId
line 22:             call nerdtree#exec("call win_gotoid(" . l:activeBufOrWin . ")", 0)
calling function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[22]..nerdtree#exec('call win_gotoid(1000)', 0)

line 1:     let old_ei = &ei
line 2:     if a:ignoreAll
line 3:         set ei=all
line 4:     endif
line 5:     exec a:cmd
line 5: call win_gotoid(1000)
line 6:     let &ei = old_ei
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217[22]..nerdtree#exec returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217

line 23:         else
line 24:             call nerdtree#exec(bufwinnr(l:activeBufOrWin) . " wincmd w", 0)
line 25:         endif
line 26:     else
line 27:         close
line 28:     endif
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs[5]..217 returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs

line 6:   exe 'tabn ' . l:current_tab
line 6: tabn 1
function <SNR>32_NERDTreeToggleAllTabs[5]..<SNR>32_NERDTreeCloseAllTabs returning #0

continuing in function <SNR>32_NERDTreeToggleAllTabs

line 6:   else
line 7:     call s:NERDTreeOpenAllTabs()
line 8:     " force focus to NERDTree in current tab
line 9:     if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1
line 10:       exe bufwinnr(t:NERDTreeBufName) . "wincmd w"
line 11:     endif
line 12:   endif
line 13: 
line 14:   let s:disable_handlers_for_tabdo = 0
function <SNR>32_NERDTreeToggleAllTabs returning #0

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
line 37:     endif
line 38:   endif
line 39: 
line 40:   " Figure out the arguments for searchpairpos().
line 41:   if i % 2 == 0
line 42:     let s_flags = 'nW'
line 43:     let c2 = plist[i + 1]
line 44:   else
line 45:     let s_flags = 'nbW'
line 46:     let c2 = c
line 47:     let c = plist[i - 1]
line 48:   endif
line 49:   if c == '['
line 50:     let c = '\['
line 51:     let c2 = '\]'
line 52:   endif
line 53: 
line 54:   " Find the match.  When it was just before the cursor move it there for a
line 55:   " moment.
line 56:   if before > 0
line 57:     let has_getcurpos = exists("*getcurpos")
line 58:     if has_getcurpos
line 59:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 60:       let save_cursor = getcurpos()
line 61:     else
line 62:       let save_cursor = winsaveview()
line 63:     endif
line 64:     call cursor(c_lnum, c_col - before)
line 65:   endif
line 66: 
line 67:   if !has("syntax") || !exists("g:syntax_on")
line 68:     let s_skip = "0"
line 69:   else
line 70:     " Build an expression that detects whether the current cursor position is
line 71:     " in certain syntax types (string, comment, etc.), for use as
line 72:     " searchpairpos()'s skip argument.
line 73:     " We match "escape" for special items, such as lispEscapeSpecial.
line 74:     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
line 76:     " If executing the expression determines that the cursor is currently in
line 77:     " one of the syntax types, then we want searchpairpos() to find the pair
line 78:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 79:     " outside of the syntax types and s_skip should keep its value so we skip
line 80:     " any matching pair inside the syntax types.
line 81:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 82:     try
line 83:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 83: if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"')) | let s_skip = "0" | endif
line 83:  let s_skip = "0" | endif
line 83:  endif
line 84:     catch /^Vim\%((\a\+)\)\=:E363/
line 85:       " We won't find anything, so skip searching, should keep Vim responsive.
line 86:       return
line 87:     endtry
line 88:   endif
line 89: 
line 90:   " Limit the search to lines visible in the window.
line 91:   let stoplinebottom = line('w$')
line 92:   let stoplinetop = line('w0')
line 93:   if i % 2 == 0
line 94:     let stopline = stoplinebottom
line 95:   else
line 96:     let stopline = stoplinetop
line 97:   endif
line 98: 
line 99:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 100:   " This fails when a timeout is not supported.
line 101:   if mode() == 'i' || mode() == 'R'
line 102:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 103:   else
line 104:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 105:   endif
line 106:   try
line 107:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 108:   catch /E118/
line 109:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 110:     " a long time on closed folds and long lines.
line 111:     " The "viewable" variables give a range in which we can scroll while
line 112:     " keeping the cursor at the same position.
line 113:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 114:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 115:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 116:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 117:     " one of these stoplines will be adjusted below, but the current values are
line 118:     " minimal boundaries within the current window
line 119:     if i % 2 == 0
line 120:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 121: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 122: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 123:       else
line 124: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 125:       endif
line 126:       let stoplinebottom = stopline
line 127:     else
line 128:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 129: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 130: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 131:       else
line 132: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 133:       endif
line 134:       let stoplinetop = stopline
line 135:     endif
line 136:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 137:   endtry
line 138: 
line 139:   if before > 0
line 140:     if has_getcurpos
line 141:       call setpos('.', save_cursor)
line 142:     else
line 143:       call winrestview(save_cursor)
line 144:     endif
line 145:   endif
line 146: 
line 147:   " If a match is found setup match highlighting.
line 148:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 149:     if exists('*matchaddpos')
line 150:       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
line 151:     else
line 152:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 154:     endif
line 155:     let w:paren_hl_on = 1
line 156:   endif
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
line 37:     endif
line 38:   endif
line 39: 
line 40:   " Figure out the arguments for searchpairpos().
line 41:   if i % 2 == 0
line 42:     let s_flags = 'nW'
line 43:     let c2 = plist[i + 1]
line 44:   else
line 45:     let s_flags = 'nbW'
line 46:     let c2 = c
line 47:     let c = plist[i - 1]
line 48:   endif
line 49:   if c == '['
line 50:     let c = '\['
line 51:     let c2 = '\]'
line 52:   endif
line 53: 
line 54:   " Find the match.  When it was just before the cursor move it there for a
line 55:   " moment.
line 56:   if before > 0
line 57:     let has_getcurpos = exists("*getcurpos")
line 58:     if has_getcurpos
line 59:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 60:       let save_cursor = getcurpos()
line 61:     else
line 62:       let save_cursor = winsaveview()
line 63:     endif
line 64:     call cursor(c_lnum, c_col - before)
line 65:   endif
line 66: 
line 67:   if !has("syntax") || !exists("g:syntax_on")
line 68:     let s_skip = "0"
line 69:   else
line 70:     " Build an expression that detects whether the current cursor position is
line 71:     " in certain syntax types (string, comment, etc.), for use as
line 72:     " searchpairpos()'s skip argument.
line 73:     " We match "escape" for special items, such as lispEscapeSpecial.
line 74:     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
line 76:     " If executing the expression determines that the cursor is currently in
line 77:     " one of the syntax types, then we want searchpairpos() to find the pair
line 78:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 79:     " outside of the syntax types and s_skip should keep its value so we skip
line 80:     " any matching pair inside the syntax types.
line 81:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 82:     try
line 83:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 83: if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"')) | let s_skip = "0" | endif
line 83:  let s_skip = "0" | endif
line 83:  endif
line 84:     catch /^Vim\%((\a\+)\)\=:E363/
line 85:       " We won't find anything, so skip searching, should keep Vim responsive.
line 86:       return
line 87:     endtry
line 88:   endif
line 89: 
line 90:   " Limit the search to lines visible in the window.
line 91:   let stoplinebottom = line('w$')
line 92:   let stoplinetop = line('w0')
line 93:   if i % 2 == 0
line 94:     let stopline = stoplinebottom
line 95:   else
line 96:     let stopline = stoplinetop
line 97:   endif
line 98: 
line 99:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 100:   " This fails when a timeout is not supported.
line 101:   if mode() == 'i' || mode() == 'R'
line 102:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 103:   else
line 104:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 105:   endif
line 106:   try
line 107:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 108:   catch /E118/
line 109:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 110:     " a long time on closed folds and long lines.
line 111:     " The "viewable" variables give a range in which we can scroll while
line 112:     " keeping the cursor at the same position.
line 113:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 114:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 115:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 116:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 117:     " one of these stoplines will be adjusted below, but the current values are
line 118:     " minimal boundaries within the current window
line 119:     if i % 2 == 0
line 120:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 121: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 122: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 123:       else
line 124: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 125:       endif
line 126:       let stoplinebottom = stopline
line 127:     else
line 128:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 129: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 130: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 131:       else
line 132: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 133:       endif
line 134:       let stoplinetop = stopline
line 135:     endif
line 136:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 137:   endtry
line 138: 
line 139:   if before > 0
line 140:     if has_getcurpos
line 141:       call setpos('.', save_cursor)
line 142:     else
line 143:       call winrestview(save_cursor)
line 144:     endif
line 145:   endif
line 146: 
line 147:   " If a match is found setup match highlighting.
line 148:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 149:     if exists('*matchaddpos')
line 150:       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
line 151:     else
line 152:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 154:     endif
line 155:     let w:paren_hl_on = 1
line 156:   endif
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
line 37:     endif
line 38:   endif
line 39: 
line 40:   " Figure out the arguments for searchpairpos().
line 41:   if i % 2 == 0
line 42:     let s_flags = 'nW'
line 43:     let c2 = plist[i + 1]
line 44:   else
line 45:     let s_flags = 'nbW'
line 46:     let c2 = c
line 47:     let c = plist[i - 1]
line 48:   endif
line 49:   if c == '['
line 50:     let c = '\['
line 51:     let c2 = '\]'
line 52:   endif
line 53: 
line 54:   " Find the match.  When it was just before the cursor move it there for a
line 55:   " moment.
line 56:   if before > 0
line 57:     let has_getcurpos = exists("*getcurpos")
line 58:     if has_getcurpos
line 59:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 60:       let save_cursor = getcurpos()
line 61:     else
line 62:       let save_cursor = winsaveview()
line 63:     endif
line 64:     call cursor(c_lnum, c_col - before)
line 65:   endif
line 66: 
line 67:   if !has("syntax") || !exists("g:syntax_on")
line 68:     let s_skip = "0"
line 69:   else
line 70:     " Build an expression that detects whether the current cursor position is
line 71:     " in certain syntax types (string, comment, etc.), for use as
line 72:     " searchpairpos()'s skip argument.
line 73:     " We match "escape" for special items, such as lispEscapeSpecial.
line 74:     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
line 76:     " If executing the expression determines that the cursor is currently in
line 77:     " one of the syntax types, then we want searchpairpos() to find the pair
line 78:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 79:     " outside of the syntax types and s_skip should keep its value so we skip
line 80:     " any matching pair inside the syntax types.
line 81:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 82:     try
line 83:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 83: if !empty(filter(map(synstack(line("."), col(".")), 'synIDattr(v:val, "name")'), 'v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"')) | let s_skip = "0" | endif
line 83:  let s_skip = "0" | endif
line 83:  endif
line 84:     catch /^Vim\%((\a\+)\)\=:E363/
line 85:       " We won't find anything, so skip searching, should keep Vim responsive.
line 86:       return
line 87:     endtry
line 88:   endif
line 89: 
line 90:   " Limit the search to lines visible in the window.
line 91:   let stoplinebottom = line('w$')
line 92:   let stoplinetop = line('w0')
line 93:   if i % 2 == 0
line 94:     let stopline = stoplinebottom
line 95:   else
line 96:     let stopline = stoplinetop
line 97:   endif
line 98: 
line 99:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 100:   " This fails when a timeout is not supported.
line 101:   if mode() == 'i' || mode() == 'R'
line 102:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 103:   else
line 104:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 105:   endif
line 106:   try
line 107:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 108:   catch /E118/
line 109:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 110:     " a long time on closed folds and long lines.
line 111:     " The "viewable" variables give a range in which we can scroll while
line 112:     " keeping the cursor at the same position.
line 113:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 114:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 115:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 116:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 117:     " one of these stoplines will be adjusted below, but the current values are
line 118:     " minimal boundaries within the current window
line 119:     if i % 2 == 0
line 120:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 121: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 122: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 123:       else
line 124: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 125:       endif
line 126:       let stoplinebottom = stopline
line 127:     else
line 128:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 129: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 130: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 131:       else
line 132: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 133:       endif
line 134:       let stoplinetop = stopline
line 135:     endif
line 136:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 137:   endtry
line 138: 
line 139:   if before > 0
line 140:     if has_getcurpos
line 141:       call setpos('.', save_cursor)
line 142:     else
line 143:       call winrestview(save_cursor)
line 144:     endif
line 145:   endif
line 146: 
line 147:   " If a match is found setup match highlighting.
line 148:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 149:     if exists('*matchaddpos')
line 150:       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
line 151:     else
line 152:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 154:     endif
line 155:     let w:paren_hl_on = 1
line 156:   endif
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"


calling function rtags#FindRefsCallTree()

line 1:     let args = { '--containing-function-location' : '', '-r' : rtags#getCurrentLocation() }
calling function rtags#FindRefsCallTree[1]..rtags#getCurrentLocation()

line 1:     let [lnum, col] = getpos('.')[1:2]
line 2:     return printf("%s:%s:%s", expand("%:p"), lnum, col)
chdir(main)
fchdir() to previous dir
function rtags#FindRefsCallTree[1]..rtags#getCurrentLocation returning '/home/w/repo/inz/kernel/main/kmain.cpp:15:9'

continuing in function rtags#FindRefsCallTree

line 4: 
line 5:     call rtags#ExecuteThen(args, [function('rtags#ViewReferences')])
calling function rtags#FindRefsCallTree[5]..rtags#ExecuteThen({'--containing-function-location': '',...w/repo/inz/kernel/main/kmain.cpp:15:9'}, [function('rtags#ViewReferences')])

line 1:     if s:rtagsAsync == 1
line 2:         call rtags#ExecuteRCAsync(a:args, a:handlers)
calling function rtags#FindRefsCallTree[5]..rtags#ExecuteThen[2]..rtags#ExecuteRCAsync({'--containing-function-location': '',...w/repo/inz/kernel/main/kmain.cpp:15:9'}, [function('rtags#ViewReferences')])

line 1:     let cmd = rtags#getRcCmd()
calling function rtags#FindRefsCallTree[5]..rtags#ExecuteThen[2]..rtags#ExecuteRCAsync[1]..rtags#getRcCmd()

line 1:     let cmd = g:rtagsRcCmd
line 2:     let cmd .= " --absolute-path "
line 3:     if g:rtagsExcludeSysHeaders == 1
line 4:         return cmd." -H "
line 5:     endif
line 6:     return cmd
function rtags#FindRefsCallTree[5]..rtags#ExecuteThen[2]..rtags#ExecuteRCAsync[1]..rtags#getRcCmd returning 'rc --absolute-path '

continuing in function rtags#FindRefsCallTree[5]..rtags#ExecuteThen[2]..rtags#ExecuteRCAsync

line 2: 
line 3:     " Give rdm unsaved file content, so that you don't have to save files
line 4:     " before each rc invocation.
line 5:     if exists('b:rtags_sent_content')
line 6:         let content = join(getline(1, line('$')), "\n")
line 7:         if b:rtags_sent_content != content
line 8:             let unsaved_content = content
line 9:         endif
line 10:     elseif &modified
line 11:         let unsaved_content = join(getline(1, line('$')), "\n")
line 12:     endif
line 13:     if exists('unsaved_content')
line 14:         let filename = expand("%")
line 15:         let output = system(printf("%s --unsaved-file=%s:%s -V %s", cmd, filename, strlen(unsaved_content), filename), unsaved_content)
line 16:         let b:rtags_sent_content = unsaved_content
line 17:     endif
line 18: 
line 19:     " prepare for the actual command invocation
line 20:     for [key, value] in items(a:args)
line 21:         let cmd .= " ".key
line 22:         if len(value) > 1
line 23:             let cmd .= " ".value
line 24:         endif
line 25:     endfor
line 20:     for [key, value] in items(a:args)
line 21:         let cmd .= " ".key
line 22:         if len(value) > 1
line 23:             let cmd .= " ".value
line 24:         endif
line 25:     endfor
line 20:     for [key, value] in items(a:args)
line 21:         let cmd .= " ".key
line 22:         if len(value) > 1
line 23:             let cmd .= " ".value
line 24:         endif
line 25:     endfor
line 26: 
line 27:     let s:callbacks = { 'on_exit' : function('rtags#HandleResults') }
line 30: 
line 31:     let s:job_cid = s:job_cid + 1
line 32:     " should have out+err redirection portable for various shells.
line 33:     if has('nvim')
line 34:         let cmd = cmd . ' >' . rtags#TempFile(s:job_cid) . ' 2>&1'
line 35:         let job = jobstart(cmd, s:callbacks)
line 36:         let s:jobs[job] = s:job_cid
line 37:         let s:result_handlers[job] = a:handlers
line 38:     elseif has('job') && has('channel')
line 39:         let l:opts = {}
line 40:         let l:opts.mode = 'nl'
line 41:         let l:opts.out_cb = {ch, data -> rtags#HandleResults(ch_info(ch).id, data, 'vim_stdout')}
line 42:         let l:opts.exit_cb = {ch, data -> rtags#HandleResults(ch_info(ch).id, data,'vim_exit')}
line 43:         let l:opts.stoponexit = 'kill'
line 44:         let job = job_start(cmd, l:opts)
line 45:         let channel = ch_info(job_getchannel(job)).id
line 46:         let s:result_stdout[channel] = []
line 47:         let s:jobs[channel] = s:job_cid
line 48:         let s:result_handlers[channel] = a:handlers
line 49:     endif
line 50: 
function rtags#FindRefsCallTree[5]..rtags#ExecuteThen[2]..rtags#ExecuteRCAsync returning #0

continuing in function rtags#FindRefsCallTree[5]..rtags#ExecuteThen

line 3:     else
line 4:         let result = rtags#ExecuteRC(a:args)
line 5:         call rtags#ExecuteHandlers(result, a:handlers)
line 6:     endif
function rtags#FindRefsCallTree[5]..rtags#ExecuteThen returning #0

continuing in function rtags#FindRefsCallTree

function rtags#FindRefsCallTree returning #0

calling function <lambda>1(channel 0 open, 'Not indexed')

line 1: return rtags#HandleResults(ch_info(ch).id, data, 'vim_stdout')
calling function <lambda>1[1]..rtags#HandleResults(0, 'Not indexed', 'vim_stdout')

line 1: 
line 2: 
line 3:     if a:event == 'vim_stdout'
line 4:         call add(s:result_stdout[a:job_id], a:data)
line 5:     elseif a:event == 'vim_exit'
line 6: 
line 7:         let job_cid = remove(s:jobs, a:job_id)
line 8:         let handlers = remove(s:result_handlers, a:job_id)
line 9:         let output = remove(s:result_stdout, a:job_id)
line 10: 
line 11:         call rtags#ExecuteHandlers(output, handlers)
line 12:     else
line 13:         let job_cid = remove(s:jobs, a:job_id)
line 14:         let temp_file = rtags#TempFile(job_cid)
line 15:         let output = readfile(temp_file)
line 16:         let handlers = remove(s:result_handlers, a:job_id)
line 17:         call rtags#ExecuteHandlers(output, handlers)
line 18:         execute 'silent !rm -f ' . temp_file
line 19:     endif
line 20: 
function <lambda>1[1]..rtags#HandleResults returning #0

continuing in function <lambda>1

function <lambda>1 returning #0

calling function <lambda>2(process 32212 dead, 35)

line 1: return rtags#HandleResults(ch_info(ch).id, data,'vim_exit')
calling function <lambda>2[1]..rtags#HandleResults(0, 35, 'vim_exit')

line 1: 
line 2: 
line 3:     if a:event == 'vim_stdout'
line 4:         call add(s:result_stdout[a:job_id], a:data)
line 5:     elseif a:event == 'vim_exit'
line 6: 
line 7:         let job_cid = remove(s:jobs, a:job_id)
line 8:         let handlers = remove(s:result_handlers, a:job_id)
line 9:         let output = remove(s:result_stdout, a:job_id)
line 10: 
line 11:         call rtags#ExecuteHandlers(output, handlers)
calling function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers(['Not indexed'], [function('rtags#ViewReferences')])

line 1:     let result = a:output
line 2:     for Handler in a:handlers
line 3:         if type(Handler) == 3
line 4:             let HandlerFunc = Handler[0]
line 5:             let args = Handler[1]
line 6:             call HandlerFunc(result, args)
line 7:         else
line 8:             try
line 9:                 let result = Handler(result)
calling function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences(['Not indexed'])

line 1:     let cmd = g:rtagsMaxSearchResultWindowHeight . "new References"
line 2:     silent execute cmd
line 2: 10new References
Executing WinLeave Autocommands for "*"
autocommand call <SID>WinLeaveHandler()

line 0: call <SID>WinLeaveHandler()
calling function <SNR>32_WinLeaveHandler()

line 1:   if s:disable_handlers_for_tabdo
line 2:     return
line 3:   endif
line 4: 
line 5:   if g:nerdtree_tabs_synchronize_view
line 6:     call s:SaveNERDTreeViewIfPossible()
calling function <SNR>32_WinLeaveHandler[6]..<SNR>32_SaveNERDTreeViewIfPossible()

line 1:   if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) == winnr()
line 2:     " save scroll and cursor etc.
line 3:     let s:nerdtree_view = winsaveview()
line 4: 
line 5:     " save NERDTree window width
line 6:     let s:nerdtree_width = winwidth(winnr())
line 7: 
line 8:     " save buffer name (to be able to correct desync by commands spawning
line 9:     " a new NERDTree instance)
line 10:     let s:nerdtree_buffer = bufname("%")
line 11:   endif
function <SNR>32_WinLeaveHandler[6]..<SNR>32_SaveNERDTreeViewIfPossible returning #0

continuing in function <SNR>32_WinLeaveHandler

line 7:   endif
function <SNR>32_WinLeaveHandler returning #0

continuing in WinLeave Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call <SID>WinEnterHandler()

line 0: call <SID>WinEnterHandler()
calling function <SNR>32_WinEnterHandler()

line 1:   if s:disable_handlers_for_tabdo
line 2:     return
line 3:   endif
line 4: 
line 5:   " We need to handle VimLeave properly.
line 6:   " But we shouldn't nest redefined autocmds
line 7:   let s:ei = &eventignore
line 8:   let &eventignore = 'VimEnter,TabEnter,TabLeave,WinEnter,WinLeave,BufWinEnter,BufRead'
line 9:   if g:nerdtree_tabs_autoclose
line 10:     call s:CloseIfOnlyNerdTreeLeft()
calling function <SNR>32_WinEnterHandler[10]..<SNR>32_CloseIfOnlyNerdTreeLeft()

line 1:   if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1 && winnr("$") == 1
line 2:     q
line 3:   endif
function <SNR>32_WinEnterHandler[10]..<SNR>32_CloseIfOnlyNerdTreeLeft returning #0

continuing in function <SNR>32_WinEnterHandler

line 11:   endif
line 12:   let &eventignore = s:ei
function <SNR>32_WinEnterHandler returning #0

continuing in WinEnter Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in WinEnter Autocommands for "*"

chdir(/home/w/repo/inz/kernel)
fchdir() to previous dir
Reading viminfo file "/home/w/.viminfo" marks
Executing BufNewFile Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 0:  runtime! scripts.vim | endif
Searching for "scripts.vim" in "/home/w/.vim,/home/w/.vim/bundle/nerdtree,/home/w/.vim/bundle/vim-nerdtree-tabs,/home/w/.vim/bundle/vim-rtags,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/w/.vim/after"
Searching for "/home/w/.vim/scripts.vim"
Searching for "/home/w/.vim/bundle/nerdtree/scripts.vim"
Searching for "/home/w/.vim/bundle/vim-nerdtree-tabs/scripts.vim"
Searching for "/home/w/.vim/bundle/vim-rtags/scripts.vim"
Searching for "/usr/share/vim/vimfiles/scripts.vim"
Searching for "/usr/share/vim/vim81/scripts.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 0: sourcing "/usr/share/vim/vim81/scripts.vim"
line 1: " Vim support file to detect file types in scripts
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2018 Feb 03
line 5: 
line 6: " This file is called by an autocommand for every file that has just been
line 7: " loaded into a buffer.  It checks if the type of file can be recognized by
line 8: " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
line 9: "
line 10: " Note that the pattern matches are done with =~# to avoid the value of the
line 11: " 'ignorecase' option making a difference.  Where case is to be ignored use
line 12: " =~? instead.  Do not use =~ anywhere.
line 13: 
line 14: 
line 15: " Only do the rest when the FileType autocommand has not been triggered yet.
line 16: if did_filetype()
line 17:   finish
line 18: endif
line 19: 
line 20: " Load the user defined scripts file first
line 21: " Only do this when the FileType autocommand has not been triggered yet
line 22: if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
line 23:   execute "source " . myscriptsfile
line 24:   if did_filetype()
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Line continuation is used here, remove 'C' from 'cpoptions'
line 30: let s:cpo_save = &cpo
line 31: set cpo&vim
line 32: 
line 33: let s:line1 = getline(1)
line 34: 
line 35: if s:line1 =~# "^#!"
line 36:   " A script that starts with "#!".
line 37: 
line 38:   " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
line 39:   " "#!/usr/bin/bash" to make matching easier.
line 40:   if s:line1 =~# '^#!\s*\S*\<env\s'
line 41:     let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
line 42:     let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
line 43:   endif
line 44: 
line 45:   " Get the program name.
line 46:   " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
line 47:   " If the word env is used, use the first word after the space:
line 48:   " "#!/usr/bin/env perl [path/args]"
line 49:   " If there is no path use the first word: "#!perl [path/args]".
line 50:   " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
line 51:   if s:line1 =~# '^#!\s*\a:[/\\]'
line 52:     let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
line 53:   elseif s:line1 =~# '^#!.*\<env\>'
line 54:     let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
line 55:   elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
line 56:     let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
line 57:   else
line 58:     let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
line 59:   endif
line 60: 
line 61:   " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
line 62:   " third line.  Suggested by Steven Atkinson.
line 63:   if getline(3) =~# '^exec wish'
line 64:     let s:name = 'wish'
line 65:   endif
line 66: 
line 67:   " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
line 68:   if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
line 69:     call dist#ft#SetFileTypeSH(s:line1)^I" defined in filetype.vim
line 70: 
line 71:     " csh scripts
line 72:   elseif s:name =~# '^csh\>'
line 73:     if exists("g:filetype_csh")
line 74:       call dist#ft#SetFileTypeShell(g:filetype_csh)
line 75:     else
line 76:       call dist#ft#SetFileTypeShell("csh")
line 77:     endif
line 78: 
line 79:     " tcsh scripts
line 80:   elseif s:name =~# '^tcsh\>'
line 81:     call dist#ft#SetFileTypeShell("tcsh")
line 82: 
line 83:     " Z shell scripts
line 84:   elseif s:name =~# '^zsh\>'
line 85:     set ft=zsh
line 86: 
line 87:     " TCL scripts
line 88:   elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
line 89:     set ft=tcl
line 90: 
line 91:     " Expect scripts
line 92:   elseif s:name =~# '^expect\>'
line 93:     set ft=expect
line 94: 
line 95:     " Gnuplot scripts
line 96:   elseif s:name =~# '^gnuplot\>'
line 97:     set ft=gnuplot
line 98: 
line 99:     " Makefiles
line 100:   elseif s:name =~# 'make\>'
line 101:     set ft=make
line 102: 
line 103:     " Pike
line 104:   elseif s:name =~# '^pike\%(\>\|[0-9]\)'
line 105:     set ft=pike
line 106: 
line 107:     " Lua
line 108:   elseif s:name =~# 'lua'
line 109:     set ft=lua
line 110: 
line 111:     " Perl 6
line 112:   elseif s:name =~# 'perl6'
line 113:     set ft=perl6
line 114: 
line 115:     " Perl
line 116:   elseif s:name =~# 'perl'
line 117:     set ft=perl
line 118: 
line 119:     " PHP
line 120:   elseif s:name =~# 'php'
line 121:     set ft=php
line 122: 
line 123:     " Python
line 124:   elseif s:name =~# 'python'
line 125:     set ft=python
line 126: 
line 127:     " Groovy
line 128:   elseif s:name =~# '^groovy\>'
line 129:     set ft=groovy
line 130: 
line 131:     " Ruby
line 132:   elseif s:name =~# 'ruby'
line 133:     set ft=ruby
line 134: 
line 135:     " JavaScript
line 136:   elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
line 137:     set ft=javascript
line 138: 
line 139:     " BC calculator
line 140:   elseif s:name =~# '^bc\>'
line 141:     set ft=bc
line 142: 
line 143:     " sed
line 144:   elseif s:name =~# 'sed\>'
line 145:     set ft=sed
line 146: 
line 147:     " OCaml-scripts
line 148:   elseif s:name =~# 'ocaml'
line 149:     set ft=ocaml
line 150: 
line 151:     " Awk scripts
line 152:   elseif s:name =~# 'awk\>'
line 153:     set ft=awk
line 154: 
line 155:     " Website MetaLanguage
line 156:   elseif s:name =~# 'wml'
line 157:     set ft=wml
line 158: 
line 159:     " Scheme scripts
line 160:   elseif s:name =~# 'scheme'
line 161:     set ft=scheme
line 162: 
line 163:     " CFEngine scripts
line 164:   elseif s:name =~# 'cfengine'
line 165:     set ft=cfengine
line 166: 
line 167:     " Erlang scripts
line 168:   elseif s:name =~# 'escript'
line 169:     set ft=erlang
line 170: 
line 171:     " Haskell
line 172:   elseif s:name =~# 'haskell'
line 173:     set ft=haskell
line 174: 
line 175:     " Scala
line 176:   elseif s:name =~# 'scala\>'
line 177:     set ft=scala
line 178: 
line 179:     " Clojure
line 180:   elseif s:name =~# 'clojure'
line 181:     set ft=clojure
line 182: 
line 183:   endif
line 184:   unlet s:name
line 185: 
line 186: else
line 187:   " File does not start with "#!".
line 188: 
line 189:   let s:line2 = getline(2)
line 190:   let s:line3 = getline(3)
line 191:   let s:line4 = getline(4)
line 192:   let s:line5 = getline(5)
line 193: 
line 194:   " Bourne-like shell scripts: sh ksh bash bash2
line 195:   if s:line1 =~# '^:$'
line 196:     call dist#ft#SetFileTypeSH(s:line1)^I" defined in filetype.vim
line 197: 
line 198:     " Z shell scripts
line 200:   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' || "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
line 201:     set ft=zsh
line 202: 
line 203:   " ELM Mail files
line 204:   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
line 205:     set ft=mail
line 206: 
line 207:     " Mason
line 208:   elseif s:line1 =~# '^<[%&].*>'
line 209:     set ft=mason
line 210: 
line 211:     " Vim scripts (must have '" vim' as the first line to trigger this)
line 212:   elseif s:line1 =~# '^" *[vV]im$'
line 213:     set ft=vim
line 214: 
line 215:     " MOO
line 216:   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
line 217:     set ft=moo
line 218: 
line 219:     " Diff file:
line 220:     " - "diff" in first line (context diff)
line 221:     " - "Only in " in first line
line 222:     " - "--- " in first line and "+++ " in second line (unified diff).
line 223:     " - "*** " in first line and "--- " in second line (context diff).
line 224:     " - "# It was generated by makepatch " in the second line (makepatch diff).
line 225:     " - "Index: <filename>" in the first line (CVS file)
line 226:     " - "=== ", line of "=", "---", "+++ " (SVK diff)
line 227:     " - "=== ", "--- ", "+++ " (bzr diff, common case)
line 228:     " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
line 229:     " - "# HG changeset patch" in first line (Mercurial export format)
line 235:   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)' || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ') || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ') || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ') || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ '))) || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
line 236:     set ft=diff
line 237: 
line 238:     " PostScript Files (must have %!PS as the first line, like a2ps output)
line 239:   elseif s:line1 =~# '^%![ \t]*PS'
line 240:     set ft=postscr
line 241: 
line 242:     " M4 scripts: Guess there is a line that starts with "dnl".
line 247:   elseif s:line1 =~# '^\s*dnl\>' || s:line2 =~# '^\s*dnl\>' || s:line3 =~# '^\s*dnl\>' || s:line4 =~# '^\s*dnl\>' || s:line5 =~# '^\s*dnl\>'
line 248:     set ft=m4
line 249: 
line 250:     " AmigaDos scripts
line 252:   elseif $TERM == "amiga" && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
line 253:     set ft=amiga
line 254: 
line 255:     " SiCAD scripts (must have procn or procd as the first line to trigger this)
line 256:   elseif s:line1 =~? '^ *proc[nd] *$'
line 257:     set ft=sicad
line 258: 
line 259:     " Purify log files start with "****  Purify"
line 260:   elseif s:line1 =~# '^\*\*\*\*  Purify'
line 261:     set ft=purifylog
line 262: 
line 263:     " XML
line 264:   elseif s:line1 =~# '<?\s*xml.*?>'
line 265:     set ft=xml
line 266: 
line 267:     " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
line 268:   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
line 269:     set ft=xhtml
line 270: 
line 271:     " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
line 272:     " Avoid "doctype html", used by slim.
line 273:   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
line 274:     set ft=html
line 275: 
line 276:     " PDF
line 277:   elseif s:line1 =~# '^%PDF-'
line 278:     set ft=pdf
line 279: 
line 280:     " XXD output
line 281:   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
line 282:     set ft=xxd
line 283: 
line 284:     " RCS/CVS log output
line 285:   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
line 286:     set ft=rcslog
line 287: 
line 288:     " CVS commit
line 289:   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
line 290:     set ft=cvs
line 291: 
line 292:     " Prescribe
line 293:   elseif s:line1 =~# '^!R!'
line 294:     set ft=prescribe
line 295: 
line 296:     " Send-pr
line 297:   elseif s:line1 =~# '^SEND-PR:'
line 298:     set ft=sendpr
line 299: 
line 300:     " SNNS files
line 301:   elseif s:line1 =~# '^SNNS network definition file'
line 302:     set ft=snnsnet
line 303:   elseif s:line1 =~# '^SNNS pattern definition file'
line 304:     set ft=snnspat
line 305:   elseif s:line1 =~# '^SNNS result file'
line 306:     set ft=snnsres
line 307: 
line 308:     " Virata
line 313:   elseif s:line1 =~# '^%.\{-}[Vv]irata' || s:line2 =~# '^%.\{-}[Vv]irata' || s:line3 =~# '^%.\{-}[Vv]irata' || s:line4 =~# '^%.\{-}[Vv]irata' || s:line5 =~# '^%.\{-}[Vv]irata'
line 314:     set ft=virata
line 315: 
line 316:     " Strace
line 317:   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
line 318:     set ft=strace
line 319: 
line 320:     " VSE JCL
line 321:   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
line 322:     set ft=vsejcl
line 323: 
line 324:     " TAK and SINDA
line 325:   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
line 326:     set ft=takout
line 327:   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
line 328:     set ft=sindaout
line 329:   elseif getline(6) =~# 'Run Date: '
line 330:     set ft=takcmp
line 331:   elseif getline(9) =~# 'Node    File  1'
line 332:     set ft=sindacmp
line 333: 
line 334:     " DNS zone files
line 335:   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
line 336:     set ft=bindzone
line 337: 
line 338:     " BAAN
line 340:   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC ' || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
line 341:     set ft=baan
line 342: 
line 343:   " Valgrind
line 344:   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
line 345:     set ft=valgrind
line 346: 
line 347:   " Go docs
line 348:   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
line 349:     set ft=godoc
line 350: 
line 351:   " Renderman Interface Bytestream
line 352:   elseif s:line1 =~# '^##RenderMan'
line 353:     set ft=rib
line 354: 
line 355:   " Scheme scripts
line 356:   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
line 357:     set ft=scheme
line 358: 
line 359:   " Git output
line 360:   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
line 361:     set ft=git
line 362: 
line 363:    " Gprof (gnu profiler)
line 366:    elseif s:line1 == 'Flat profile:' && s:line2 == '' && s:line3 =~# '^Each sample counts as .* seconds.$'
line 367:      set ft=gprof
line 368: 
line 369:   " Erlang terms
line 370:   " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
line 371:   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
line 372:     set ft=erlang
line 373: 
line 374:   " CVS diff
line 375:   else
line 376:     let s:lnum = 1
line 377:     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
line 378:       let s:lnum += 1
line 379:     endwhile
line 380:     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
line 381:       set ft=diff
line 382: 
line 383:       " locale input files: Formal Definitions of Cultural Conventions
line 384:       " filename must be like en_US, fr_FR@euro or en_US.UTF-8
line 385:     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
line 386:       let s:lnum = 1
line 387:       while s:lnum < 100 && s:lnum < line("$")
line 388: ^Iif getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
line 389: ^I  setf fdcc
line 390: ^I  break
line 391: ^Iendif
line 392: ^Ilet s:lnum += 1
line 393:       endwhile
line 394:     endif
line 395:     unlet s:lnum
line 396: 
line 397:   endif
line 398: 
line 399:   unlet s:line2 s:line3 s:line4 s:line5
line 400: 
line 401: endif
line 402: 
line 403: " Restore 'cpoptions'
line 404: let &cpo = s:cpo_save
line 405: 
line 406: unlet s:cpo_save s:line1
finished sourcing /usr/share/vim/vim81/scripts.vim
continuing in BufNewFile Autocommands for "*"
Searching for "/usr/share/vim/vimfiles/after/scripts.vim"
Searching for "/home/w/.vim/after/scripts.vim"
line 0:  endif
Executing BufNewFile Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif

line 0: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 0:    setf FALLBACK conf | endif
line 0:  endif
Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('/home/w/repo/inz/kernel/References')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand call <SID>BufWinEnterHandler()

line 0: call <SID>BufWinEnterHandler()
calling function <SNR>32_BufWinEnterHandler()

line 1:   if s:NewTabCreated
line 2:     " Turn off the 'NewTabCreated' flag
line 3:     let s:NewTabCreated = 0
line 4: 
line 5:     " Restore focus to NERDTree if necessary
line 6:     if !g:nerdtree_tabs_focus_on_files
line 7:       call s:NERDTreeRestoreFocus()
line 8:     endif
line 9:   endif
function <SNR>32_BufWinEnterHandler returning #0

continuing in BufWinEnter Autocommands for "*"

line 2: unlet! b:keymap_name
line 3:     setlocal noswapfile
line 4:     setlocal buftype=nowrite
line 5:     setlocal bufhidden=delete
line 6:     setlocal nowrap
line 7:     setlocal tw=0
line 8: 
line 9:     iabc <buffer>
line 10: 
line 11:     setlocal modifiable
line 12:     silent normal ggdG
line 13:     setlocal nomodifiable
line 14:     let b:rtagsLocations=[]
line 15:     call rtags#AddReferences(a:results, -1)
calling function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences[15]..rtags#AddReferences(['Not indexed'], -1)

line 1:     let ln = line(".")
line 2:     let depth = 0
line 3:     let nr = len(b:rtagsLocations)
line 4:     let i = -1
line 5:     " If a reference number is provided, find this entry in the list and insert
line 6:     " after it.
line 7:     if a:rnum >= 0
line 8:         let i = 0
line 9:         while i < nr && b:rtagsLocations[i].rnum != a:rnum
line 10:             let i += 1
line 11:         endwhile
line 12:         if i == nr
line 13:             " We didn't find the source record, something went wrong
line 14:             echo "Error finding insertion point."
line 15:             return
line 16:         endif
line 17:         let depth = b:rtagsLocations[i].depth + 1
line 18:         exec (":" . (i + 1))
line 19:     endif
line 20:     let prefix = repeat(" ", depth * 2)
line 21:     let new_entries = []
line 22:     setlocal modifiable
line 23:     for record in a:results
line 24:         let [line; sourcefunc] = split(record, '\s\+function: ')
line 25:         let [location; rest] = split(line, '\s\+')
line 26:         let [file, lnum, col] = rtags#parseSourceLocation(location)
calling function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences[15]..rtags#AddReferences[26]..rtags#parseSourceLocation('Not')

line 1:     let [location; symbol_detail] = split(a:string, '\s\+')
line 2:     let splittedLine = split(location, ':')
line 3:     if len(splittedLine) == 3
line 4:         let [jump_file, lnum, col; rest] = splittedLine
line 5:         " Must be a path, therefore leading / is compulsory
line 6:         if jump_file[0] == '/'
line 7:             return [jump_file, lnum, col]
line 8:         endif
line 9:     endif
line 10:     return ["","",""]
function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences[15]..rtags#AddReferences[26]..rtags#parseSourceLocation returning ['', '', '']

continuing in function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences[15]..rtags#AddReferences

line 27:         let entry = {}
line 28:         let entry.filename = substitute(file, getcwd().'/', '', 'g')
line 29:         let entry.filepath = file
line 30:         let entry.lnum = lnum
line 31:         let entry.col = col
line 32:         let entry.vcol = 0
line 33:         let entry.text = join(rest, ' ')
line 34:         let entry.type = 'ref'
line 35:         let entry.depth = depth
line 36:         let entry.source = matchstr(sourcefunc, '[^\s]\+')
line 37:         let entry.rnum = nr
line 38:         silent execute "normal! A\<cr>\<esc>i".prefix . substitute(entry.filename, '.*/', '', 'g').':'.entry.lnum.' '.entry.text."\<esc>"
line 38: normal! A^M^[i: indexed^[
line 39:         call add(new_entries, entry)
line 40:         let nr = nr + 1
line 41:     endfor
line 23:     for record in a:results
line 24:         let [line; sourcefunc] = split(record, '\s\+function: ')
line 25:         let [location; rest] = split(line, '\s\+')
line 26:         let [file, lnum, col] = rtags#parseSourceLocation(location)
line 27:         let entry = {}
line 28:         let entry.filename = substitute(file, getcwd().'/', '', 'g')
line 29:         let entry.filepath = file
line 30:         let entry.lnum = lnum
line 31:         let entry.col = col
line 32:         let entry.vcol = 0
line 33:         let entry.text = join(rest, ' ')
line 34:         let entry.type = 'ref'
line 35:         let entry.depth = depth
line 36:         let entry.source = matchstr(sourcefunc, '[^\s]\+')
line 37:         let entry.rnum = nr
line 38:         silent execute "normal! A\<cr>\<esc>i".prefix . substitute(entry.filename, '.*/', '', 'g').':'.entry.lnum.' '.entry.text."\<esc>"
line 39:         call add(new_entries, entry)
line 40:         let nr = nr + 1
line 41:     endfor
line 42:     call extend(b:rtagsLocations, new_entries, i + 1)
line 43:     setlocal nomodifiable
line 44:     exec (":" . ln)
line 44: :1
function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences[15]..rtags#AddReferences returning #0

continuing in function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences

line 16:     setlocal modifiable
line 17:     silent normal ggdd
line 18:     setlocal nomodifiable
line 19: 
line 20:     let cpo_save = &cpo
line 21:     set cpo&vim
line 22:     nnoremap <buffer> <cr> :call <SID>OpenReference()<cr>
line 23:     nnoremap <buffer> o    :call <SID>ExpandReferences()<cr>
line 24:     let &cpo = cpo_save
function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers[9]..rtags#ViewReferences returning #0

continuing in function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers

line 10:             catch /E706/
line 11:                 " If we're not returning the right type we're probably done
line 12:                 return
line 13:             endtry
line 14:         endif
line 15:     endfor 
line 2:     for Handler in a:handlers
line 3:         if type(Handler) == 3
line 4:             let HandlerFunc = Handler[0]
line 5:             let args = Handler[1]
line 6:             call HandlerFunc(result, args)
line 7:         else
line 8:             try
line 9:                 let result = Handler(result)
line 10:             catch /E706/
line 11:                 " If we're not returning the right type we're probably done
line 12:                 return
line 13:             endtry
line 14:         endif
line 15:     endfor 
function <lambda>2[1]..rtags#HandleResults[11]..rtags#ExecuteHandlers returning #0

continuing in function <lambda>2[1]..rtags#HandleResults

line 12:     else
line 13:         let job_cid = remove(s:jobs, a:job_id)
line 14:         let temp_file = rtags#TempFile(job_cid)
line 15:         let output = readfile(temp_file)
line 16:         let handlers = remove(s:result_handlers, a:job_id)
line 17:         call rtags#ExecuteHandlers(output, handlers)
line 18:         execute 'silent !rm -f ' . temp_file
line 19:     endif
line 20: 
function <lambda>2[1]..rtags#HandleResults returning #0

continuing in function <lambda>2

function <lambda>2 returning #0

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>38_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>38_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"


Writing viminfo file "/home/w/.viminfo"